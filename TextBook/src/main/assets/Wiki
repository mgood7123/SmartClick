UTF-8
From Wikipedia, the free encyclopedia
Jump to navigationJump to search
UTF-8
Standard	Unicode Standard
Classification	Unicode Transformation Format, extended ASCII, variable-width encoding
Extends	US-ASCII
Transforms / Encodes	ISO 10646 (Unicode)
Preceded by	UTF-1
vte
UTF-8 is a variable-width character encoding used for electronic communication. Defined by the Unicode Standard, the name is derived from Unicode (or Universal Coded Character Set) Transformation Format ‚Äì 8-bit.[1]

UTF-8 is capable of encoding all 1,112,064[nb 1] valid character code points in Unicode using one to four one-byte (8-bit) code units. Code points with lower numerical values, which tend to occur more frequently, are encoded using fewer bytes. It was designed for backward compatibility with ASCII: the first 128 characters of Unicode, which correspond one-to-one with ASCII, are encoded using a single byte with the same binary value as ASCII, so that valid ASCII text is valid UTF-8-encoded Unicode as well. Since ASCII bytes do not occur when encoding non-ASCII code points into UTF-8, UTF-8 is safe to use within most programming and document languages that interpret certain ASCII characters in a special way, such as "/" (slash) in filenames, "\" (backslash) in escape sequences, and "%" in printf.

UTF-8 was designed as a superior alternative to UTF-1, a proposed variable-width encoding with partial ASCII compatibility which lacked some features including self-synchronization and fully ASCII-compatible handling of characters such as slashes. Ken Thompson and Rob Pike produced the first implementation for the Plan 9 operating system in September 1992.[2][3] This led to its adoption by X/Open as its specification for FSS-UTF, which would first be officially presented at USENIX in January 1993 and subsequently adopted by the Internet Engineering Task Force (IETF) in RFC 2277 (BCP 18) for future Internet standards work, replacing Single Byte Character Sets such as Latin-1 in older RFCs.

UTF-8 is by far the most common encoding for the World Wide Web, accounting for over 95% of all web pages, and up to 100% for some languages, as of 2020.[4]


Contents
1	Adoption
2	Encoding
2.1	Examples
2.2	Codepage layout
2.3	Overlong encodings
2.4	Invalid sequences and error handling
2.5	Byte order mark
3	Naming
4	History
5	Standards
6	Comparison with other encodings
6.1	Single-byte
6.2	Other multi-byte
6.3	UTF-16
7	Derivatives
7.1	CESU-8
7.2	MySQL utf8mb3
7.3	Modified UTF-8
7.4	WTF-8
7.5	PEP 383
8	See also
9	Notes
10	References
11	External links
Adoption[edit]

Use of the main encodings on the web from 2001 to 2012 as recorded by Google,[5] with UTF-8 overtaking all others in 2008 and over 60% of the web in 2012. The ASCII-only figure includes all web pages that only contain ASCII characters, regardless of the declared header.
UTF-8 is the recommendation from the WHATWG for HTML and DOM specifications,[6] and the Internet Mail Consortium recommends that all e-mail programs be able to display and create mail using UTF-8.[7][8]

Google reported that in 2008, UTF-8 (labelled "Unicode") became the most common encoding for HTML files.[9]

Since 2009, UTF-8 has been the most common encoding for the World Wide Web.[4] The World Wide Web Consortium recommends UTF-8 as the default encoding in XML and HTML (and not just using UTF-8, also stating it in metadata), "even when all characters are in the ASCII range .. Using non-UTF-8 encodings can have unexpected results".[10] Many other standards only support UTF-8, e.g. open JSON exchange requires it.[11]

As of October 2020, UTF-8 accounts on average for 95.5% of all web pages and 97% of the top 1,000 highest ranked web pages.[4] (This takes into account that ASCII is valid UTF-8.[12]) Several languages have 100.0% use of UTF-8 on the web, such as Punjabi, Tagalog, Lao, Marathi, Kannada, Kurdish, Pashto, Javanese, Greenlandic (Kalaallisut) and Iranian languages[13] and sign languages.[14]

In locales where UTF-8 is used alongside another encoding, the latter is typically more efficient for the associated language. The Chinese standard GB 2312 and with its extension GBK (which are both interpreted by web browsers as GB 18030, having support for the same letters as UTF-8) have a combined 14.5% share in China[15][16] and a 0.5% share world-wide. Big5 is another popular Chinese encoding with 0.1% share world-wide. The single-byte Windows-1251 is twice as efficient for the Cyrillic script and is used for 10.6% of Russian web sites.[17] E.g. Greek and Hebrew encodings are also twice as efficient, but still those languages have over 95% use of UTF-8.[18][19] EUC-KR is more efficient for Korean text and is used for 17.3% of South Korean websites. Shift JIS and EUC-JP have a 10.5% share on Japanese websites (the more popular Shift JIS has 0.2% global share).[20][21][5] With the exception of GB 18030 and UTF-16, these encodings were designed for specific languages, and do not support all Unicode characters. As of September 2020, the Breton language has the lowest UTF-8 use on the Web of any tracked language, with 79.4% use.[22]

International Components for Unicode (ICU) has historically used UTF-16, and still does only for Java; while for C/C++ UTF-8 is now supported as the "Default Charset",[23] including the correct handling of "illegal UTF-8".[24]

For local text files UTF-8 usage is lower, and many legacy single-byte encodings remain in use. This is primarily due to editors that will not display or write UTF-8 unless the first character in a file is a byte order mark, making it impossible for other software to use UTF-8 without being rewritten to ignore the byte order mark on input and add it on output. UTF-16 files are also fairly common on Windows, but not elsewhere.[original research?] Internally in software usage is even lower, with UCS-2 and UTF-32 in use, particularly in Windows but also Python, JavaScript, Qt, and many other software libraries. This is due to a belief that direct indexing of code points is more important than 8-bit compatibility.[citation needed] UTF-16 is also used due to being compatible with UCS-2, even though it does not have direct indexing. Microsoft now recommends UTF-8 for Windows programs,[25] while previously they emphasized "Unicode" (meaning UTF-16) Win32 API, this may mean internal use of UTF-8 will increase in the future.[original research?]

Encoding[edit]
Since the restriction of the Unicode code-space to 21-bit values in 2003, UTF-8 is defined to encode code points in one to four bytes, depending on the number of significant bits in the numerical value of the code point. The following table shows the structure of the encoding. The x characters are replaced by the bits of the code point.

Layout of UTF-8 byte sequences
Number of bytes	First code point	Last code point	Byte 1	Byte 2	Byte 3	Byte 4
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+07FF	110xxxxx	10xxxxxx
3	U+0800	U+FFFF	1110xxxx	10xxxxxx	10xxxxxx
4	U+10000	[nb 2]U+10FFFF	11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
The first 128 characters (US-ASCII) need one byte. The next 1,920 characters need two bytes to encode, which covers the remainder of almost all Latin-script alphabets, and also Greek, Cyrillic, Coptic, Armenian, Hebrew, Arabic, Syriac, Thaana and N'Ko alphabets, as well as Combining Diacritical Marks. Three bytes are needed for characters in the rest of the Basic Multilingual Plane, which contains virtually all characters in common use,[26] including most Chinese, Japanese and Korean characters. Four bytes are needed for characters in the other planes of Unicode, which include less common CJK characters, various historic scripts, mathematical symbols, and emoji (pictographic symbols).

Examples[edit]
Consider the encoding of the Euro sign, ‚Ç¨:

The Unicode code point for "‚Ç¨" is U+20AC.
As this code point lies between U+0800 and U+FFFF, this will take three bytes to encode.
Hexadecimal 20AC is binary 0010 0000 1010 1100. The two leading zeros are added because a three-byte encoding needs exactly sixteen bits from the code point.
Because the encoding will be three bytes long, its leading byte starts with three 1s, then a 0 (1110...)
The four most significant bits of the code point are stored in the remaining low order four bits of this byte (1110 0010), leaving 12 bits of the code point yet to be encoded (...0000 1010 1100).
All continuation bytes contain exactly six bits from the code point. So the next six bits of the code point are stored in the low order six bits of the next byte, and 10 is stored in the high order two bits to mark it as a continuation byte (so 1000 0010).
Finally the last six bits of the code point are stored in the low order six bits of the final byte, and again 10 is stored in the high order two bits (1010 1100).
The three bytes 1110 0010 1000 0010 1010 1100 can be more concisely written in hexadecimal, as E2 82 AC.

The following table summarises this conversion, as well as others with different lengths in UTF-8. The colors indicate how bits from the code point are distributed among the UTF-8 bytes. Additional bits added by the UTF-8 encoding process are shown in black.

Representation of UTF-8 characters
Character	Code point	UTF-8
Octal	Binary	Binary	Octal	Hexadecimal
$	U+0024	044	010 0100	00100100	044	24
¬¢	U+00A2	0242	000 1010 0010	11000010 10100010	302 242	C2 A2
‡§π	U+0939	004471	0000 1001 0011 1001	11100000 10100100 10111001	340 244 271	E0 A4 B9
‚Ç¨	U+20AC	020254	0010 0000 1010 1100	11100010 10000010 10101100	342 202 254	E2 82 AC
Ìïú	U+D55C	152534	1101 0101 0101 1100	11101101 10010101 10011100	355 225 234	ED 95 9C
êçà	U+10348	0201510	0 0001 0000 0011 0100 1000	11110000 10010000 10001101 10001000	360 220 215 210	F0 90 8D 88
UTF-8's use of six bits per byte to represent the actual characters being encoded means that octal notation (which uses 3-bit groups) can aid in the comparison of UTF-8 sequences with one another.[27]

Codepage layout[edit]
The following table summarizes usage of UTF-8 code units (individual bytes or octets) in a code page format. The upper half (0_ to 7_) is for bytes used only in single-byte codes, so it looks like a normal code page; the lower half is for continuation bytes (8_ to B_) and leading bytes (C_ to F_), and is explained further in the legend below.

UTF-8
_0	_1	_2	_3	_4	_5	_6	_7	_8	_9	_A	_B	_C	_D	_E	_F
0_	NUL
0000	SOH
0001	STX
0002	ETX
0003	EOT
0004	ENQ
0005	ACK
0006	BEL
0007	BS
0008	HT
0009	LF
000A	VT
000B	FF
000C	CR
000D	SO
000E	SI
000F
1_	DLE
0010	DC1
0011	DC2
0012	DC3
0013	DC4
0014	NAK
0015	SYN
0016	ETB
0017	CAN
0018	EM
0019	SUB
001A	ESC
001B	FS
001C	GS
001D	RS
001E	US
001F
2_	SP
0020	!
0021	"
0022	#
0023	$
0024	%
0025	&
0026	'
0027	(
0028	)
0029	*
002A	+
002B	,
002C	-
002D	.
002E	/
002F
3_	0
0030	1
0031	2
0032	3
0033	4
0034	5
0035	6
0036	7
0037	8
0038	9
0039	:
003A	;
003B	<
003C	=
003D	>
003E	?
003F
4_	@
0040	A
0041	B
0042	C
0043	D
0044	E
0045	F
0046	G
0047	H
0048	I
0049	J
004A	K
004B	L
004C	M
004D	N
004E	O
004F
5_	P
0050	Q
0051	R
0052	S
0053	T
0054	U
0055	V
0056	W
0057	X
0058	Y
0059	Z
005A	[
005B	\
005C	]
005D	^
005E	_
005F
6_	`
0060	a
0061	b
0062	c
0063	d
0064	e
0065	f
0066	g
0067	h
0068	i
0069	j
006A	k
006B	l
006C	m
006D	n
006E	o
006F
7_	p
0070	q
0071	r
0072	s
0073	t
0074	u
0075	v
0076	w
0077	x
0078	y
0079	z
007A	{
007B	|
007C	}
007D	~
007E	DEL
007F
8_	‚Ä¢
+00	‚Ä¢
+01	‚Ä¢
+02	‚Ä¢
+03	‚Ä¢
+04	‚Ä¢
+05	‚Ä¢
+06	‚Ä¢
+07	‚Ä¢
+08	‚Ä¢
+09	‚Ä¢
+0A	‚Ä¢
+0B	‚Ä¢
+0C	‚Ä¢
+0D	‚Ä¢
+0E	‚Ä¢
+0F
9_	‚Ä¢
+10	‚Ä¢
+11	‚Ä¢
+12	‚Ä¢
+13	‚Ä¢
+14	‚Ä¢
+15	‚Ä¢
+16	‚Ä¢
+17	‚Ä¢
+18	‚Ä¢
+19	‚Ä¢
+1A	‚Ä¢
+1B	‚Ä¢
+1C	‚Ä¢
+1D	‚Ä¢
+1E	‚Ä¢
+1F
A_	‚Ä¢
+20	‚Ä¢
+21	‚Ä¢
+22	‚Ä¢
+23	‚Ä¢
+24	‚Ä¢
+25	‚Ä¢
+26	‚Ä¢
+27	‚Ä¢
+28	‚Ä¢
+29	‚Ä¢
+2A	‚Ä¢
+2B	‚Ä¢
+2C	‚Ä¢
+2D	‚Ä¢
+2E	‚Ä¢
+2F
B_	‚Ä¢
+30	‚Ä¢
+31	‚Ä¢
+32	‚Ä¢
+33	‚Ä¢
+34	‚Ä¢
+35	‚Ä¢
+36	‚Ä¢
+37	‚Ä¢
+38	‚Ä¢
+39	‚Ä¢
+3A	‚Ä¢
+3B	‚Ä¢
+3C	‚Ä¢
+3D	‚Ä¢
+3E	‚Ä¢
+3F
2
C_	2
0000	2
0040	Latin
0080	Latin
00C0	Latin
0100	Latin
0140	Latin
0180	Latin
01C0	Latin
0200	IPA
0240	IPA
0280	IPA
02C0	accents
0300	accents
0340	Greek
0380	Greek
03C0
2
D_	Cyril
0400	Cyril
0440	Cyril
0480	Cyril
04C0	Cyril
0500	Armeni
0540	Hebrew
0580	Hebrew
05C0	Arabic
0600	Arabic
0640	Arabic
0680	Arabic
06C0	Syriac
0700	Arabic
0740	Thaana
0780	N'Ko
07C0
3
E_	Indic
0800	Misc.
1000	Symbol
2000	Kana‚Ä¶
3000	CJK
4000	CJK
5000	CJK
6000	CJK
7000	CJK
8000	CJK
9000	Asian
A000	Hangul
B000	Hangul
C000	Hangul
D000	PUA
E000	Forms
F000
4
F_	SMP‚Ä¶
10000	ÒÄÄÄ
40000	ÚÄÄÄ
80000	SSP‚Ä¶
C0000	SPU‚Ä¶
100000	4
140000	4
180000	4
1C0000	5
200000	5
1000000	5
2000000	5
3000000	6
4000000	6
40000000
  Blue cells are 7-bit (single-byte) sequences. They must not be followed by a continuation byte.[28]

  Orange cells with a large dot are continuation bytes.[29] The hexadecimal number shown after the + symbol is the value of the 6 bits they add.

  White cells are the leading bytes for a sequence of multiple bytes,[30] the length shown at the left edge of the row. The text shows the Unicode blocks encoded by sequences starting with this byte, and the hexadecimal code point shown in the cell is the lowest character value encoded using that leading byte.

  Red cells must never appear in a valid UTF-8 sequence. The first two red cells (C0 and C1) could be used only for a 2-byte encoding of a 7-bit ASCII character which should be encoded in 1 byte; as described below, such "overlong" sequences are disallowed.[31] The red cells in the F_ row (F5 to FD) indicate leading bytes of 4-byte or longer sequences that cannot be valid because they would encode code points larger than the U+10FFFF limit of Unicode (a limit derived from the maximum code point encodable in UTF-16 [32]). FE and FF do not match any allowed character pattern and are therefore not valid start bytes.[33]

  Pink cells are the leading bytes for a sequence of multiple bytes, of which some, but not all, possible continuation sequences are valid. E0 and F0 could start overlong encodings, in this case the lowest non-overlong-encoded code point is shown. F4 can start code points greater than U+10FFFF which are invalid. ED can start the encoding of a code point in the range U+D800‚ÄìU+DFFF; these are invalid since they are reserved for UTF-16 surrogate halves.[34]

Overlong encodings[edit]
In principle, it would be possible to inflate the number of bytes in an encoding by padding the code point with leading 0s. To encode the Euro sign ‚Ç¨ from the above example in four bytes instead of three, it could be padded with leading 0s until it was 21 bits long ‚Äì 000 000010 000010 101100, and encoded as 11110000 10000010 10000010 10101100 (or F0 82 82 AC in hexadecimal). This is called an overlong encoding.

The standard specifies that the correct encoding of a code point uses only the minimum number of bytes required to hold the significant bits of the code point. Longer encodings are called overlong and are not valid UTF-8 representations of the code point. This rule maintains a one-to-one correspondence between code points and their valid encodings, so that there is a unique valid encoding for each code point. This ensures that string comparisons and searches are well-defined.

Invalid sequences and error handling[edit]
Not all sequences of bytes are valid UTF-8. A UTF-8 decoder should be prepared for:

invalid bytes
an unexpected continuation byte
a non-continuation byte before the end of the character
the string ending before the end of the character (which can happen in simple string truncation)
an overlong encoding
a sequence that decodes to an invalid code point
Many of the first UTF-8 decoders would decode these, ignoring incorrect bits and accepting overlong results. Carefully crafted invalid UTF-8 could make them either skip or create ASCII characters such as NUL, slash, or quotes. Invalid UTF-8 has been used to bypass security validations in high-profile products including Microsoft's IIS web server[35] and Apache's Tomcat servlet container.[36] RFC 3629 states "Implementations of the decoding algorithm MUST protect against decoding invalid sequences."[37] The Unicode Standard requires decoders to "...treat any ill-formed code unit sequence as an error condition. This guarantees that it will neither interpret nor emit an ill-formed code unit sequence."

Since RFC 3629 (November 2003), the high and low surrogate halves used by UTF-16 (U+D800 through U+DFFF) and code points not encodable by UTF-16 (those after U+10FFFF) are not legal Unicode values, and their UTF-8 encoding must be treated as an invalid byte sequence. Not decoding unpaired surrogate halves makes it impossible to store invalid UTF-16 (such as Windows filenames or UTF-16 that has been split between the surrogates) as UTF-8.[citation needed]

Some implementations of decoders throw exceptions on errors.[38] This has the disadvantage that it can turn what would otherwise be harmless errors (such as a "no such file" error) into a denial of service. For instance early versions of Python 3.0 would exit immediately if the command line or environment variables contained invalid UTF-8.[39] An alternative practice is to replace errors with a replacement character. Since Unicode 6[40] (October 2010), the standard (chapter 3) has recommended a "best practice" where the error ends as soon as a disallowed byte is encountered. In these decoders E1,A0,C0 is two errors (2 bytes in the first one). This means an error is no more than three bytes long and never contains the start of a valid character, and there are 21,952 different possible errors.[41] The standard also recommends replacing each error with the replacement character "ÔøΩ" (U+FFFD).

Byte order mark[edit]
If the UTF-16 Unicode byte order mark (BOM) character is at the start of a UTF-8 file, the first three bytes will be 0xEF, 0xBB, 0xBF.

The Unicode Standard neither requires nor recommends the use of the BOM for UTF-8, but warns that it may be encountered at the start of a file trans-coded from another encoding.[42] While ASCII text encoded using UTF-8 is backward compatible with ASCII, this is not true when Unicode Standard recommendations are ignored and a BOM is added. Nevertheless, there was and still is software that always inserts a BOM when writing UTF-8, and refuses to correctly interpret UTF-8 unless the first character is a BOM (or the file only contains ASCII).[citation needed]

Naming[edit]
The official Internet Assigned Numbers Authority (IANA) code for the encoding is "UTF-8".[43] All letters are upper-case, and the name is hyphenated. This spelling is used in all the Unicode Consortium documents relating to the encoding.

Alternatively, the name "utf-8" may be used by all standards conforming to the IANA list (which include CSS, HTML, XML, and HTTP headers),[44] as the declaration is case insensitive.[43]

Other descriptions, such as those that omit the hyphen or replace it with a space, i.e. "utf8" or "UTF 8", are not accepted as correct by the governing standards.[37] Despite this, most agents such as browsers can understand them, and so standards intended to describe existing practice (such as HTML5) may effectively require their recognition.[45]

Unofficially, UTF-8-BOM and UTF-8-NOBOM are sometimes used to refer to text files which respectively contain and lack a byte order mark (BOM).[citation needed] In Japan especially, UTF-8 encoding without BOM is sometimes called "UTF-8N".[46][47]

Windows 7 and later, i.e. all supported Windows versions, have codepage 65001, as a synonym for UTF-8 (with better support than in older Windows),[48] and Microsoft has a script for Windows 10, to enable it by default for its program Microsoft Notepad.[49]

In PCL, UTF-8 is called Symbol-ID "18N" (PCL supports 183 character encodings, called Symbol Sets, which potentially could be reduced to one, 18N, that is UTF-8).[50]

History[edit]
See also: Universal Coded Character Set ¬ß History
The International Organization for Standardization (ISO) set out to compose a universal multi-byte character set in 1989. The draft ISO 10646 standard contained a non-required annex called UTF-1 that provided a byte stream encoding of its 32-bit code points. This encoding was not satisfactory on performance grounds, among other problems, and the biggest problem was probably that it did not have a clear separation between ASCII and non-ASCII: new UTF-1 tools would be backward compatible with ASCII-encoded text, but UTF-1-encoded text could confuse existing code expecting ASCII (or extended ASCII), because it could contain continuation bytes in the range 0x21‚Äì0x7E that meant something else in ASCII, e.g., 0x2F for '/', the Unix path directory separator, and this example is reflected in the name and introductory text of its replacement. The table below was derived from a textual description in the annex.

UTF-1
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5
1	U+0000	U+009F	00‚Äì9F
2	U+00A0	U+00FF	A0	A0‚ÄìFF
2	U+0100	U+4015	A1‚ÄìF5	21‚Äì7E, A0‚ÄìFF
3	U+4016	U+38E2D	F6‚ÄìFB	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF
5	U+38E2E	U+7FFFFFFF	FC‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF
In July 1992, the X/Open committee XoJIG was looking for a better encoding. Dave Prosser of Unix System Laboratories submitted a proposal for one that had faster implementation characteristics and introduced the improvement that 7-bit ASCII characters would only represent themselves; all multi-byte sequences would include only bytes where the high bit was set. The name File System Safe UCS Transformation Format (FSS-UTF) and most of the text of this proposal were later preserved in the final specification.[51][52][53][54]

FSS-UTF proposal (1992)
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+207F	10xxxxxx	1xxxxxxx
3	U+2080	U+8207F	110xxxxx	1xxxxxxx	1xxxxxxx
4	U+82080	U+208207F	1110xxxx	1xxxxxxx	1xxxxxxx	1xxxxxxx
5	U+2082080	U+7FFFFFFF	11110xxx	1xxxxxxx	1xxxxxxx	1xxxxxxx	1xxxxxxx
In August 1992, this proposal was circulated by an IBM X/Open representative to interested parties. A modification by Ken Thompson of the Plan 9 operating system group at Bell Labs made it somewhat less bit-efficient than the previous proposal but crucially allowed it to be self-synchronizing, letting a reader start anywhere and immediately detect byte sequence boundaries. It also abandoned the use of biases and instead added the rule that only the shortest possible encoding is allowed; the additional loss in compactness is relatively insignificant, but readers now have to look out for invalid encodings to avoid reliability and especially security issues. Thompson's design was outlined on September 2, 1992, on a placemat in a New Jersey diner with Rob Pike. In the following days, Pike and Thompson implemented it and updated Plan 9 to use it throughout, and then communicated their success back to X/Open, which accepted it as the specification for FSS-UTF.[53]

FSS-UTF (1992) / UTF-8 (1993)[2]
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5	Byte 6
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+07FF	110xxxxx	10xxxxxx
3	U+0800	U+FFFF	1110xxxx	10xxxxxx	10xxxxxx
4	U+10000	U+1FFFFF	11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
5	U+200000	U+3FFFFFF	111110xx	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx
6	U+4000000	U+7FFFFFFF	1111110x	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx
UTF-8 was first officially presented at the USENIX conference in San Diego, from January 25 to 29, 1993. The Internet Engineering Task Force adopted UTF-8 in its Policy on Character Sets and Languages in RFC 2277 (BCP 18) for future Internet standards work, replacing Single Byte Character Sets such as Latin-1 in older RFCs.[55]

In November 2003, UTF-8 was restricted by RFC 3629 to match the constraints of the UTF-16 character encoding: explicitly prohibiting code points corresponding to the high and low surrogate characters removed more than 3% of the three-byte sequences, and ending at U+10FFFF removed more than 48% of the four-byte sequences and all five- and six-byte sequences.

Standards[edit]
There are several current definitions of UTF-8 in various standards documents:

RFC 3629 / STD 63 (2003), which establishes UTF-8 as a standard Internet protocol element
RFC 5198 defines UTF-8 NFC for Network Interchange (2008)
ISO/IEC 10646:2014 ¬ß9.1 (2014)[56]
The Unicode Standard, Version 11.0 (2018)[57]
They supersede the definitions given in the following obsolete works:

The Unicode Standard, Version 2.0, Appendix A (1996)
ISO/IEC 10646-1:1993 Amendment 2 / Annex R (1996)
RFC 2044 (1996)
RFC 2279 (1998)
The Unicode Standard, Version 3.0, ¬ß2.3 (2000) plus Corrigendum #1 : UTF-8 Shortest Form (2000)
Unicode Standard Annex #27: Unicode 3.1 (2001)[58]
The Unicode Standard, Version 5.0 (2006)[59]
The Unicode Standard, Version 6.0 (2010)[60]
They are all the same in their general mechanics, with the main differences being on issues such as allowed range of code point values and safe handling of invalid input.

Comparison with other encodings[edit]
See also: Comparison of Unicode encodings
Some of the important features of this encoding are as follows:

Backward compatibility: Backward compatibility with ASCII and the enormous amount of software designed to process ASCII-encoded text was the main driving force behind the design of UTF-8. In UTF-8, single bytes with values in the range of 0 to 127 map directly to Unicode code points in the ASCII range. Single bytes in this range represent characters, as they do in ASCII. Moreover, 7-bit bytes (bytes where the most significant bit is 0) never appear in a multi-byte sequence, and no valid multi-byte sequence decodes to an ASCII code-point. A sequence of 7-bit bytes is both valid ASCII and valid UTF-8, and under either interpretation represents the same sequence of characters. Therefore, the 7-bit bytes in a UTF-8 stream represent all and only the ASCII characters in the stream. Thus, many text processors, parsers, protocols, file formats, text display programs, etc., which use ASCII characters for formatting and control purposes, will continue to work as intended by treating the UTF-8 byte stream as a sequence of single-byte characters, without decoding the multi-byte sequences. ASCII characters on which the processing turns, such as punctuation, whitespace, and control characters will never be encoded as multi-byte sequences. It is therefore safe for such processors to simply ignore or pass-through the multi-byte sequences, without decoding them. For example, ASCII whitespace may be used to tokenize a UTF-8 stream into words; ASCII line-feeds may be used to split a UTF-8 stream into lines; and ASCII NUL characters can be used to split UTF-8-encoded data into null-terminated strings. Similarly, many format strings used by library functions like "printf" will correctly handle UTF-8-encoded input arguments.
Fallback and auto-detection: Only a small subset of possible byte strings are a valid UTF-8 string: the bytes C0, C1, and F5 through FF cannot appear, and bytes with the high bit set must be in pairs, and other requirements. It is extremely unlikely that a readable text in any extended ASCII is valid UTF-8. Part of the popularity of UTF-8 is due to it providing a form of backward compatibility for these as well. A UTF-8 processor which erroneously receives extended ASCII as input can thus "auto-detect" this with very high reliability. Fallback errors will be false negatives, and these will be rare. Moreover, in many applications, such as text display, the consequence of incorrect fallback is usually slight.[original research?] A UTF-8 stream may simply contain errors, resulting in the auto-detection scheme producing false positives; but auto-detection is successful in the majority of cases, especially with longer texts, and is widely used. It also works to "fall back" or replace 8-bit bytes using the appropriate code-point for a legacy encoding only when errors in the UTF-8 are detected, allowing recovery even if UTF-8 and legacy encoding is concatenated in the same file.
Prefix code: The first byte indicates the number of bytes in the sequence. Reading from a stream can instantaneously decode each individual fully received sequence, without first having to wait for either the first byte of a next sequence or an end-of-stream indication. The length of multi-byte sequences is easily determined by humans as it is simply the number of high-order 1s in the leading byte. An incorrect character will not be decoded if a stream ends mid-sequence.
Self-synchronization: The leading bytes and the continuation bytes do not share values (continuation bytes start with the bits 10 while single bytes start with 0 and longer lead bytes start with 11). This means a search will not accidentally find the sequence for one character starting in the middle of another character. It also means the start of a character can be found from a random position by backing up at most 3 bytes to find the leading byte. An incorrect character will not be decoded if a stream starts mid-sequence, and a shorter sequence will never appear inside a longer one.
Sorting order: The chosen values of the leading bytes means that a list of UTF-8 strings can be sorted in code point order by sorting the corresponding byte sequences.
Single-byte[edit]
UTF-8 can encode any Unicode character, avoiding the need to figure out and set a "code page" or otherwise indicate what character set is in use, and allowing output in multiple scripts at the same time. For many scripts there have been more than one single-byte encoding in usage, so even knowing the script was insufficient information to display it correctly.
The bytes 0xFE and 0xFF do not appear, so a valid UTF-8 stream never matches the UTF-16 byte order mark and thus cannot be confused with it. The absence of 0xFF (0377) also eliminates the need to escape this byte in Telnet (and FTP control connection).
UTF-8 encoded text is larger than specialized single-byte encodings except for plain ASCII characters. In the case of scripts which used 8-bit character sets with non-Latin characters encoded in the upper half (such as most Cyrillic and Greek alphabet code pages), characters in UTF-8 will be double the size. For some scripts, such as Thai and Devanagari (which is used by various South Asian languages), characters will triple in size. There are even examples where a single byte turns into a composite character in Unicode and is thus six times larger in UTF-8. This has caused objections in India and other countries.
It is possible in UTF-8 (or any other variable-length encoding) to split or truncate a string in the middle of a character. If the two pieces are not re-appended later before interpretation as characters, this can introduce an invalid sequence at both the end of the previous section and the start of the next, and some decoders will not preserve these bytes and result in data loss. Because UTF-8 is self-synchronizing this will however never introduce a different valid character, and it is also fairly easy to move the truncation point backward to the start of a character.
If the code points are all the same size, measurements of a fixed number of them is easy. Due to ASCII-era documentation where "character" is used as a synonym for "byte" this is often considered important. However, by measuring string positions using bytes instead of "characters" most algorithms can be easily and efficiently adapted for UTF-8. Searching for a string within a long string can for example be done byte by byte; the self-synchronization property prevents false positives.
Other multi-byte[edit]
UTF-8 can encode any Unicode character. Files in different scripts can be displayed correctly without having to choose the correct code page or font. For instance, Chinese and Arabic can be written in the same file without specialised markup or manual settings that specify an encoding.
UTF-8 is self-synchronizing: character boundaries are easily identified by scanning for well-defined bit patterns in either direction. If bytes are lost due to error or corruption, one can always locate the next valid character and resume processing. If there is a need to shorten a string to fit a specified field, the previous valid character can easily be found. Many multi-byte encodings such as Shift JIS are much harder to resynchronize. This also means that byte-oriented string-searching algorithms can be used with UTF-8 (as a character is the same as a "word" made up of that many bytes), optimized versions of byte searches can be much faster due to hardware support and lookup tables that have only 256 entries. Self-synchronization does however require that bits be reserved for these markers in every byte, increasing the size.
Efficient to encode using simple bitwise operations. UTF-8 does not require slower mathematical operations such as multiplication or division (unlike Shift JIS, GB 2312 and other encodings).
UTF-8 will take more space than a multi-byte encoding designed for a specific script. East Asian legacy encodings generally used two bytes per character yet take three bytes per character in UTF-8.
UTF-16[edit]
Byte encodings and UTF-8 are represented by byte arrays in programs, and often nothing needs to be done to a function when converting source code from a byte encoding to UTF-8. UTF-16 is represented by 16-bit word arrays, and converting to UTF-16 while maintaining compatibility with existing ASCII-based programs (such as was done with Windows) requires every API and data structure that takes a string to be duplicated, one version accepting byte strings and another version accepting UTF-16. If backward compatibility is not needed, all string handling still must be modified.
Text encoded in UTF-8 will be smaller than the same text encoded in UTF-16 if there are more code points below U+0080 than in the range U+0800..U+FFFF. This is true for all modern European languages.
Text in (for example) Chinese, Japanese or Devanagari will take more space in UTF-8 if there are more of these characters than there are ASCII characters. This is likely when data mainly consist of pure prose, but is lessened by the degree to which the context uses ASCII whitespace, digits, and punctuation.[nb 3]
Most of the rich text formats (including HTML) contain a large proportion of ASCII characters for the sake of formatting, thus the size usually will be reduced significantly compared with UTF-16, even when the language mostly uses 3-byte long characters in UTF-8.[nb 4]
Most communication (e.g. HTML and IP) and storage (e.g. for Unix) was designed for a stream of bytes. A UTF-16 string must use a pair of bytes for each code unit:
The order of those two bytes becomes an issue and must be specified in the UTF-16 protocol, such as with a byte order mark.
If an odd number of bytes is missing from UTF-16, the whole rest of the string will be meaningless text. Any bytes missing from UTF-8 will still allow the text to be recovered accurately starting with the next character after the missing bytes.
Derivatives[edit]
The following implementations show slight differences from the UTF-8 specification. They are incompatible with the UTF-8 specification and may be rejected by conforming UTF-8 applications.

CESU-8[edit]
Main article: CESU-8
Unicode Technical Report #26[61] assigns the name CESU-8 to a nonstandard variant of UTF-8, in which Unicode characters in supplementary planes are encoded using six bytes, rather than the four bytes required by UTF-8. CESU-8 encoding treats each half of a four-byte UTF-16 surrogate pair as a two-byte UCS-2 character, yielding two three-byte UTF-8 characters, which together represent the original supplementary character. Unicode characters within the Basic Multilingual Plane appear as they would normally in UTF-8. The Report was written to acknowledge and formalize the existence of data encoded as CESU-8, despite the Unicode Consortium discouraging its use, and notes that a possible intentional reason for CESU-8 encoding is preservation of UTF-16 binary collation.

CESU-8 encoding can result from converting UTF-16 data with supplementary characters to UTF-8, using conversion methods that assume UCS-2 data, meaning they are unaware of four-byte UTF-16 supplementary characters. It is primarily an issue on operating systems which extensively use UTF-16 internally, such as Microsoft Windows.[citation needed]

In Oracle Database, the UTF8 character set uses CESU-8 encoding, and is deprecated. The AL32UTF8 character set uses standards-compliant UTF-8 encoding, and is preferred.[62][63]

CESU-8 is prohibited for use in HTML5 documents.[64][65][66]

MySQL utf8mb3[edit]
In MySQL, the utf8mb3 character set is defined to be UTF-8 encoded data with a maximum of three bytes per character, meaning only Unicode characters in the Basic Multilingual Plane are supported. Unicode characters in supplementary planes are explicitly not supported. utf8mb3 is deprecated in favor of the utf8mb4 character set, which uses standards-compliant UTF-8 encoding. utf8 is an alias for utf8mb3, but is intended to become an alias to utf8mb4 in a future release of MySQL.[67] It is possible, though unsupported, to store CESU-8 encoded data in utf8mb3, by handling UTF-16 data with supplementary characters as though it is UCS-2.

Modified UTF-8[edit]
Modified UTF-8 (MUTF-8) originated in the Java programming language. In Modified UTF-8, the null character (U+0000) uses the two-byte overlong encoding 11000000 10000000 (hexadecimal C0 80), instead of 00000000 (hexadecimal 00).[68] Modified UTF-8 strings never contain any actual null bytes but can contain all Unicode code points including U+0000,[69] which allows such strings (with a null byte appended) to be processed by traditional null-terminated string functions. All known Modified UTF-8 implementations also treat the surrogate pairs as in CESU-8.

In normal usage, the language supports standard UTF-8 when reading and writing strings through InputStreamReader and OutputStreamWriter (if it is the platform's default character set or as requested by the program). However it uses Modified UTF-8 for object serialization[70] among other applications of DataInput and DataOutput, for the Java Native Interface,[71] and for embedding constant strings in class files.[72]

The dex format defined by Dalvik also uses the same modified UTF-8 to represent string values.[73] Tcl also uses the same modified UTF-8[74] as Java for internal representation of Unicode data, but uses strict CESU-8 for external data.

WTF-8[edit]

This section contains a list of miscellaneous information. Please relocate any relevant information into other sections or articles. (August 2020)
In WTF-8 (Wobbly Transformation Format, 8-bit) unpaired surrogate halves (U+D800 through U+DFFF) are allowed.[75] This is necessary to store possibly-invalid UTF-16, such as Windows filenames. Many systems that deal with UTF-8 work this way without considering it a different encoding, as it is simpler.[76]

(The term "WTF-8" has also been used humorously to refer to erroneously doubly-encoded UTF-8[77][78] sometimes with the implication that CP1252 bytes are the only ones encoded)[79]

PEP 383[edit]
Version 3 of the Python programming language treats each byte of an invalid UTF-8 bytestream as an error; this gives 128 different possible errors. Extensions have been created to allow any byte sequence that is assumed to be UTF-8 to be lossless transformed to UTF-16 or UTF-32, by translating the 128 possible error bytes to reserved code points, and transforming those code points back to error bytes to output UTF-8. The most common approach is to translate the codes to U+DC80...U+DCFF which are low (trailing) surrogate values and thus "invalid" UTF-16, as used by Python's PEP 383 (or "surrogateescape") approach.[80] Another encoding called MirBSD OPTU-8/16 converts them to U+EF80...U+EFFF in a Private Use Area.[81] In either approach, the byte value is encoded in the low eight bits of the output code point.

These encodings are very useful because they avoid the need to deal with "invalid" byte strings until much later, if at all, and allow "text" and "data" byte arrays to be the same object. If a program wants to use UTF-16 internally these are required to preserve and use filenames that can use invalid UTF-8;[82] as the Windows filesystem API uses UTF-16, the need to support invalid UTF-8 is less there.[80]

For the encoding to be reversible, the standard UTF-8 encodings of the code points used for erroneous bytes must be considered invalid. This makes the encoding incompatible with WTF-8 or CESU-8 (though only for 128 code points). When re-encoding it is necessary to be careful of sequences of error code points which convert back to valid UTF-8, which may be used by malicious software to get unexpected characters in the output, though this cannot produce ASCII characters so it is considered comparatively safe, since malicious sequences (such as cross-site scripting) usually rely on ASCII characters.[82]

See also[edit]
Alt code
Character encodings in HTML
Comparison of e-mail clients#Features
Comparison of Unicode encodings
Iconv
Specials (Unicode block)
Unicode and email
Unicode and HTML
Percent-encoding#Current standard
UTF-EBCDIC
Notes[edit]
^ 17 planes times 216 code points per plane, minus 211 technically-invalid surrogates.
^ You might expect larger code points than U+10FFFF to be expressible, but in RFC3629 ¬ß3 UTF-8 is limited to match the limits of UTF-16. (As ¬ß12 notes, this is changed from RFC 2279.)
^ The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi), when the pure text was pasted to Notepad, generated 19 KB when saved as UTF-16 and 22 KB when saved as UTF-8.
^ The 2010-10-27 version of UTF-8 (in Japanese) generated 169 KB when converted with Notepad to UTF-16, and only 101 KB when converted back to UTF-8. The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi) required 119 KB in UTF-16 and 76 KB in UTF-8.
References[edit]
^ "Chapter 2. General Structure". The Unicode Standard (6.0 ed.). Mountain View, California, US: The Unicode Consortium. ISBN 978-1-936213-01-6.
^ Jump up to: a b Pike, Rob (30 April 2003). "UTF-8 history".
^ Pike, Rob; Thompson, Ken (1993). "Hello World or ŒöŒ±ŒªŒ∑ŒºŒ≠œÅŒ± Œ∫œåœÉŒºŒµ or „Åì„Çì„Å´„Å°„ÅØ ‰∏ñÁïå" (PDF). Proceedings of the Winter 1993 USENIX Conference.
^ Jump up to: a b c "Usage Survey of Character Encodings broken down by Ranking". w3techs.com. Retrieved 2020-08-24.
^ Jump up to: a b Davis, Mark (2012-02-03). "Unicode over 60 percent of the web". Official Google Blog. Archived from the original on 2018-08-09. Retrieved 2020-07-24.
^ "Encoding Standard". encoding.spec.whatwg.org. Retrieved 2020-04-15.
^ "Using International Characters in Internet Mail". Internet Mail Consortium. 1998-08-01. Archived from the original on 2007-10-26. Retrieved 2007-11-08.
^ "Encoding Standard". encoding.spec.whatwg.org. Retrieved 2018-11-15.
^ Davis, Mark (2008-05-05). "Moving to Unicode 5.1". Retrieved 2013-03-01.
^ "Specifying the document's character encoding". HTML5.2. World Wide Web Consortium. 14 December 2017. Retrieved 2018-06-03.
^ "The JavaScript Object Notation (JSON) Data Interchange Format". IETF. December 2017. Retrieved 16 February 2018.
^ "Usage Statistics and Market Share of US-ASCII for Websites, August 2020". w3techs.com. Retrieved 2020-08-28.
^ "Distribution of Character Encodings among websites that use Iranian languages". w3techs.com. Retrieved 2018-12-03.
^ "Distribution of Character Encodings among websites that use Sign Languages". w3techs.com. Retrieved 2018-12-03.
^ "Distribution of Character Encodings among websites that use .cn". w3techs.com. Retrieved 2020-09-01.
^ "Distribution of Character Encodings among websites that use Chinese". w3techs.com. Retrieved 2020-07-03.
^ "Distribution of Character Encodings among websites that use .ru". w3techs.com. Retrieved 2020-09-01.
^ "Distribution of Character Encodings among websites that use Greek". w3techs.com. Retrieved 2020-09-07.
^ "Distribution of Character Encodings among websites that use Hebrew". w3techs.com. Retrieved 2020-09-07.
^ "Historical trends in the usage of character encodings". Retrieved 2020-07-24.
^ "UTF-8 Usage Statistics". BuiltWith. Retrieved 2011-03-28.
^ "Usage Report of UTF-8 broken down by Content Languages". w3techs.com. Retrieved 2020-09-07.
^ "UTF-8 - ICU User Guide". userguide.icu-project.org. Retrieved 2018-04-03.
^ "#13311 (change illegal-UTF-8 handling to Unicode "best practice")". bugs.icu-project.org. Retrieved 2018-04-03.
^ "Use the Windows UTF-8 code page". UWP applications. docs.microsoft.com. Retrieved 2020-06-06.
^ Allen, Julie D.; Anderson, Deborah; Becker, Joe; Cook, Richard, eds. (2012). "The Unicode Standard, Version 6.1". Mountain View, California: Unicode Consortium.
^ https://ci.apache.org/projects/flink/flink-docs-release-1.9/api/java/org/apache/flink/table/dataformat/BinaryString.html#compareTo-org.apache.flink.table.dataformat.BinaryString-
^ "Chapter 3", The Unicode Standard (PDF), p. 54
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ "Chapter 3", The Unicode Standard (PDF), p. 54
^ Yergeau, F. (November 2003). UTF-8, a transformation format of ISO 10646. IETF. doi:10.17487/RFC3629. STD 63. RFC 3629. Retrieved August 20, 2020.
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ Yergeau, F. (November 2003). UTF-8, a transformation format of ISO 10646. IETF. doi:10.17487/RFC3629. STD 63. RFC 3629. Retrieved August 20, 2020.
^ Marin, Marvin (2000-10-17). "Web Server Folder Traversal MS00-078".
^ "Summary for CVE-2008-2938". National Vulnerability Database.
^ Jump up to: a b Yergeau, F. (2003). UTF-8, a transformation format of ISO 10646. Internet Engineering Task Force. doi:10.17487/RFC3629. RFC 3629. Retrieved 2015-02-03.
^ Java's DataInput IO Interface
^ "Non-decodable Bytes in System Character Interfaces". python.org. 2009-04-22. Retrieved 2014-08-13.
^ "Unicode 6.0.0".
^ 128 1-byte, (16+5)√ó64 2-byte, and 5√ó64√ó64 3-byte. There may be somewhat fewer if more precise tests are done for each continuation byte.
^ "Chapter 2", The Unicode Standard (PDF), p. 30
^ Jump up to: a b "Character Sets". Internet Assigned Numbers Authority. 2013-01-23. Retrieved 2013-02-08.
^ D√ºrst, Martin. "Setting the HTTP charset parameter". W3C. Retrieved 2013-02-08.
^ "Encoding Standard ¬ß 4.2. Names and labels". WHATWG. Retrieved 2018-04-29.
^ "BOM". suikawiki (in Japanese). Retrieved 2013-04-26.
^ Davis, Mark. "Forms of Unicode". IBM. Archived from the original on 2005-05-06. Retrieved 2013-09-18.
^ Liviu (2014-02-07). "UTF-8 codepage 65001 in Windows 7 - part I". Retrieved 2018-01-30.
^ "Script How to set default encoding to UTF-8 for notepad by PowerShell". gallery.technet.microsoft.com. Retrieved 2018-01-30.
^ "HP PCL Symbol Sets | Printer Control Language (PCL & PXL) Support Blog". 2015-02-19. Archived from the original on 2015-02-19. Retrieved 2018-01-30.
^ "Appendix F. FSS-UTF / File System Safe UCS Transformation format" (PDF). The Unicode Standard 1.1. Archived (PDF) from the original on 2016-06-07. Retrieved 2016-06-07.
^ Whistler, Kenneth (2001-06-12). "FSS-UTF, UTF-2, UTF-8, and UTF-16". Archived from the original on 2016-06-07. Retrieved 2006-06-07.
^ Jump up to: a b Pike, Rob (2003-04-30). "UTF-8 history". Retrieved 2012-09-07.
^ Pike, Rob (2012-09-06). "UTF-8 turned 20 years old yesterday". Retrieved 2012-09-07.
^ Alvestrand, Harald (January 1998). IETF Policy on Character Sets and Languages. doi:10.17487/RFC2277. BCP 18.
^ ISO/IEC 10646:2014 ¬ß9.1, 2014.
^ The Unicode Standard, Version 11.0 ¬ß3.9 D92, ¬ß3.10 D95, 2018.
^ Unicode Standard Annex #27: Unicode 3.1, 2001.
^ The Unicode Standard, Version 5.0 ¬ß3.9‚Äì¬ß3.10 ch. 3, 2006.
^ The Unicode Standard, Version 6.0 ¬ß3.9 D92, ¬ß3.10 D95, 2010.
^ McGowan, Rick (2011-12-19). "Compatibility Encoding Scheme for UTF-16: 8-Bit (CESU-8)". Unicode Consortium. Unicode Technical Report #26.
^ "Character Set Support". Oracle Database 19c Documentation, SQL Language Reference. Oracle Corporation.
^ "Supporting Multilingual Databases with Unicode ¬ß Support for the Unicode Standard in Oracle Database". Database Globalization Support Guide. Oracle Corporation.
^ "8.2.2.3. Character encodings". HTML 5.1 Standard. W3C.
^ "8.2.2.3. Character encodings". HTML 5 Standard. W3C.
^ "12.2.3.3 Character encodings". HTML Living Standard. WHATWG.
^ "The utf8mb3 Character Set (3-Byte UTF-8 Unicode Encoding)". MySQL 8.0 Reference Manual. Oracle Corporation.
^ "Java SE documentation for Interface java.io.DataInput, subsection on Modified UTF-8". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "Java Object Serialization Specification, chapter 6: Object Serialization Stream Protocol, section 2: Stream Elements". Oracle Corporation. 2010. Retrieved 2015-10-16.
^ "Java Native Interface Specification, chapter 3: JNI Types and Data Structures, section: Modified UTF-8 Strings". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "ART and Dalvik". Android Open Source Project. Archived from the original on 2013-04-26. Retrieved 2013-04-09.
^ "Tcler's Wiki: UTF-8 bit by bit (Revision 6)". 2009-04-25. Retrieved 2009-05-22.
^ Sapin, Simon (2016-03-11) [2014-09-25]. "The WTF-8 encoding". Archived from the original on 2016-05-24. Retrieved 2016-05-24.
^ Sapin, Simon (2015-03-25) [2014-09-25]. "The WTF-8 encoding ¬ß Motivation". Archived from the original on 2016-05-24. Retrieved 2020-08-26.
^ "WTF-8.com". 2006-05-18. Retrieved 2016-06-21.
^ Speer, Robyn (2015-05-21). "ftfy (fixes text for you) 4.0: changing less and fixing more". Archived from the original on 2015-05-30. Retrieved 2016-06-21.
^ "WTF-8, a transformation format of code page 1252". Archived from the original on 2016-10-13. Retrieved 2016-10-12.
^ Jump up to: a b von L√∂wis, Martin (2009-04-22). "Non-decodable Bytes in System Character Interfaces". Python Software Foundation. PEP 383.
^ "RTFM optu8to16(3), optu8to16vis(3)". www.mirbsd.org.
^ Jump up to: a b Davis, Mark; Suignard, Michel (2014). "3.7 Enabling Lossless Conversion". Unicode Security Considerations. Unicode Technical Report #36.
External links[edit]
Original UTF-8 paper (or pdf) for Plan 9 from Bell Labs
UTF-8 test pages:
Andreas Prilop
Jost Gippert
World Wide Web Consortium
Unix/Linux: UTF-8/Unicode FAQ, Linux Unicode HOWTO, 8.xml UTF-8 and Gentoo
Characters, Symbols and the Unicode Miracle on YouTube
showvte
Unicode
showvte
Character encodings
showvte
Rob Pike
showvte
Ken Thompson
Categories: Character encodingComputer-related introductions in 1993EncodingsUnicode Transformation Formats
Navigation menu
Not logged inTalkContributionsCreate accountLog in
ArticleTalk
ReadEditView history
Search

Main page
Contents
Current events
Random article
About Wikipedia
Contact us
Donate
Contribute
Help
Learn to edit
Community portal
Recent changes
Upload file
Tools
What links here
Related changes
Special pages
Permanent link
Page information
Cite this page
Wikidata item
Print/export
Download as PDF
Printable version

Languages
ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
Espa√±ol
Bahasa Indonesia
Italiano
Bahasa Melayu
Portugu√™s
–†—É—Å—Å–∫–∏–π
ÿßÿ±ÿØŸà
‰∏≠Êñá
32 more
Edit links
This page was last edited on 20 October 2020, at 18:05 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia¬Æ is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
Privacy policyAbout WikipediaDisclaimersContact WikipediaMobile viewDevelopersStatisticsCookie statement
Wikimedia FoundationPowered by MediaWiki

UTF-8
From Wikipedia, the free encyclopedia
Jump to navigationJump to search
UTF-8
Standard	Unicode Standard
Classification	Unicode Transformation Format, extended ASCII, variable-width encoding
Extends	US-ASCII
Transforms / Encodes	ISO 10646 (Unicode)
Preceded by	UTF-1
vte
UTF-8 is a variable-width character encoding used for electronic communication. Defined by the Unicode Standard, the name is derived from Unicode (or Universal Coded Character Set) Transformation Format ‚Äì 8-bit.[1]

UTF-8 is capable of encoding all 1,112,064[nb 1] valid character code points in Unicode using one to four one-byte (8-bit) code units. Code points with lower numerical values, which tend to occur more frequently, are encoded using fewer bytes. It was designed for backward compatibility with ASCII: the first 128 characters of Unicode, which correspond one-to-one with ASCII, are encoded using a single byte with the same binary value as ASCII, so that valid ASCII text is valid UTF-8-encoded Unicode as well. Since ASCII bytes do not occur when encoding non-ASCII code points into UTF-8, UTF-8 is safe to use within most programming and document languages that interpret certain ASCII characters in a special way, such as "/" (slash) in filenames, "\" (backslash) in escape sequences, and "%" in printf.

UTF-8 was designed as a superior alternative to UTF-1, a proposed variable-width encoding with partial ASCII compatibility which lacked some features including self-synchronization and fully ASCII-compatible handling of characters such as slashes. Ken Thompson and Rob Pike produced the first implementation for the Plan 9 operating system in September 1992.[2][3] This led to its adoption by X/Open as its specification for FSS-UTF, which would first be officially presented at USENIX in January 1993 and subsequently adopted by the Internet Engineering Task Force (IETF) in RFC 2277 (BCP 18) for future Internet standards work, replacing Single Byte Character Sets such as Latin-1 in older RFCs.

UTF-8 is by far the most common encoding for the World Wide Web, accounting for over 95% of all web pages, and up to 100% for some languages, as of 2020.[4]


Contents
1	Adoption
2	Encoding
2.1	Examples
2.2	Codepage layout
2.3	Overlong encodings
2.4	Invalid sequences and error handling
2.5	Byte order mark
3	Naming
4	History
5	Standards
6	Comparison with other encodings
6.1	Single-byte
6.2	Other multi-byte
6.3	UTF-16
7	Derivatives
7.1	CESU-8
7.2	MySQL utf8mb3
7.3	Modified UTF-8
7.4	WTF-8
7.5	PEP 383
8	See also
9	Notes
10	References
11	External links
Adoption[edit]

Use of the main encodings on the web from 2001 to 2012 as recorded by Google,[5] with UTF-8 overtaking all others in 2008 and over 60% of the web in 2012. The ASCII-only figure includes all web pages that only contain ASCII characters, regardless of the declared header.
UTF-8 is the recommendation from the WHATWG for HTML and DOM specifications,[6] and the Internet Mail Consortium recommends that all e-mail programs be able to display and create mail using UTF-8.[7][8]

Google reported that in 2008, UTF-8 (labelled "Unicode") became the most common encoding for HTML files.[9]

Since 2009, UTF-8 has been the most common encoding for the World Wide Web.[4] The World Wide Web Consortium recommends UTF-8 as the default encoding in XML and HTML (and not just using UTF-8, also stating it in metadata), "even when all characters are in the ASCII range .. Using non-UTF-8 encodings can have unexpected results".[10] Many other standards only support UTF-8, e.g. open JSON exchange requires it.[11]

As of October 2020, UTF-8 accounts on average for 95.5% of all web pages and 97% of the top 1,000 highest ranked web pages.[4] (This takes into account that ASCII is valid UTF-8.[12]) Several languages have 100.0% use of UTF-8 on the web, such as Punjabi, Tagalog, Lao, Marathi, Kannada, Kurdish, Pashto, Javanese, Greenlandic (Kalaallisut) and Iranian languages[13] and sign languages.[14]

In locales where UTF-8 is used alongside another encoding, the latter is typically more efficient for the associated language. The Chinese standard GB 2312 and with its extension GBK (which are both interpreted by web browsers as GB 18030, having support for the same letters as UTF-8) have a combined 14.5% share in China[15][16] and a 0.5% share world-wide. Big5 is another popular Chinese encoding with 0.1% share world-wide. The single-byte Windows-1251 is twice as efficient for the Cyrillic script and is used for 10.6% of Russian web sites.[17] E.g. Greek and Hebrew encodings are also twice as efficient, but still those languages have over 95% use of UTF-8.[18][19] EUC-KR is more efficient for Korean text and is used for 17.3% of South Korean websites. Shift JIS and EUC-JP have a 10.5% share on Japanese websites (the more popular Shift JIS has 0.2% global share).[20][21][5] With the exception of GB 18030 and UTF-16, these encodings were designed for specific languages, and do not support all Unicode characters. As of September 2020, the Breton language has the lowest UTF-8 use on the Web of any tracked language, with 79.4% use.[22]

International Components for Unicode (ICU) has historically used UTF-16, and still does only for Java; while for C/C++ UTF-8 is now supported as the "Default Charset",[23] including the correct handling of "illegal UTF-8".[24]

For local text files UTF-8 usage is lower, and many legacy single-byte encodings remain in use. This is primarily due to editors that will not display or write UTF-8 unless the first character in a file is a byte order mark, making it impossible for other software to use UTF-8 without being rewritten to ignore the byte order mark on input and add it on output. UTF-16 files are also fairly common on Windows, but not elsewhere.[original research?] Internally in software usage is even lower, with UCS-2 and UTF-32 in use, particularly in Windows but also Python, JavaScript, Qt, and many other software libraries. This is due to a belief that direct indexing of code points is more important than 8-bit compatibility.[citation needed] UTF-16 is also used due to being compatible with UCS-2, even though it does not have direct indexing. Microsoft now recommends UTF-8 for Windows programs,[25] while previously they emphasized "Unicode" (meaning UTF-16) Win32 API, this may mean internal use of UTF-8 will increase in the future.[original research?]

Encoding[edit]
Since the restriction of the Unicode code-space to 21-bit values in 2003, UTF-8 is defined to encode code points in one to four bytes, depending on the number of significant bits in the numerical value of the code point. The following table shows the structure of the encoding. The x characters are replaced by the bits of the code point.

Layout of UTF-8 byte sequences
Number of bytes	First code point	Last code point	Byte 1	Byte 2	Byte 3	Byte 4
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+07FF	110xxxxx	10xxxxxx
3	U+0800	U+FFFF	1110xxxx	10xxxxxx	10xxxxxx
4	U+10000	[nb 2]U+10FFFF	11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
The first 128 characters (US-ASCII) need one byte. The next 1,920 characters need two bytes to encode, which covers the remainder of almost all Latin-script alphabets, and also Greek, Cyrillic, Coptic, Armenian, Hebrew, Arabic, Syriac, Thaana and N'Ko alphabets, as well as Combining Diacritical Marks. Three bytes are needed for characters in the rest of the Basic Multilingual Plane, which contains virtually all characters in common use,[26] including most Chinese, Japanese and Korean characters. Four bytes are needed for characters in the other planes of Unicode, which include less common CJK characters, various historic scripts, mathematical symbols, and emoji (pictographic symbols).

Examples[edit]
Consider the encoding of the Euro sign, ‚Ç¨:

The Unicode code point for "‚Ç¨" is U+20AC.
As this code point lies between U+0800 and U+FFFF, this will take three bytes to encode.
Hexadecimal 20AC is binary 0010 0000 1010 1100. The two leading zeros are added because a three-byte encoding needs exactly sixteen bits from the code point.
Because the encoding will be three bytes long, its leading byte starts with three 1s, then a 0 (1110...)
The four most significant bits of the code point are stored in the remaining low order four bits of this byte (1110 0010), leaving 12 bits of the code point yet to be encoded (...0000 1010 1100).
All continuation bytes contain exactly six bits from the code point. So the next six bits of the code point are stored in the low order six bits of the next byte, and 10 is stored in the high order two bits to mark it as a continuation byte (so 1000 0010).
Finally the last six bits of the code point are stored in the low order six bits of the final byte, and again 10 is stored in the high order two bits (1010 1100).
The three bytes 1110 0010 1000 0010 1010 1100 can be more concisely written in hexadecimal, as E2 82 AC.

The following table summarises this conversion, as well as others with different lengths in UTF-8. The colors indicate how bits from the code point are distributed among the UTF-8 bytes. Additional bits added by the UTF-8 encoding process are shown in black.

Representation of UTF-8 characters
Character	Code point	UTF-8
Octal	Binary	Binary	Octal	Hexadecimal
$	U+0024	044	010 0100	00100100	044	24
¬¢	U+00A2	0242	000 1010 0010	11000010 10100010	302 242	C2 A2
‡§π	U+0939	004471	0000 1001 0011 1001	11100000 10100100 10111001	340 244 271	E0 A4 B9
‚Ç¨	U+20AC	020254	0010 0000 1010 1100	11100010 10000010 10101100	342 202 254	E2 82 AC
Ìïú	U+D55C	152534	1101 0101 0101 1100	11101101 10010101 10011100	355 225 234	ED 95 9C
êçà	U+10348	0201510	0 0001 0000 0011 0100 1000	11110000 10010000 10001101 10001000	360 220 215 210	F0 90 8D 88
UTF-8's use of six bits per byte to represent the actual characters being encoded means that octal notation (which uses 3-bit groups) can aid in the comparison of UTF-8 sequences with one another.[27]

Codepage layout[edit]
The following table summarizes usage of UTF-8 code units (individual bytes or octets) in a code page format. The upper half (0_ to 7_) is for bytes used only in single-byte codes, so it looks like a normal code page; the lower half is for continuation bytes (8_ to B_) and leading bytes (C_ to F_), and is explained further in the legend below.

UTF-8
_0	_1	_2	_3	_4	_5	_6	_7	_8	_9	_A	_B	_C	_D	_E	_F
0_	NUL
0000	SOH
0001	STX
0002	ETX
0003	EOT
0004	ENQ
0005	ACK
0006	BEL
0007	BS
0008	HT
0009	LF
000A	VT
000B	FF
000C	CR
000D	SO
000E	SI
000F
1_	DLE
0010	DC1
0011	DC2
0012	DC3
0013	DC4
0014	NAK
0015	SYN
0016	ETB
0017	CAN
0018	EM
0019	SUB
001A	ESC
001B	FS
001C	GS
001D	RS
001E	US
001F
2_	SP
0020	!
0021	"
0022	#
0023	$
0024	%
0025	&
0026	'
0027	(
0028	)
0029	*
002A	+
002B	,
002C	-
002D	.
002E	/
002F
3_	0
0030	1
0031	2
0032	3
0033	4
0034	5
0035	6
0036	7
0037	8
0038	9
0039	:
003A	;
003B	<
003C	=
003D	>
003E	?
003F
4_	@
0040	A
0041	B
0042	C
0043	D
0044	E
0045	F
0046	G
0047	H
0048	I
0049	J
004A	K
004B	L
004C	M
004D	N
004E	O
004F
5_	P
0050	Q
0051	R
0052	S
0053	T
0054	U
0055	V
0056	W
0057	X
0058	Y
0059	Z
005A	[
005B	\
005C	]
005D	^
005E	_
005F
6_	`
0060	a
0061	b
0062	c
0063	d
0064	e
0065	f
0066	g
0067	h
0068	i
0069	j
006A	k
006B	l
006C	m
006D	n
006E	o
006F
7_	p
0070	q
0071	r
0072	s
0073	t
0074	u
0075	v
0076	w
0077	x
0078	y
0079	z
007A	{
007B	|
007C	}
007D	~
007E	DEL
007F
8_	‚Ä¢
+00	‚Ä¢
+01	‚Ä¢
+02	‚Ä¢
+03	‚Ä¢
+04	‚Ä¢
+05	‚Ä¢
+06	‚Ä¢
+07	‚Ä¢
+08	‚Ä¢
+09	‚Ä¢
+0A	‚Ä¢
+0B	‚Ä¢
+0C	‚Ä¢
+0D	‚Ä¢
+0E	‚Ä¢
+0F
9_	‚Ä¢
+10	‚Ä¢
+11	‚Ä¢
+12	‚Ä¢
+13	‚Ä¢
+14	‚Ä¢
+15	‚Ä¢
+16	‚Ä¢
+17	‚Ä¢
+18	‚Ä¢
+19	‚Ä¢
+1A	‚Ä¢
+1B	‚Ä¢
+1C	‚Ä¢
+1D	‚Ä¢
+1E	‚Ä¢
+1F
A_	‚Ä¢
+20	‚Ä¢
+21	‚Ä¢
+22	‚Ä¢
+23	‚Ä¢
+24	‚Ä¢
+25	‚Ä¢
+26	‚Ä¢
+27	‚Ä¢
+28	‚Ä¢
+29	‚Ä¢
+2A	‚Ä¢
+2B	‚Ä¢
+2C	‚Ä¢
+2D	‚Ä¢
+2E	‚Ä¢
+2F
B_	‚Ä¢
+30	‚Ä¢
+31	‚Ä¢
+32	‚Ä¢
+33	‚Ä¢
+34	‚Ä¢
+35	‚Ä¢
+36	‚Ä¢
+37	‚Ä¢
+38	‚Ä¢
+39	‚Ä¢
+3A	‚Ä¢
+3B	‚Ä¢
+3C	‚Ä¢
+3D	‚Ä¢
+3E	‚Ä¢
+3F
2
C_	2
0000	2
0040	Latin
0080	Latin
00C0	Latin
0100	Latin
0140	Latin
0180	Latin
01C0	Latin
0200	IPA
0240	IPA
0280	IPA
02C0	accents
0300	accents
0340	Greek
0380	Greek
03C0
2
D_	Cyril
0400	Cyril
0440	Cyril
0480	Cyril
04C0	Cyril
0500	Armeni
0540	Hebrew
0580	Hebrew
05C0	Arabic
0600	Arabic
0640	Arabic
0680	Arabic
06C0	Syriac
0700	Arabic
0740	Thaana
0780	N'Ko
07C0
3
E_	Indic
0800	Misc.
1000	Symbol
2000	Kana‚Ä¶
3000	CJK
4000	CJK
5000	CJK
6000	CJK
7000	CJK
8000	CJK
9000	Asian
A000	Hangul
B000	Hangul
C000	Hangul
D000	PUA
E000	Forms
F000
4
F_	SMP‚Ä¶
10000	ÒÄÄÄ
40000	ÚÄÄÄ
80000	SSP‚Ä¶
C0000	SPU‚Ä¶
100000	4
140000	4
180000	4
1C0000	5
200000	5
1000000	5
2000000	5
3000000	6
4000000	6
40000000
  Blue cells are 7-bit (single-byte) sequences. They must not be followed by a continuation byte.[28]

  Orange cells with a large dot are continuation bytes.[29] The hexadecimal number shown after the + symbol is the value of the 6 bits they add.

  White cells are the leading bytes for a sequence of multiple bytes,[30] the length shown at the left edge of the row. The text shows the Unicode blocks encoded by sequences starting with this byte, and the hexadecimal code point shown in the cell is the lowest character value encoded using that leading byte.

  Red cells must never appear in a valid UTF-8 sequence. The first two red cells (C0 and C1) could be used only for a 2-byte encoding of a 7-bit ASCII character which should be encoded in 1 byte; as described below, such "overlong" sequences are disallowed.[31] The red cells in the F_ row (F5 to FD) indicate leading bytes of 4-byte or longer sequences that cannot be valid because they would encode code points larger than the U+10FFFF limit of Unicode (a limit derived from the maximum code point encodable in UTF-16 [32]). FE and FF do not match any allowed character pattern and are therefore not valid start bytes.[33]

  Pink cells are the leading bytes for a sequence of multiple bytes, of which some, but not all, possible continuation sequences are valid. E0 and F0 could start overlong encodings, in this case the lowest non-overlong-encoded code point is shown. F4 can start code points greater than U+10FFFF which are invalid. ED can start the encoding of a code point in the range U+D800‚ÄìU+DFFF; these are invalid since they are reserved for UTF-16 surrogate halves.[34]

Overlong encodings[edit]
In principle, it would be possible to inflate the number of bytes in an encoding by padding the code point with leading 0s. To encode the Euro sign ‚Ç¨ from the above example in four bytes instead of three, it could be padded with leading 0s until it was 21 bits long ‚Äì 000 000010 000010 101100, and encoded as 11110000 10000010 10000010 10101100 (or F0 82 82 AC in hexadecimal). This is called an overlong encoding.

The standard specifies that the correct encoding of a code point uses only the minimum number of bytes required to hold the significant bits of the code point. Longer encodings are called overlong and are not valid UTF-8 representations of the code point. This rule maintains a one-to-one correspondence between code points and their valid encodings, so that there is a unique valid encoding for each code point. This ensures that string comparisons and searches are well-defined.

Invalid sequences and error handling[edit]
Not all sequences of bytes are valid UTF-8. A UTF-8 decoder should be prepared for:

invalid bytes
an unexpected continuation byte
a non-continuation byte before the end of the character
the string ending before the end of the character (which can happen in simple string truncation)
an overlong encoding
a sequence that decodes to an invalid code point
Many of the first UTF-8 decoders would decode these, ignoring incorrect bits and accepting overlong results. Carefully crafted invalid UTF-8 could make them either skip or create ASCII characters such as NUL, slash, or quotes. Invalid UTF-8 has been used to bypass security validations in high-profile products including Microsoft's IIS web server[35] and Apache's Tomcat servlet container.[36] RFC 3629 states "Implementations of the decoding algorithm MUST protect against decoding invalid sequences."[37] The Unicode Standard requires decoders to "...treat any ill-formed code unit sequence as an error condition. This guarantees that it will neither interpret nor emit an ill-formed code unit sequence."

Since RFC 3629 (November 2003), the high and low surrogate halves used by UTF-16 (U+D800 through U+DFFF) and code points not encodable by UTF-16 (those after U+10FFFF) are not legal Unicode values, and their UTF-8 encoding must be treated as an invalid byte sequence. Not decoding unpaired surrogate halves makes it impossible to store invalid UTF-16 (such as Windows filenames or UTF-16 that has been split between the surrogates) as UTF-8.[citation needed]

Some implementations of decoders throw exceptions on errors.[38] This has the disadvantage that it can turn what would otherwise be harmless errors (such as a "no such file" error) into a denial of service. For instance early versions of Python 3.0 would exit immediately if the command line or environment variables contained invalid UTF-8.[39] An alternative practice is to replace errors with a replacement character. Since Unicode 6[40] (October 2010), the standard (chapter 3) has recommended a "best practice" where the error ends as soon as a disallowed byte is encountered. In these decoders E1,A0,C0 is two errors (2 bytes in the first one). This means an error is no more than three bytes long and never contains the start of a valid character, and there are 21,952 different possible errors.[41] The standard also recommends replacing each error with the replacement character "ÔøΩ" (U+FFFD).

Byte order mark[edit]
If the UTF-16 Unicode byte order mark (BOM) character is at the start of a UTF-8 file, the first three bytes will be 0xEF, 0xBB, 0xBF.

The Unicode Standard neither requires nor recommends the use of the BOM for UTF-8, but warns that it may be encountered at the start of a file trans-coded from another encoding.[42] While ASCII text encoded using UTF-8 is backward compatible with ASCII, this is not true when Unicode Standard recommendations are ignored and a BOM is added. Nevertheless, there was and still is software that always inserts a BOM when writing UTF-8, and refuses to correctly interpret UTF-8 unless the first character is a BOM (or the file only contains ASCII).[citation needed]

Naming[edit]
The official Internet Assigned Numbers Authority (IANA) code for the encoding is "UTF-8".[43] All letters are upper-case, and the name is hyphenated. This spelling is used in all the Unicode Consortium documents relating to the encoding.

Alternatively, the name "utf-8" may be used by all standards conforming to the IANA list (which include CSS, HTML, XML, and HTTP headers),[44] as the declaration is case insensitive.[43]

Other descriptions, such as those that omit the hyphen or replace it with a space, i.e. "utf8" or "UTF 8", are not accepted as correct by the governing standards.[37] Despite this, most agents such as browsers can understand them, and so standards intended to describe existing practice (such as HTML5) may effectively require their recognition.[45]

Unofficially, UTF-8-BOM and UTF-8-NOBOM are sometimes used to refer to text files which respectively contain and lack a byte order mark (BOM).[citation needed] In Japan especially, UTF-8 encoding without BOM is sometimes called "UTF-8N".[46][47]

Windows 7 and later, i.e. all supported Windows versions, have codepage 65001, as a synonym for UTF-8 (with better support than in older Windows),[48] and Microsoft has a script for Windows 10, to enable it by default for its program Microsoft Notepad.[49]

In PCL, UTF-8 is called Symbol-ID "18N" (PCL supports 183 character encodings, called Symbol Sets, which potentially could be reduced to one, 18N, that is UTF-8).[50]

History[edit]
See also: Universal Coded Character Set ¬ß History
The International Organization for Standardization (ISO) set out to compose a universal multi-byte character set in 1989. The draft ISO 10646 standard contained a non-required annex called UTF-1 that provided a byte stream encoding of its 32-bit code points. This encoding was not satisfactory on performance grounds, among other problems, and the biggest problem was probably that it did not have a clear separation between ASCII and non-ASCII: new UTF-1 tools would be backward compatible with ASCII-encoded text, but UTF-1-encoded text could confuse existing code expecting ASCII (or extended ASCII), because it could contain continuation bytes in the range 0x21‚Äì0x7E that meant something else in ASCII, e.g., 0x2F for '/', the Unix path directory separator, and this example is reflected in the name and introductory text of its replacement. The table below was derived from a textual description in the annex.

UTF-1
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5
1	U+0000	U+009F	00‚Äì9F
2	U+00A0	U+00FF	A0	A0‚ÄìFF
2	U+0100	U+4015	A1‚ÄìF5	21‚Äì7E, A0‚ÄìFF
3	U+4016	U+38E2D	F6‚ÄìFB	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF
5	U+38E2E	U+7FFFFFFF	FC‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF
In July 1992, the X/Open committee XoJIG was looking for a better encoding. Dave Prosser of Unix System Laboratories submitted a proposal for one that had faster implementation characteristics and introduced the improvement that 7-bit ASCII characters would only represent themselves; all multi-byte sequences would include only bytes where the high bit was set. The name File System Safe UCS Transformation Format (FSS-UTF) and most of the text of this proposal were later preserved in the final specification.[51][52][53][54]

FSS-UTF proposal (1992)
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+207F	10xxxxxx	1xxxxxxx
3	U+2080	U+8207F	110xxxxx	1xxxxxxx	1xxxxxxx
4	U+82080	U+208207F	1110xxxx	1xxxxxxx	1xxxxxxx	1xxxxxxx
5	U+2082080	U+7FFFFFFF	11110xxx	1xxxxxxx	1xxxxxxx	1xxxxxxx	1xxxxxxx
In August 1992, this proposal was circulated by an IBM X/Open representative to interested parties. A modification by Ken Thompson of the Plan 9 operating system group at Bell Labs made it somewhat less bit-efficient than the previous proposal but crucially allowed it to be self-synchronizing, letting a reader start anywhere and immediately detect byte sequence boundaries. It also abandoned the use of biases and instead added the rule that only the shortest possible encoding is allowed; the additional loss in compactness is relatively insignificant, but readers now have to look out for invalid encodings to avoid reliability and especially security issues. Thompson's design was outlined on September 2, 1992, on a placemat in a New Jersey diner with Rob Pike. In the following days, Pike and Thompson implemented it and updated Plan 9 to use it throughout, and then communicated their success back to X/Open, which accepted it as the specification for FSS-UTF.[53]

FSS-UTF (1992) / UTF-8 (1993)[2]
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5	Byte 6
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+07FF	110xxxxx	10xxxxxx
3	U+0800	U+FFFF	1110xxxx	10xxxxxx	10xxxxxx
4	U+10000	U+1FFFFF	11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
5	U+200000	U+3FFFFFF	111110xx	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx
6	U+4000000	U+7FFFFFFF	1111110x	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx
UTF-8 was first officially presented at the USENIX conference in San Diego, from January 25 to 29, 1993. The Internet Engineering Task Force adopted UTF-8 in its Policy on Character Sets and Languages in RFC 2277 (BCP 18) for future Internet standards work, replacing Single Byte Character Sets such as Latin-1 in older RFCs.[55]

In November 2003, UTF-8 was restricted by RFC 3629 to match the constraints of the UTF-16 character encoding: explicitly prohibiting code points corresponding to the high and low surrogate characters removed more than 3% of the three-byte sequences, and ending at U+10FFFF removed more than 48% of the four-byte sequences and all five- and six-byte sequences.

Standards[edit]
There are several current definitions of UTF-8 in various standards documents:

RFC 3629 / STD 63 (2003), which establishes UTF-8 as a standard Internet protocol element
RFC 5198 defines UTF-8 NFC for Network Interchange (2008)
ISO/IEC 10646:2014 ¬ß9.1 (2014)[56]
The Unicode Standard, Version 11.0 (2018)[57]
They supersede the definitions given in the following obsolete works:

The Unicode Standard, Version 2.0, Appendix A (1996)
ISO/IEC 10646-1:1993 Amendment 2 / Annex R (1996)
RFC 2044 (1996)
RFC 2279 (1998)
The Unicode Standard, Version 3.0, ¬ß2.3 (2000) plus Corrigendum #1 : UTF-8 Shortest Form (2000)
Unicode Standard Annex #27: Unicode 3.1 (2001)[58]
The Unicode Standard, Version 5.0 (2006)[59]
The Unicode Standard, Version 6.0 (2010)[60]
They are all the same in their general mechanics, with the main differences being on issues such as allowed range of code point values and safe handling of invalid input.

Comparison with other encodings[edit]
See also: Comparison of Unicode encodings
Some of the important features of this encoding are as follows:

Backward compatibility: Backward compatibility with ASCII and the enormous amount of software designed to process ASCII-encoded text was the main driving force behind the design of UTF-8. In UTF-8, single bytes with values in the range of 0 to 127 map directly to Unicode code points in the ASCII range. Single bytes in this range represent characters, as they do in ASCII. Moreover, 7-bit bytes (bytes where the most significant bit is 0) never appear in a multi-byte sequence, and no valid multi-byte sequence decodes to an ASCII code-point. A sequence of 7-bit bytes is both valid ASCII and valid UTF-8, and under either interpretation represents the same sequence of characters. Therefore, the 7-bit bytes in a UTF-8 stream represent all and only the ASCII characters in the stream. Thus, many text processors, parsers, protocols, file formats, text display programs, etc., which use ASCII characters for formatting and control purposes, will continue to work as intended by treating the UTF-8 byte stream as a sequence of single-byte characters, without decoding the multi-byte sequences. ASCII characters on which the processing turns, such as punctuation, whitespace, and control characters will never be encoded as multi-byte sequences. It is therefore safe for such processors to simply ignore or pass-through the multi-byte sequences, without decoding them. For example, ASCII whitespace may be used to tokenize a UTF-8 stream into words; ASCII line-feeds may be used to split a UTF-8 stream into lines; and ASCII NUL characters can be used to split UTF-8-encoded data into null-terminated strings. Similarly, many format strings used by library functions like "printf" will correctly handle UTF-8-encoded input arguments.
Fallback and auto-detection: Only a small subset of possible byte strings are a valid UTF-8 string: the bytes C0, C1, and F5 through FF cannot appear, and bytes with the high bit set must be in pairs, and other requirements. It is extremely unlikely that a readable text in any extended ASCII is valid UTF-8. Part of the popularity of UTF-8 is due to it providing a form of backward compatibility for these as well. A UTF-8 processor which erroneously receives extended ASCII as input can thus "auto-detect" this with very high reliability. Fallback errors will be false negatives, and these will be rare. Moreover, in many applications, such as text display, the consequence of incorrect fallback is usually slight.[original research?] A UTF-8 stream may simply contain errors, resulting in the auto-detection scheme producing false positives; but auto-detection is successful in the majority of cases, especially with longer texts, and is widely used. It also works to "fall back" or replace 8-bit bytes using the appropriate code-point for a legacy encoding only when errors in the UTF-8 are detected, allowing recovery even if UTF-8 and legacy encoding is concatenated in the same file.
Prefix code: The first byte indicates the number of bytes in the sequence. Reading from a stream can instantaneously decode each individual fully received sequence, without first having to wait for either the first byte of a next sequence or an end-of-stream indication. The length of multi-byte sequences is easily determined by humans as it is simply the number of high-order 1s in the leading byte. An incorrect character will not be decoded if a stream ends mid-sequence.
Self-synchronization: The leading bytes and the continuation bytes do not share values (continuation bytes start with the bits 10 while single bytes start with 0 and longer lead bytes start with 11). This means a search will not accidentally find the sequence for one character starting in the middle of another character. It also means the start of a character can be found from a random position by backing up at most 3 bytes to find the leading byte. An incorrect character will not be decoded if a stream starts mid-sequence, and a shorter sequence will never appear inside a longer one.
Sorting order: The chosen values of the leading bytes means that a list of UTF-8 strings can be sorted in code point order by sorting the corresponding byte sequences.
Single-byte[edit]
UTF-8 can encode any Unicode character, avoiding the need to figure out and set a "code page" or otherwise indicate what character set is in use, and allowing output in multiple scripts at the same time. For many scripts there have been more than one single-byte encoding in usage, so even knowing the script was insufficient information to display it correctly.
The bytes 0xFE and 0xFF do not appear, so a valid UTF-8 stream never matches the UTF-16 byte order mark and thus cannot be confused with it. The absence of 0xFF (0377) also eliminates the need to escape this byte in Telnet (and FTP control connection).
UTF-8 encoded text is larger than specialized single-byte encodings except for plain ASCII characters. In the case of scripts which used 8-bit character sets with non-Latin characters encoded in the upper half (such as most Cyrillic and Greek alphabet code pages), characters in UTF-8 will be double the size. For some scripts, such as Thai and Devanagari (which is used by various South Asian languages), characters will triple in size. There are even examples where a single byte turns into a composite character in Unicode and is thus six times larger in UTF-8. This has caused objections in India and other countries.
It is possible in UTF-8 (or any other variable-length encoding) to split or truncate a string in the middle of a character. If the two pieces are not re-appended later before interpretation as characters, this can introduce an invalid sequence at both the end of the previous section and the start of the next, and some decoders will not preserve these bytes and result in data loss. Because UTF-8 is self-synchronizing this will however never introduce a different valid character, and it is also fairly easy to move the truncation point backward to the start of a character.
If the code points are all the same size, measurements of a fixed number of them is easy. Due to ASCII-era documentation where "character" is used as a synonym for "byte" this is often considered important. However, by measuring string positions using bytes instead of "characters" most algorithms can be easily and efficiently adapted for UTF-8. Searching for a string within a long string can for example be done byte by byte; the self-synchronization property prevents false positives.
Other multi-byte[edit]
UTF-8 can encode any Unicode character. Files in different scripts can be displayed correctly without having to choose the correct code page or font. For instance, Chinese and Arabic can be written in the same file without specialised markup or manual settings that specify an encoding.
UTF-8 is self-synchronizing: character boundaries are easily identified by scanning for well-defined bit patterns in either direction. If bytes are lost due to error or corruption, one can always locate the next valid character and resume processing. If there is a need to shorten a string to fit a specified field, the previous valid character can easily be found. Many multi-byte encodings such as Shift JIS are much harder to resynchronize. This also means that byte-oriented string-searching algorithms can be used with UTF-8 (as a character is the same as a "word" made up of that many bytes), optimized versions of byte searches can be much faster due to hardware support and lookup tables that have only 256 entries. Self-synchronization does however require that bits be reserved for these markers in every byte, increasing the size.
Efficient to encode using simple bitwise operations. UTF-8 does not require slower mathematical operations such as multiplication or division (unlike Shift JIS, GB 2312 and other encodings).
UTF-8 will take more space than a multi-byte encoding designed for a specific script. East Asian legacy encodings generally used two bytes per character yet take three bytes per character in UTF-8.
UTF-16[edit]
Byte encodings and UTF-8 are represented by byte arrays in programs, and often nothing needs to be done to a function when converting source code from a byte encoding to UTF-8. UTF-16 is represented by 16-bit word arrays, and converting to UTF-16 while maintaining compatibility with existing ASCII-based programs (such as was done with Windows) requires every API and data structure that takes a string to be duplicated, one version accepting byte strings and another version accepting UTF-16. If backward compatibility is not needed, all string handling still must be modified.
Text encoded in UTF-8 will be smaller than the same text encoded in UTF-16 if there are more code points below U+0080 than in the range U+0800..U+FFFF. This is true for all modern European languages.
Text in (for example) Chinese, Japanese or Devanagari will take more space in UTF-8 if there are more of these characters than there are ASCII characters. This is likely when data mainly consist of pure prose, but is lessened by the degree to which the context uses ASCII whitespace, digits, and punctuation.[nb 3]
Most of the rich text formats (including HTML) contain a large proportion of ASCII characters for the sake of formatting, thus the size usually will be reduced significantly compared with UTF-16, even when the language mostly uses 3-byte long characters in UTF-8.[nb 4]
Most communication (e.g. HTML and IP) and storage (e.g. for Unix) was designed for a stream of bytes. A UTF-16 string must use a pair of bytes for each code unit:
The order of those two bytes becomes an issue and must be specified in the UTF-16 protocol, such as with a byte order mark.
If an odd number of bytes is missing from UTF-16, the whole rest of the string will be meaningless text. Any bytes missing from UTF-8 will still allow the text to be recovered accurately starting with the next character after the missing bytes.
Derivatives[edit]
The following implementations show slight differences from the UTF-8 specification. They are incompatible with the UTF-8 specification and may be rejected by conforming UTF-8 applications.

CESU-8[edit]
Main article: CESU-8
Unicode Technical Report #26[61] assigns the name CESU-8 to a nonstandard variant of UTF-8, in which Unicode characters in supplementary planes are encoded using six bytes, rather than the four bytes required by UTF-8. CESU-8 encoding treats each half of a four-byte UTF-16 surrogate pair as a two-byte UCS-2 character, yielding two three-byte UTF-8 characters, which together represent the original supplementary character. Unicode characters within the Basic Multilingual Plane appear as they would normally in UTF-8. The Report was written to acknowledge and formalize the existence of data encoded as CESU-8, despite the Unicode Consortium discouraging its use, and notes that a possible intentional reason for CESU-8 encoding is preservation of UTF-16 binary collation.

CESU-8 encoding can result from converting UTF-16 data with supplementary characters to UTF-8, using conversion methods that assume UCS-2 data, meaning they are unaware of four-byte UTF-16 supplementary characters. It is primarily an issue on operating systems which extensively use UTF-16 internally, such as Microsoft Windows.[citation needed]

In Oracle Database, the UTF8 character set uses CESU-8 encoding, and is deprecated. The AL32UTF8 character set uses standards-compliant UTF-8 encoding, and is preferred.[62][63]

CESU-8 is prohibited for use in HTML5 documents.[64][65][66]

MySQL utf8mb3[edit]
In MySQL, the utf8mb3 character set is defined to be UTF-8 encoded data with a maximum of three bytes per character, meaning only Unicode characters in the Basic Multilingual Plane are supported. Unicode characters in supplementary planes are explicitly not supported. utf8mb3 is deprecated in favor of the utf8mb4 character set, which uses standards-compliant UTF-8 encoding. utf8 is an alias for utf8mb3, but is intended to become an alias to utf8mb4 in a future release of MySQL.[67] It is possible, though unsupported, to store CESU-8 encoded data in utf8mb3, by handling UTF-16 data with supplementary characters as though it is UCS-2.

Modified UTF-8[edit]
Modified UTF-8 (MUTF-8) originated in the Java programming language. In Modified UTF-8, the null character (U+0000) uses the two-byte overlong encoding 11000000 10000000 (hexadecimal C0 80), instead of 00000000 (hexadecimal 00).[68] Modified UTF-8 strings never contain any actual null bytes but can contain all Unicode code points including U+0000,[69] which allows such strings (with a null byte appended) to be processed by traditional null-terminated string functions. All known Modified UTF-8 implementations also treat the surrogate pairs as in CESU-8.

In normal usage, the language supports standard UTF-8 when reading and writing strings through InputStreamReader and OutputStreamWriter (if it is the platform's default character set or as requested by the program). However it uses Modified UTF-8 for object serialization[70] among other applications of DataInput and DataOutput, for the Java Native Interface,[71] and for embedding constant strings in class files.[72]

The dex format defined by Dalvik also uses the same modified UTF-8 to represent string values.[73] Tcl also uses the same modified UTF-8[74] as Java for internal representation of Unicode data, but uses strict CESU-8 for external data.

WTF-8[edit]

This section contains a list of miscellaneous information. Please relocate any relevant information into other sections or articles. (August 2020)
In WTF-8 (Wobbly Transformation Format, 8-bit) unpaired surrogate halves (U+D800 through U+DFFF) are allowed.[75] This is necessary to store possibly-invalid UTF-16, such as Windows filenames. Many systems that deal with UTF-8 work this way without considering it a different encoding, as it is simpler.[76]

(The term "WTF-8" has also been used humorously to refer to erroneously doubly-encoded UTF-8[77][78] sometimes with the implication that CP1252 bytes are the only ones encoded)[79]

PEP 383[edit]
Version 3 of the Python programming language treats each byte of an invalid UTF-8 bytestream as an error; this gives 128 different possible errors. Extensions have been created to allow any byte sequence that is assumed to be UTF-8 to be lossless transformed to UTF-16 or UTF-32, by translating the 128 possible error bytes to reserved code points, and transforming those code points back to error bytes to output UTF-8. The most common approach is to translate the codes to U+DC80...U+DCFF which are low (trailing) surrogate values and thus "invalid" UTF-16, as used by Python's PEP 383 (or "surrogateescape") approach.[80] Another encoding called MirBSD OPTU-8/16 converts them to U+EF80...U+EFFF in a Private Use Area.[81] In either approach, the byte value is encoded in the low eight bits of the output code point.

These encodings are very useful because they avoid the need to deal with "invalid" byte strings until much later, if at all, and allow "text" and "data" byte arrays to be the same object. If a program wants to use UTF-16 internally these are required to preserve and use filenames that can use invalid UTF-8;[82] as the Windows filesystem API uses UTF-16, the need to support invalid UTF-8 is less there.[80]

For the encoding to be reversible, the standard UTF-8 encodings of the code points used for erroneous bytes must be considered invalid. This makes the encoding incompatible with WTF-8 or CESU-8 (though only for 128 code points). When re-encoding it is necessary to be careful of sequences of error code points which convert back to valid UTF-8, which may be used by malicious software to get unexpected characters in the output, though this cannot produce ASCII characters so it is considered comparatively safe, since malicious sequences (such as cross-site scripting) usually rely on ASCII characters.[82]

See also[edit]
Alt code
Character encodings in HTML
Comparison of e-mail clients#Features
Comparison of Unicode encodings
Iconv
Specials (Unicode block)
Unicode and email
Unicode and HTML
Percent-encoding#Current standard
UTF-EBCDIC
Notes[edit]
^ 17 planes times 216 code points per plane, minus 211 technically-invalid surrogates.
^ You might expect larger code points than U+10FFFF to be expressible, but in RFC3629 ¬ß3 UTF-8 is limited to match the limits of UTF-16. (As ¬ß12 notes, this is changed from RFC 2279.)
^ The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi), when the pure text was pasted to Notepad, generated 19 KB when saved as UTF-16 and 22 KB when saved as UTF-8.
^ The 2010-10-27 version of UTF-8 (in Japanese) generated 169 KB when converted with Notepad to UTF-16, and only 101 KB when converted back to UTF-8. The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi) required 119 KB in UTF-16 and 76 KB in UTF-8.
References[edit]
^ "Chapter 2. General Structure". The Unicode Standard (6.0 ed.). Mountain View, California, US: The Unicode Consortium. ISBN 978-1-936213-01-6.
^ Jump up to: a b Pike, Rob (30 April 2003). "UTF-8 history".
^ Pike, Rob; Thompson, Ken (1993). "Hello World or ŒöŒ±ŒªŒ∑ŒºŒ≠œÅŒ± Œ∫œåœÉŒºŒµ or „Åì„Çì„Å´„Å°„ÅØ ‰∏ñÁïå" (PDF). Proceedings of the Winter 1993 USENIX Conference.
^ Jump up to: a b c "Usage Survey of Character Encodings broken down by Ranking". w3techs.com. Retrieved 2020-08-24.
^ Jump up to: a b Davis, Mark (2012-02-03). "Unicode over 60 percent of the web". Official Google Blog. Archived from the original on 2018-08-09. Retrieved 2020-07-24.
^ "Encoding Standard". encoding.spec.whatwg.org. Retrieved 2020-04-15.
^ "Using International Characters in Internet Mail". Internet Mail Consortium. 1998-08-01. Archived from the original on 2007-10-26. Retrieved 2007-11-08.
^ "Encoding Standard". encoding.spec.whatwg.org. Retrieved 2018-11-15.
^ Davis, Mark (2008-05-05). "Moving to Unicode 5.1". Retrieved 2013-03-01.
^ "Specifying the document's character encoding". HTML5.2. World Wide Web Consortium. 14 December 2017. Retrieved 2018-06-03.
^ "The JavaScript Object Notation (JSON) Data Interchange Format". IETF. December 2017. Retrieved 16 February 2018.
^ "Usage Statistics and Market Share of US-ASCII for Websites, August 2020". w3techs.com. Retrieved 2020-08-28.
^ "Distribution of Character Encodings among websites that use Iranian languages". w3techs.com. Retrieved 2018-12-03.
^ "Distribution of Character Encodings among websites that use Sign Languages". w3techs.com. Retrieved 2018-12-03.
^ "Distribution of Character Encodings among websites that use .cn". w3techs.com. Retrieved 2020-09-01.
^ "Distribution of Character Encodings among websites that use Chinese". w3techs.com. Retrieved 2020-07-03.
^ "Distribution of Character Encodings among websites that use .ru". w3techs.com. Retrieved 2020-09-01.
^ "Distribution of Character Encodings among websites that use Greek". w3techs.com. Retrieved 2020-09-07.
^ "Distribution of Character Encodings among websites that use Hebrew". w3techs.com. Retrieved 2020-09-07.
^ "Historical trends in the usage of character encodings". Retrieved 2020-07-24.
^ "UTF-8 Usage Statistics". BuiltWith. Retrieved 2011-03-28.
^ "Usage Report of UTF-8 broken down by Content Languages". w3techs.com. Retrieved 2020-09-07.
^ "UTF-8 - ICU User Guide". userguide.icu-project.org. Retrieved 2018-04-03.
^ "#13311 (change illegal-UTF-8 handling to Unicode "best practice")". bugs.icu-project.org. Retrieved 2018-04-03.
^ "Use the Windows UTF-8 code page". UWP applications. docs.microsoft.com. Retrieved 2020-06-06.
^ Allen, Julie D.; Anderson, Deborah; Becker, Joe; Cook, Richard, eds. (2012). "The Unicode Standard, Version 6.1". Mountain View, California: Unicode Consortium.
^ https://ci.apache.org/projects/flink/flink-docs-release-1.9/api/java/org/apache/flink/table/dataformat/BinaryString.html#compareTo-org.apache.flink.table.dataformat.BinaryString-
^ "Chapter 3", The Unicode Standard (PDF), p. 54
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ "Chapter 3", The Unicode Standard (PDF), p. 54
^ Yergeau, F. (November 2003). UTF-8, a transformation format of ISO 10646. IETF. doi:10.17487/RFC3629. STD 63. RFC 3629. Retrieved August 20, 2020.
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ Yergeau, F. (November 2003). UTF-8, a transformation format of ISO 10646. IETF. doi:10.17487/RFC3629. STD 63. RFC 3629. Retrieved August 20, 2020.
^ Marin, Marvin (2000-10-17). "Web Server Folder Traversal MS00-078".
^ "Summary for CVE-2008-2938". National Vulnerability Database.
^ Jump up to: a b Yergeau, F. (2003). UTF-8, a transformation format of ISO 10646. Internet Engineering Task Force. doi:10.17487/RFC3629. RFC 3629. Retrieved 2015-02-03.
^ Java's DataInput IO Interface
^ "Non-decodable Bytes in System Character Interfaces". python.org. 2009-04-22. Retrieved 2014-08-13.
^ "Unicode 6.0.0".
^ 128 1-byte, (16+5)√ó64 2-byte, and 5√ó64√ó64 3-byte. There may be somewhat fewer if more precise tests are done for each continuation byte.
^ "Chapter 2", The Unicode Standard (PDF), p. 30
^ Jump up to: a b "Character Sets". Internet Assigned Numbers Authority. 2013-01-23. Retrieved 2013-02-08.
^ D√ºrst, Martin. "Setting the HTTP charset parameter". W3C. Retrieved 2013-02-08.
^ "Encoding Standard ¬ß 4.2. Names and labels". WHATWG. Retrieved 2018-04-29.
^ "BOM". suikawiki (in Japanese). Retrieved 2013-04-26.
^ Davis, Mark. "Forms of Unicode". IBM. Archived from the original on 2005-05-06. Retrieved 2013-09-18.
^ Liviu (2014-02-07). "UTF-8 codepage 65001 in Windows 7 - part I". Retrieved 2018-01-30.
^ "Script How to set default encoding to UTF-8 for notepad by PowerShell". gallery.technet.microsoft.com. Retrieved 2018-01-30.
^ "HP PCL Symbol Sets | Printer Control Language (PCL & PXL) Support Blog". 2015-02-19. Archived from the original on 2015-02-19. Retrieved 2018-01-30.
^ "Appendix F. FSS-UTF / File System Safe UCS Transformation format" (PDF). The Unicode Standard 1.1. Archived (PDF) from the original on 2016-06-07. Retrieved 2016-06-07.
^ Whistler, Kenneth (2001-06-12). "FSS-UTF, UTF-2, UTF-8, and UTF-16". Archived from the original on 2016-06-07. Retrieved 2006-06-07.
^ Jump up to: a b Pike, Rob (2003-04-30). "UTF-8 history". Retrieved 2012-09-07.
^ Pike, Rob (2012-09-06). "UTF-8 turned 20 years old yesterday". Retrieved 2012-09-07.
^ Alvestrand, Harald (January 1998). IETF Policy on Character Sets and Languages. doi:10.17487/RFC2277. BCP 18.
^ ISO/IEC 10646:2014 ¬ß9.1, 2014.
^ The Unicode Standard, Version 11.0 ¬ß3.9 D92, ¬ß3.10 D95, 2018.
^ Unicode Standard Annex #27: Unicode 3.1, 2001.
^ The Unicode Standard, Version 5.0 ¬ß3.9‚Äì¬ß3.10 ch. 3, 2006.
^ The Unicode Standard, Version 6.0 ¬ß3.9 D92, ¬ß3.10 D95, 2010.
^ McGowan, Rick (2011-12-19). "Compatibility Encoding Scheme for UTF-16: 8-Bit (CESU-8)". Unicode Consortium. Unicode Technical Report #26.
^ "Character Set Support". Oracle Database 19c Documentation, SQL Language Reference. Oracle Corporation.
^ "Supporting Multilingual Databases with Unicode ¬ß Support for the Unicode Standard in Oracle Database". Database Globalization Support Guide. Oracle Corporation.
^ "8.2.2.3. Character encodings". HTML 5.1 Standard. W3C.
^ "8.2.2.3. Character encodings". HTML 5 Standard. W3C.
^ "12.2.3.3 Character encodings". HTML Living Standard. WHATWG.
^ "The utf8mb3 Character Set (3-Byte UTF-8 Unicode Encoding)". MySQL 8.0 Reference Manual. Oracle Corporation.
^ "Java SE documentation for Interface java.io.DataInput, subsection on Modified UTF-8". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "Java Object Serialization Specification, chapter 6: Object Serialization Stream Protocol, section 2: Stream Elements". Oracle Corporation. 2010. Retrieved 2015-10-16.
^ "Java Native Interface Specification, chapter 3: JNI Types and Data Structures, section: Modified UTF-8 Strings". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "ART and Dalvik". Android Open Source Project. Archived from the original on 2013-04-26. Retrieved 2013-04-09.
^ "Tcler's Wiki: UTF-8 bit by bit (Revision 6)". 2009-04-25. Retrieved 2009-05-22.
^ Sapin, Simon (2016-03-11) [2014-09-25]. "The WTF-8 encoding". Archived from the original on 2016-05-24. Retrieved 2016-05-24.
^ Sapin, Simon (2015-03-25) [2014-09-25]. "The WTF-8 encoding ¬ß Motivation". Archived from the original on 2016-05-24. Retrieved 2020-08-26.
^ "WTF-8.com". 2006-05-18. Retrieved 2016-06-21.
^ Speer, Robyn (2015-05-21). "ftfy (fixes text for you) 4.0: changing less and fixing more". Archived from the original on 2015-05-30. Retrieved 2016-06-21.
^ "WTF-8, a transformation format of code page 1252". Archived from the original on 2016-10-13. Retrieved 2016-10-12.
^ Jump up to: a b von L√∂wis, Martin (2009-04-22). "Non-decodable Bytes in System Character Interfaces". Python Software Foundation. PEP 383.
^ "RTFM optu8to16(3), optu8to16vis(3)". www.mirbsd.org.
^ Jump up to: a b Davis, Mark; Suignard, Michel (2014). "3.7 Enabling Lossless Conversion". Unicode Security Considerations. Unicode Technical Report #36.
External links[edit]
Original UTF-8 paper (or pdf) for Plan 9 from Bell Labs
UTF-8 test pages:
Andreas Prilop
Jost Gippert
World Wide Web Consortium
Unix/Linux: UTF-8/Unicode FAQ, Linux Unicode HOWTO, 8.xml UTF-8 and Gentoo
Characters, Symbols and the Unicode Miracle on YouTube
showvte
Unicode
showvte
Character encodings
showvte
Rob Pike
showvte
Ken Thompson
Categories: Character encodingComputer-related introductions in 1993EncodingsUnicode Transformation Formats
Navigation menu
Not logged inTalkContributionsCreate accountLog in
ArticleTalk
ReadEditView history
Search

Main page
Contents
Current events
Random article
About Wikipedia
Contact us
Donate
Contribute
Help
Learn to edit
Community portal
Recent changes
Upload file
Tools
What links here
Related changes
Special pages
Permanent link
Page information
Cite this page
Wikidata item
Print/export
Download as PDF
Printable version

Languages
ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
Espa√±ol
Bahasa Indonesia
Italiano
Bahasa Melayu
Portugu√™s
–†—É—Å—Å–∫–∏–π
ÿßÿ±ÿØŸà
‰∏≠Êñá
32 more
Edit links
This page was last edited on 20 October 2020, at 18:05 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia¬Æ is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
Privacy policyAbout WikipediaDisclaimersContact WikipediaMobile viewDevelopersStatisticsCookie statement
Wikimedia FoundationPowered by MediaWiki

UTF-8
From Wikipedia, the free encyclopedia
Jump to navigationJump to search
UTF-8
Standard	Unicode Standard
Classification	Unicode Transformation Format, extended ASCII, variable-width encoding
Extends	US-ASCII
Transforms / Encodes	ISO 10646 (Unicode)
Preceded by	UTF-1
vte
UTF-8 is a variable-width character encoding used for electronic communication. Defined by the Unicode Standard, the name is derived from Unicode (or Universal Coded Character Set) Transformation Format ‚Äì 8-bit.[1]

UTF-8 is capable of encoding all 1,112,064[nb 1] valid character code points in Unicode using one to four one-byte (8-bit) code units. Code points with lower numerical values, which tend to occur more frequently, are encoded using fewer bytes. It was designed for backward compatibility with ASCII: the first 128 characters of Unicode, which correspond one-to-one with ASCII, are encoded using a single byte with the same binary value as ASCII, so that valid ASCII text is valid UTF-8-encoded Unicode as well. Since ASCII bytes do not occur when encoding non-ASCII code points into UTF-8, UTF-8 is safe to use within most programming and document languages that interpret certain ASCII characters in a special way, such as "/" (slash) in filenames, "\" (backslash) in escape sequences, and "%" in printf.

UTF-8 was designed as a superior alternative to UTF-1, a proposed variable-width encoding with partial ASCII compatibility which lacked some features including self-synchronization and fully ASCII-compatible handling of characters such as slashes. Ken Thompson and Rob Pike produced the first implementation for the Plan 9 operating system in September 1992.[2][3] This led to its adoption by X/Open as its specification for FSS-UTF, which would first be officially presented at USENIX in January 1993 and subsequently adopted by the Internet Engineering Task Force (IETF) in RFC 2277 (BCP 18) for future Internet standards work, replacing Single Byte Character Sets such as Latin-1 in older RFCs.

UTF-8 is by far the most common encoding for the World Wide Web, accounting for over 95% of all web pages, and up to 100% for some languages, as of 2020.[4]


Contents
1	Adoption
2	Encoding
2.1	Examples
2.2	Codepage layout
2.3	Overlong encodings
2.4	Invalid sequences and error handling
2.5	Byte order mark
3	Naming
4	History
5	Standards
6	Comparison with other encodings
6.1	Single-byte
6.2	Other multi-byte
6.3	UTF-16
7	Derivatives
7.1	CESU-8
7.2	MySQL utf8mb3
7.3	Modified UTF-8
7.4	WTF-8
7.5	PEP 383
8	See also
9	Notes
10	References
11	External links
Adoption[edit]

Use of the main encodings on the web from 2001 to 2012 as recorded by Google,[5] with UTF-8 overtaking all others in 2008 and over 60% of the web in 2012. The ASCII-only figure includes all web pages that only contain ASCII characters, regardless of the declared header.
UTF-8 is the recommendation from the WHATWG for HTML and DOM specifications,[6] and the Internet Mail Consortium recommends that all e-mail programs be able to display and create mail using UTF-8.[7][8]

Google reported that in 2008, UTF-8 (labelled "Unicode") became the most common encoding for HTML files.[9]

Since 2009, UTF-8 has been the most common encoding for the World Wide Web.[4] The World Wide Web Consortium recommends UTF-8 as the default encoding in XML and HTML (and not just using UTF-8, also stating it in metadata), "even when all characters are in the ASCII range .. Using non-UTF-8 encodings can have unexpected results".[10] Many other standards only support UTF-8, e.g. open JSON exchange requires it.[11]

As of October 2020, UTF-8 accounts on average for 95.5% of all web pages and 97% of the top 1,000 highest ranked web pages.[4] (This takes into account that ASCII is valid UTF-8.[12]) Several languages have 100.0% use of UTF-8 on the web, such as Punjabi, Tagalog, Lao, Marathi, Kannada, Kurdish, Pashto, Javanese, Greenlandic (Kalaallisut) and Iranian languages[13] and sign languages.[14]

In locales where UTF-8 is used alongside another encoding, the latter is typically more efficient for the associated language. The Chinese standard GB 2312 and with its extension GBK (which are both interpreted by web browsers as GB 18030, having support for the same letters as UTF-8) have a combined 14.5% share in China[15][16] and a 0.5% share world-wide. Big5 is another popular Chinese encoding with 0.1% share world-wide. The single-byte Windows-1251 is twice as efficient for the Cyrillic script and is used for 10.6% of Russian web sites.[17] E.g. Greek and Hebrew encodings are also twice as efficient, but still those languages have over 95% use of UTF-8.[18][19] EUC-KR is more efficient for Korean text and is used for 17.3% of South Korean websites. Shift JIS and EUC-JP have a 10.5% share on Japanese websites (the more popular Shift JIS has 0.2% global share).[20][21][5] With the exception of GB 18030 and UTF-16, these encodings were designed for specific languages, and do not support all Unicode characters. As of September 2020, the Breton language has the lowest UTF-8 use on the Web of any tracked language, with 79.4% use.[22]

International Components for Unicode (ICU) has historically used UTF-16, and still does only for Java; while for C/C++ UTF-8 is now supported as the "Default Charset",[23] including the correct handling of "illegal UTF-8".[24]

For local text files UTF-8 usage is lower, and many legacy single-byte encodings remain in use. This is primarily due to editors that will not display or write UTF-8 unless the first character in a file is a byte order mark, making it impossible for other software to use UTF-8 without being rewritten to ignore the byte order mark on input and add it on output. UTF-16 files are also fairly common on Windows, but not elsewhere.[original research?] Internally in software usage is even lower, with UCS-2 and UTF-32 in use, particularly in Windows but also Python, JavaScript, Qt, and many other software libraries. This is due to a belief that direct indexing of code points is more important than 8-bit compatibility.[citation needed] UTF-16 is also used due to being compatible with UCS-2, even though it does not have direct indexing. Microsoft now recommends UTF-8 for Windows programs,[25] while previously they emphasized "Unicode" (meaning UTF-16) Win32 API, this may mean internal use of UTF-8 will increase in the future.[original research?]

Encoding[edit]
Since the restriction of the Unicode code-space to 21-bit values in 2003, UTF-8 is defined to encode code points in one to four bytes, depending on the number of significant bits in the numerical value of the code point. The following table shows the structure of the encoding. The x characters are replaced by the bits of the code point.

Layout of UTF-8 byte sequences
Number of bytes	First code point	Last code point	Byte 1	Byte 2	Byte 3	Byte 4
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+07FF	110xxxxx	10xxxxxx
3	U+0800	U+FFFF	1110xxxx	10xxxxxx	10xxxxxx
4	U+10000	[nb 2]U+10FFFF	11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
The first 128 characters (US-ASCII) need one byte. The next 1,920 characters need two bytes to encode, which covers the remainder of almost all Latin-script alphabets, and also Greek, Cyrillic, Coptic, Armenian, Hebrew, Arabic, Syriac, Thaana and N'Ko alphabets, as well as Combining Diacritical Marks. Three bytes are needed for characters in the rest of the Basic Multilingual Plane, which contains virtually all characters in common use,[26] including most Chinese, Japanese and Korean characters. Four bytes are needed for characters in the other planes of Unicode, which include less common CJK characters, various historic scripts, mathematical symbols, and emoji (pictographic symbols).

Examples[edit]
Consider the encoding of the Euro sign, ‚Ç¨:

The Unicode code point for "‚Ç¨" is U+20AC.
As this code point lies between U+0800 and U+FFFF, this will take three bytes to encode.
Hexadecimal 20AC is binary 0010 0000 1010 1100. The two leading zeros are added because a three-byte encoding needs exactly sixteen bits from the code point.
Because the encoding will be three bytes long, its leading byte starts with three 1s, then a 0 (1110...)
The four most significant bits of the code point are stored in the remaining low order four bits of this byte (1110 0010), leaving 12 bits of the code point yet to be encoded (...0000 1010 1100).
All continuation bytes contain exactly six bits from the code point. So the next six bits of the code point are stored in the low order six bits of the next byte, and 10 is stored in the high order two bits to mark it as a continuation byte (so 1000 0010).
Finally the last six bits of the code point are stored in the low order six bits of the final byte, and again 10 is stored in the high order two bits (1010 1100).
The three bytes 1110 0010 1000 0010 1010 1100 can be more concisely written in hexadecimal, as E2 82 AC.

The following table summarises this conversion, as well as others with different lengths in UTF-8. The colors indicate how bits from the code point are distributed among the UTF-8 bytes. Additional bits added by the UTF-8 encoding process are shown in black.

Representation of UTF-8 characters
Character	Code point	UTF-8
Octal	Binary	Binary	Octal	Hexadecimal
$	U+0024	044	010 0100	00100100	044	24
¬¢	U+00A2	0242	000 1010 0010	11000010 10100010	302 242	C2 A2
‡§π	U+0939	004471	0000 1001 0011 1001	11100000 10100100 10111001	340 244 271	E0 A4 B9
‚Ç¨	U+20AC	020254	0010 0000 1010 1100	11100010 10000010 10101100	342 202 254	E2 82 AC
Ìïú	U+D55C	152534	1101 0101 0101 1100	11101101 10010101 10011100	355 225 234	ED 95 9C
êçà	U+10348	0201510	0 0001 0000 0011 0100 1000	11110000 10010000 10001101 10001000	360 220 215 210	F0 90 8D 88
UTF-8's use of six bits per byte to represent the actual characters being encoded means that octal notation (which uses 3-bit groups) can aid in the comparison of UTF-8 sequences with one another.[27]

Codepage layout[edit]
The following table summarizes usage of UTF-8 code units (individual bytes or octets) in a code page format. The upper half (0_ to 7_) is for bytes used only in single-byte codes, so it looks like a normal code page; the lower half is for continuation bytes (8_ to B_) and leading bytes (C_ to F_), and is explained further in the legend below.

UTF-8
_0	_1	_2	_3	_4	_5	_6	_7	_8	_9	_A	_B	_C	_D	_E	_F
0_	NUL
0000	SOH
0001	STX
0002	ETX
0003	EOT
0004	ENQ
0005	ACK
0006	BEL
0007	BS
0008	HT
0009	LF
000A	VT
000B	FF
000C	CR
000D	SO
000E	SI
000F
1_	DLE
0010	DC1
0011	DC2
0012	DC3
0013	DC4
0014	NAK
0015	SYN
0016	ETB
0017	CAN
0018	EM
0019	SUB
001A	ESC
001B	FS
001C	GS
001D	RS
001E	US
001F
2_	SP
0020	!
0021	"
0022	#
0023	$
0024	%
0025	&
0026	'
0027	(
0028	)
0029	*
002A	+
002B	,
002C	-
002D	.
002E	/
002F
3_	0
0030	1
0031	2
0032	3
0033	4
0034	5
0035	6
0036	7
0037	8
0038	9
0039	:
003A	;
003B	<
003C	=
003D	>
003E	?
003F
4_	@
0040	A
0041	B
0042	C
0043	D
0044	E
0045	F
0046	G
0047	H
0048	I
0049	J
004A	K
004B	L
004C	M
004D	N
004E	O
004F
5_	P
0050	Q
0051	R
0052	S
0053	T
0054	U
0055	V
0056	W
0057	X
0058	Y
0059	Z
005A	[
005B	\
005C	]
005D	^
005E	_
005F
6_	`
0060	a
0061	b
0062	c
0063	d
0064	e
0065	f
0066	g
0067	h
0068	i
0069	j
006A	k
006B	l
006C	m
006D	n
006E	o
006F
7_	p
0070	q
0071	r
0072	s
0073	t
0074	u
0075	v
0076	w
0077	x
0078	y
0079	z
007A	{
007B	|
007C	}
007D	~
007E	DEL
007F
8_	‚Ä¢
+00	‚Ä¢
+01	‚Ä¢
+02	‚Ä¢
+03	‚Ä¢
+04	‚Ä¢
+05	‚Ä¢
+06	‚Ä¢
+07	‚Ä¢
+08	‚Ä¢
+09	‚Ä¢
+0A	‚Ä¢
+0B	‚Ä¢
+0C	‚Ä¢
+0D	‚Ä¢
+0E	‚Ä¢
+0F
9_	‚Ä¢
+10	‚Ä¢
+11	‚Ä¢
+12	‚Ä¢
+13	‚Ä¢
+14	‚Ä¢
+15	‚Ä¢
+16	‚Ä¢
+17	‚Ä¢
+18	‚Ä¢
+19	‚Ä¢
+1A	‚Ä¢
+1B	‚Ä¢
+1C	‚Ä¢
+1D	‚Ä¢
+1E	‚Ä¢
+1F
A_	‚Ä¢
+20	‚Ä¢
+21	‚Ä¢
+22	‚Ä¢
+23	‚Ä¢
+24	‚Ä¢
+25	‚Ä¢
+26	‚Ä¢
+27	‚Ä¢
+28	‚Ä¢
+29	‚Ä¢
+2A	‚Ä¢
+2B	‚Ä¢
+2C	‚Ä¢
+2D	‚Ä¢
+2E	‚Ä¢
+2F
B_	‚Ä¢
+30	‚Ä¢
+31	‚Ä¢
+32	‚Ä¢
+33	‚Ä¢
+34	‚Ä¢
+35	‚Ä¢
+36	‚Ä¢
+37	‚Ä¢
+38	‚Ä¢
+39	‚Ä¢
+3A	‚Ä¢
+3B	‚Ä¢
+3C	‚Ä¢
+3D	‚Ä¢
+3E	‚Ä¢
+3F
2
C_	2
0000	2
0040	Latin
0080	Latin
00C0	Latin
0100	Latin
0140	Latin
0180	Latin
01C0	Latin
0200	IPA
0240	IPA
0280	IPA
02C0	accents
0300	accents
0340	Greek
0380	Greek
03C0
2
D_	Cyril
0400	Cyril
0440	Cyril
0480	Cyril
04C0	Cyril
0500	Armeni
0540	Hebrew
0580	Hebrew
05C0	Arabic
0600	Arabic
0640	Arabic
0680	Arabic
06C0	Syriac
0700	Arabic
0740	Thaana
0780	N'Ko
07C0
3
E_	Indic
0800	Misc.
1000	Symbol
2000	Kana‚Ä¶
3000	CJK
4000	CJK
5000	CJK
6000	CJK
7000	CJK
8000	CJK
9000	Asian
A000	Hangul
B000	Hangul
C000	Hangul
D000	PUA
E000	Forms
F000
4
F_	SMP‚Ä¶
10000	ÒÄÄÄ
40000	ÚÄÄÄ
80000	SSP‚Ä¶
C0000	SPU‚Ä¶
100000	4
140000	4
180000	4
1C0000	5
200000	5
1000000	5
2000000	5
3000000	6
4000000	6
40000000
  Blue cells are 7-bit (single-byte) sequences. They must not be followed by a continuation byte.[28]

  Orange cells with a large dot are continuation bytes.[29] The hexadecimal number shown after the + symbol is the value of the 6 bits they add.

  White cells are the leading bytes for a sequence of multiple bytes,[30] the length shown at the left edge of the row. The text shows the Unicode blocks encoded by sequences starting with this byte, and the hexadecimal code point shown in the cell is the lowest character value encoded using that leading byte.

  Red cells must never appear in a valid UTF-8 sequence. The first two red cells (C0 and C1) could be used only for a 2-byte encoding of a 7-bit ASCII character which should be encoded in 1 byte; as described below, such "overlong" sequences are disallowed.[31] The red cells in the F_ row (F5 to FD) indicate leading bytes of 4-byte or longer sequences that cannot be valid because they would encode code points larger than the U+10FFFF limit of Unicode (a limit derived from the maximum code point encodable in UTF-16 [32]). FE and FF do not match any allowed character pattern and are therefore not valid start bytes.[33]

  Pink cells are the leading bytes for a sequence of multiple bytes, of which some, but not all, possible continuation sequences are valid. E0 and F0 could start overlong encodings, in this case the lowest non-overlong-encoded code point is shown. F4 can start code points greater than U+10FFFF which are invalid. ED can start the encoding of a code point in the range U+D800‚ÄìU+DFFF; these are invalid since they are reserved for UTF-16 surrogate halves.[34]

Overlong encodings[edit]
In principle, it would be possible to inflate the number of bytes in an encoding by padding the code point with leading 0s. To encode the Euro sign ‚Ç¨ from the above example in four bytes instead of three, it could be padded with leading 0s until it was 21 bits long ‚Äì 000 000010 000010 101100, and encoded as 11110000 10000010 10000010 10101100 (or F0 82 82 AC in hexadecimal). This is called an overlong encoding.

The standard specifies that the correct encoding of a code point uses only the minimum number of bytes required to hold the significant bits of the code point. Longer encodings are called overlong and are not valid UTF-8 representations of the code point. This rule maintains a one-to-one correspondence between code points and their valid encodings, so that there is a unique valid encoding for each code point. This ensures that string comparisons and searches are well-defined.

Invalid sequences and error handling[edit]
Not all sequences of bytes are valid UTF-8. A UTF-8 decoder should be prepared for:

invalid bytes
an unexpected continuation byte
a non-continuation byte before the end of the character
the string ending before the end of the character (which can happen in simple string truncation)
an overlong encoding
a sequence that decodes to an invalid code point
Many of the first UTF-8 decoders would decode these, ignoring incorrect bits and accepting overlong results. Carefully crafted invalid UTF-8 could make them either skip or create ASCII characters such as NUL, slash, or quotes. Invalid UTF-8 has been used to bypass security validations in high-profile products including Microsoft's IIS web server[35] and Apache's Tomcat servlet container.[36] RFC 3629 states "Implementations of the decoding algorithm MUST protect against decoding invalid sequences."[37] The Unicode Standard requires decoders to "...treat any ill-formed code unit sequence as an error condition. This guarantees that it will neither interpret nor emit an ill-formed code unit sequence."

Since RFC 3629 (November 2003), the high and low surrogate halves used by UTF-16 (U+D800 through U+DFFF) and code points not encodable by UTF-16 (those after U+10FFFF) are not legal Unicode values, and their UTF-8 encoding must be treated as an invalid byte sequence. Not decoding unpaired surrogate halves makes it impossible to store invalid UTF-16 (such as Windows filenames or UTF-16 that has been split between the surrogates) as UTF-8.[citation needed]

Some implementations of decoders throw exceptions on errors.[38] This has the disadvantage that it can turn what would otherwise be harmless errors (such as a "no such file" error) into a denial of service. For instance early versions of Python 3.0 would exit immediately if the command line or environment variables contained invalid UTF-8.[39] An alternative practice is to replace errors with a replacement character. Since Unicode 6[40] (October 2010), the standard (chapter 3) has recommended a "best practice" where the error ends as soon as a disallowed byte is encountered. In these decoders E1,A0,C0 is two errors (2 bytes in the first one). This means an error is no more than three bytes long and never contains the start of a valid character, and there are 21,952 different possible errors.[41] The standard also recommends replacing each error with the replacement character "ÔøΩ" (U+FFFD).

Byte order mark[edit]
If the UTF-16 Unicode byte order mark (BOM) character is at the start of a UTF-8 file, the first three bytes will be 0xEF, 0xBB, 0xBF.

The Unicode Standard neither requires nor recommends the use of the BOM for UTF-8, but warns that it may be encountered at the start of a file trans-coded from another encoding.[42] While ASCII text encoded using UTF-8 is backward compatible with ASCII, this is not true when Unicode Standard recommendations are ignored and a BOM is added. Nevertheless, there was and still is software that always inserts a BOM when writing UTF-8, and refuses to correctly interpret UTF-8 unless the first character is a BOM (or the file only contains ASCII).[citation needed]

Naming[edit]
The official Internet Assigned Numbers Authority (IANA) code for the encoding is "UTF-8".[43] All letters are upper-case, and the name is hyphenated. This spelling is used in all the Unicode Consortium documents relating to the encoding.

Alternatively, the name "utf-8" may be used by all standards conforming to the IANA list (which include CSS, HTML, XML, and HTTP headers),[44] as the declaration is case insensitive.[43]

Other descriptions, such as those that omit the hyphen or replace it with a space, i.e. "utf8" or "UTF 8", are not accepted as correct by the governing standards.[37] Despite this, most agents such as browsers can understand them, and so standards intended to describe existing practice (such as HTML5) may effectively require their recognition.[45]

Unofficially, UTF-8-BOM and UTF-8-NOBOM are sometimes used to refer to text files which respectively contain and lack a byte order mark (BOM).[citation needed] In Japan especially, UTF-8 encoding without BOM is sometimes called "UTF-8N".[46][47]

Windows 7 and later, i.e. all supported Windows versions, have codepage 65001, as a synonym for UTF-8 (with better support than in older Windows),[48] and Microsoft has a script for Windows 10, to enable it by default for its program Microsoft Notepad.[49]

In PCL, UTF-8 is called Symbol-ID "18N" (PCL supports 183 character encodings, called Symbol Sets, which potentially could be reduced to one, 18N, that is UTF-8).[50]

History[edit]
See also: Universal Coded Character Set ¬ß History
The International Organization for Standardization (ISO) set out to compose a universal multi-byte character set in 1989. The draft ISO 10646 standard contained a non-required annex called UTF-1 that provided a byte stream encoding of its 32-bit code points. This encoding was not satisfactory on performance grounds, among other problems, and the biggest problem was probably that it did not have a clear separation between ASCII and non-ASCII: new UTF-1 tools would be backward compatible with ASCII-encoded text, but UTF-1-encoded text could confuse existing code expecting ASCII (or extended ASCII), because it could contain continuation bytes in the range 0x21‚Äì0x7E that meant something else in ASCII, e.g., 0x2F for '/', the Unix path directory separator, and this example is reflected in the name and introductory text of its replacement. The table below was derived from a textual description in the annex.

UTF-1
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5
1	U+0000	U+009F	00‚Äì9F
2	U+00A0	U+00FF	A0	A0‚ÄìFF
2	U+0100	U+4015	A1‚ÄìF5	21‚Äì7E, A0‚ÄìFF
3	U+4016	U+38E2D	F6‚ÄìFB	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF
5	U+38E2E	U+7FFFFFFF	FC‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF
In July 1992, the X/Open committee XoJIG was looking for a better encoding. Dave Prosser of Unix System Laboratories submitted a proposal for one that had faster implementation characteristics and introduced the improvement that 7-bit ASCII characters would only represent themselves; all multi-byte sequences would include only bytes where the high bit was set. The name File System Safe UCS Transformation Format (FSS-UTF) and most of the text of this proposal were later preserved in the final specification.[51][52][53][54]

FSS-UTF proposal (1992)
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+207F	10xxxxxx	1xxxxxxx
3	U+2080	U+8207F	110xxxxx	1xxxxxxx	1xxxxxxx
4	U+82080	U+208207F	1110xxxx	1xxxxxxx	1xxxxxxx	1xxxxxxx
5	U+2082080	U+7FFFFFFF	11110xxx	1xxxxxxx	1xxxxxxx	1xxxxxxx	1xxxxxxx
In August 1992, this proposal was circulated by an IBM X/Open representative to interested parties. A modification by Ken Thompson of the Plan 9 operating system group at Bell Labs made it somewhat less bit-efficient than the previous proposal but crucially allowed it to be self-synchronizing, letting a reader start anywhere and immediately detect byte sequence boundaries. It also abandoned the use of biases and instead added the rule that only the shortest possible encoding is allowed; the additional loss in compactness is relatively insignificant, but readers now have to look out for invalid encodings to avoid reliability and especially security issues. Thompson's design was outlined on September 2, 1992, on a placemat in a New Jersey diner with Rob Pike. In the following days, Pike and Thompson implemented it and updated Plan 9 to use it throughout, and then communicated their success back to X/Open, which accepted it as the specification for FSS-UTF.[53]

FSS-UTF (1992) / UTF-8 (1993)[2]
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5	Byte 6
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+07FF	110xxxxx	10xxxxxx
3	U+0800	U+FFFF	1110xxxx	10xxxxxx	10xxxxxx
4	U+10000	U+1FFFFF	11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
5	U+200000	U+3FFFFFF	111110xx	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx
6	U+4000000	U+7FFFFFFF	1111110x	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx
UTF-8 was first officially presented at the USENIX conference in San Diego, from January 25 to 29, 1993. The Internet Engineering Task Force adopted UTF-8 in its Policy on Character Sets and Languages in RFC 2277 (BCP 18) for future Internet standards work, replacing Single Byte Character Sets such as Latin-1 in older RFCs.[55]

In November 2003, UTF-8 was restricted by RFC 3629 to match the constraints of the UTF-16 character encoding: explicitly prohibiting code points corresponding to the high and low surrogate characters removed more than 3% of the three-byte sequences, and ending at U+10FFFF removed more than 48% of the four-byte sequences and all five- and six-byte sequences.

Standards[edit]
There are several current definitions of UTF-8 in various standards documents:

RFC 3629 / STD 63 (2003), which establishes UTF-8 as a standard Internet protocol element
RFC 5198 defines UTF-8 NFC for Network Interchange (2008)
ISO/IEC 10646:2014 ¬ß9.1 (2014)[56]
The Unicode Standard, Version 11.0 (2018)[57]
They supersede the definitions given in the following obsolete works:

The Unicode Standard, Version 2.0, Appendix A (1996)
ISO/IEC 10646-1:1993 Amendment 2 / Annex R (1996)
RFC 2044 (1996)
RFC 2279 (1998)
The Unicode Standard, Version 3.0, ¬ß2.3 (2000) plus Corrigendum #1 : UTF-8 Shortest Form (2000)
Unicode Standard Annex #27: Unicode 3.1 (2001)[58]
The Unicode Standard, Version 5.0 (2006)[59]
The Unicode Standard, Version 6.0 (2010)[60]
They are all the same in their general mechanics, with the main differences being on issues such as allowed range of code point values and safe handling of invalid input.

Comparison with other encodings[edit]
See also: Comparison of Unicode encodings
Some of the important features of this encoding are as follows:

Backward compatibility: Backward compatibility with ASCII and the enormous amount of software designed to process ASCII-encoded text was the main driving force behind the design of UTF-8. In UTF-8, single bytes with values in the range of 0 to 127 map directly to Unicode code points in the ASCII range. Single bytes in this range represent characters, as they do in ASCII. Moreover, 7-bit bytes (bytes where the most significant bit is 0) never appear in a multi-byte sequence, and no valid multi-byte sequence decodes to an ASCII code-point. A sequence of 7-bit bytes is both valid ASCII and valid UTF-8, and under either interpretation represents the same sequence of characters. Therefore, the 7-bit bytes in a UTF-8 stream represent all and only the ASCII characters in the stream. Thus, many text processors, parsers, protocols, file formats, text display programs, etc., which use ASCII characters for formatting and control purposes, will continue to work as intended by treating the UTF-8 byte stream as a sequence of single-byte characters, without decoding the multi-byte sequences. ASCII characters on which the processing turns, such as punctuation, whitespace, and control characters will never be encoded as multi-byte sequences. It is therefore safe for such processors to simply ignore or pass-through the multi-byte sequences, without decoding them. For example, ASCII whitespace may be used to tokenize a UTF-8 stream into words; ASCII line-feeds may be used to split a UTF-8 stream into lines; and ASCII NUL characters can be used to split UTF-8-encoded data into null-terminated strings. Similarly, many format strings used by library functions like "printf" will correctly handle UTF-8-encoded input arguments.
Fallback and auto-detection: Only a small subset of possible byte strings are a valid UTF-8 string: the bytes C0, C1, and F5 through FF cannot appear, and bytes with the high bit set must be in pairs, and other requirements. It is extremely unlikely that a readable text in any extended ASCII is valid UTF-8. Part of the popularity of UTF-8 is due to it providing a form of backward compatibility for these as well. A UTF-8 processor which erroneously receives extended ASCII as input can thus "auto-detect" this with very high reliability. Fallback errors will be false negatives, and these will be rare. Moreover, in many applications, such as text display, the consequence of incorrect fallback is usually slight.[original research?] A UTF-8 stream may simply contain errors, resulting in the auto-detection scheme producing false positives; but auto-detection is successful in the majority of cases, especially with longer texts, and is widely used. It also works to "fall back" or replace 8-bit bytes using the appropriate code-point for a legacy encoding only when errors in the UTF-8 are detected, allowing recovery even if UTF-8 and legacy encoding is concatenated in the same file.
Prefix code: The first byte indicates the number of bytes in the sequence. Reading from a stream can instantaneously decode each individual fully received sequence, without first having to wait for either the first byte of a next sequence or an end-of-stream indication. The length of multi-byte sequences is easily determined by humans as it is simply the number of high-order 1s in the leading byte. An incorrect character will not be decoded if a stream ends mid-sequence.
Self-synchronization: The leading bytes and the continuation bytes do not share values (continuation bytes start with the bits 10 while single bytes start with 0 and longer lead bytes start with 11). This means a search will not accidentally find the sequence for one character starting in the middle of another character. It also means the start of a character can be found from a random position by backing up at most 3 bytes to find the leading byte. An incorrect character will not be decoded if a stream starts mid-sequence, and a shorter sequence will never appear inside a longer one.
Sorting order: The chosen values of the leading bytes means that a list of UTF-8 strings can be sorted in code point order by sorting the corresponding byte sequences.
Single-byte[edit]
UTF-8 can encode any Unicode character, avoiding the need to figure out and set a "code page" or otherwise indicate what character set is in use, and allowing output in multiple scripts at the same time. For many scripts there have been more than one single-byte encoding in usage, so even knowing the script was insufficient information to display it correctly.
The bytes 0xFE and 0xFF do not appear, so a valid UTF-8 stream never matches the UTF-16 byte order mark and thus cannot be confused with it. The absence of 0xFF (0377) also eliminates the need to escape this byte in Telnet (and FTP control connection).
UTF-8 encoded text is larger than specialized single-byte encodings except for plain ASCII characters. In the case of scripts which used 8-bit character sets with non-Latin characters encoded in the upper half (such as most Cyrillic and Greek alphabet code pages), characters in UTF-8 will be double the size. For some scripts, such as Thai and Devanagari (which is used by various South Asian languages), characters will triple in size. There are even examples where a single byte turns into a composite character in Unicode and is thus six times larger in UTF-8. This has caused objections in India and other countries.
It is possible in UTF-8 (or any other variable-length encoding) to split or truncate a string in the middle of a character. If the two pieces are not re-appended later before interpretation as characters, this can introduce an invalid sequence at both the end of the previous section and the start of the next, and some decoders will not preserve these bytes and result in data loss. Because UTF-8 is self-synchronizing this will however never introduce a different valid character, and it is also fairly easy to move the truncation point backward to the start of a character.
If the code points are all the same size, measurements of a fixed number of them is easy. Due to ASCII-era documentation where "character" is used as a synonym for "byte" this is often considered important. However, by measuring string positions using bytes instead of "characters" most algorithms can be easily and efficiently adapted for UTF-8. Searching for a string within a long string can for example be done byte by byte; the self-synchronization property prevents false positives.
Other multi-byte[edit]
UTF-8 can encode any Unicode character. Files in different scripts can be displayed correctly without having to choose the correct code page or font. For instance, Chinese and Arabic can be written in the same file without specialised markup or manual settings that specify an encoding.
UTF-8 is self-synchronizing: character boundaries are easily identified by scanning for well-defined bit patterns in either direction. If bytes are lost due to error or corruption, one can always locate the next valid character and resume processing. If there is a need to shorten a string to fit a specified field, the previous valid character can easily be found. Many multi-byte encodings such as Shift JIS are much harder to resynchronize. This also means that byte-oriented string-searching algorithms can be used with UTF-8 (as a character is the same as a "word" made up of that many bytes), optimized versions of byte searches can be much faster due to hardware support and lookup tables that have only 256 entries. Self-synchronization does however require that bits be reserved for these markers in every byte, increasing the size.
Efficient to encode using simple bitwise operations. UTF-8 does not require slower mathematical operations such as multiplication or division (unlike Shift JIS, GB 2312 and other encodings).
UTF-8 will take more space than a multi-byte encoding designed for a specific script. East Asian legacy encodings generally used two bytes per character yet take three bytes per character in UTF-8.
UTF-16[edit]
Byte encodings and UTF-8 are represented by byte arrays in programs, and often nothing needs to be done to a function when converting source code from a byte encoding to UTF-8. UTF-16 is represented by 16-bit word arrays, and converting to UTF-16 while maintaining compatibility with existing ASCII-based programs (such as was done with Windows) requires every API and data structure that takes a string to be duplicated, one version accepting byte strings and another version accepting UTF-16. If backward compatibility is not needed, all string handling still must be modified.
Text encoded in UTF-8 will be smaller than the same text encoded in UTF-16 if there are more code points below U+0080 than in the range U+0800..U+FFFF. This is true for all modern European languages.
Text in (for example) Chinese, Japanese or Devanagari will take more space in UTF-8 if there are more of these characters than there are ASCII characters. This is likely when data mainly consist of pure prose, but is lessened by the degree to which the context uses ASCII whitespace, digits, and punctuation.[nb 3]
Most of the rich text formats (including HTML) contain a large proportion of ASCII characters for the sake of formatting, thus the size usually will be reduced significantly compared with UTF-16, even when the language mostly uses 3-byte long characters in UTF-8.[nb 4]
Most communication (e.g. HTML and IP) and storage (e.g. for Unix) was designed for a stream of bytes. A UTF-16 string must use a pair of bytes for each code unit:
The order of those two bytes becomes an issue and must be specified in the UTF-16 protocol, such as with a byte order mark.
If an odd number of bytes is missing from UTF-16, the whole rest of the string will be meaningless text. Any bytes missing from UTF-8 will still allow the text to be recovered accurately starting with the next character after the missing bytes.
Derivatives[edit]
The following implementations show slight differences from the UTF-8 specification. They are incompatible with the UTF-8 specification and may be rejected by conforming UTF-8 applications.

CESU-8[edit]
Main article: CESU-8
Unicode Technical Report #26[61] assigns the name CESU-8 to a nonstandard variant of UTF-8, in which Unicode characters in supplementary planes are encoded using six bytes, rather than the four bytes required by UTF-8. CESU-8 encoding treats each half of a four-byte UTF-16 surrogate pair as a two-byte UCS-2 character, yielding two three-byte UTF-8 characters, which together represent the original supplementary character. Unicode characters within the Basic Multilingual Plane appear as they would normally in UTF-8. The Report was written to acknowledge and formalize the existence of data encoded as CESU-8, despite the Unicode Consortium discouraging its use, and notes that a possible intentional reason for CESU-8 encoding is preservation of UTF-16 binary collation.

CESU-8 encoding can result from converting UTF-16 data with supplementary characters to UTF-8, using conversion methods that assume UCS-2 data, meaning they are unaware of four-byte UTF-16 supplementary characters. It is primarily an issue on operating systems which extensively use UTF-16 internally, such as Microsoft Windows.[citation needed]

In Oracle Database, the UTF8 character set uses CESU-8 encoding, and is deprecated. The AL32UTF8 character set uses standards-compliant UTF-8 encoding, and is preferred.[62][63]

CESU-8 is prohibited for use in HTML5 documents.[64][65][66]

MySQL utf8mb3[edit]
In MySQL, the utf8mb3 character set is defined to be UTF-8 encoded data with a maximum of three bytes per character, meaning only Unicode characters in the Basic Multilingual Plane are supported. Unicode characters in supplementary planes are explicitly not supported. utf8mb3 is deprecated in favor of the utf8mb4 character set, which uses standards-compliant UTF-8 encoding. utf8 is an alias for utf8mb3, but is intended to become an alias to utf8mb4 in a future release of MySQL.[67] It is possible, though unsupported, to store CESU-8 encoded data in utf8mb3, by handling UTF-16 data with supplementary characters as though it is UCS-2.

Modified UTF-8[edit]
Modified UTF-8 (MUTF-8) originated in the Java programming language. In Modified UTF-8, the null character (U+0000) uses the two-byte overlong encoding 11000000 10000000 (hexadecimal C0 80), instead of 00000000 (hexadecimal 00).[68] Modified UTF-8 strings never contain any actual null bytes but can contain all Unicode code points including U+0000,[69] which allows such strings (with a null byte appended) to be processed by traditional null-terminated string functions. All known Modified UTF-8 implementations also treat the surrogate pairs as in CESU-8.

In normal usage, the language supports standard UTF-8 when reading and writing strings through InputStreamReader and OutputStreamWriter (if it is the platform's default character set or as requested by the program). However it uses Modified UTF-8 for object serialization[70] among other applications of DataInput and DataOutput, for the Java Native Interface,[71] and for embedding constant strings in class files.[72]

The dex format defined by Dalvik also uses the same modified UTF-8 to represent string values.[73] Tcl also uses the same modified UTF-8[74] as Java for internal representation of Unicode data, but uses strict CESU-8 for external data.

WTF-8[edit]

This section contains a list of miscellaneous information. Please relocate any relevant information into other sections or articles. (August 2020)
In WTF-8 (Wobbly Transformation Format, 8-bit) unpaired surrogate halves (U+D800 through U+DFFF) are allowed.[75] This is necessary to store possibly-invalid UTF-16, such as Windows filenames. Many systems that deal with UTF-8 work this way without considering it a different encoding, as it is simpler.[76]

(The term "WTF-8" has also been used humorously to refer to erroneously doubly-encoded UTF-8[77][78] sometimes with the implication that CP1252 bytes are the only ones encoded)[79]

PEP 383[edit]
Version 3 of the Python programming language treats each byte of an invalid UTF-8 bytestream as an error; this gives 128 different possible errors. Extensions have been created to allow any byte sequence that is assumed to be UTF-8 to be lossless transformed to UTF-16 or UTF-32, by translating the 128 possible error bytes to reserved code points, and transforming those code points back to error bytes to output UTF-8. The most common approach is to translate the codes to U+DC80...U+DCFF which are low (trailing) surrogate values and thus "invalid" UTF-16, as used by Python's PEP 383 (or "surrogateescape") approach.[80] Another encoding called MirBSD OPTU-8/16 converts them to U+EF80...U+EFFF in a Private Use Area.[81] In either approach, the byte value is encoded in the low eight bits of the output code point.

These encodings are very useful because they avoid the need to deal with "invalid" byte strings until much later, if at all, and allow "text" and "data" byte arrays to be the same object. If a program wants to use UTF-16 internally these are required to preserve and use filenames that can use invalid UTF-8;[82] as the Windows filesystem API uses UTF-16, the need to support invalid UTF-8 is less there.[80]

For the encoding to be reversible, the standard UTF-8 encodings of the code points used for erroneous bytes must be considered invalid. This makes the encoding incompatible with WTF-8 or CESU-8 (though only for 128 code points). When re-encoding it is necessary to be careful of sequences of error code points which convert back to valid UTF-8, which may be used by malicious software to get unexpected characters in the output, though this cannot produce ASCII characters so it is considered comparatively safe, since malicious sequences (such as cross-site scripting) usually rely on ASCII characters.[82]

See also[edit]
Alt code
Character encodings in HTML
Comparison of e-mail clients#Features
Comparison of Unicode encodings
Iconv
Specials (Unicode block)
Unicode and email
Unicode and HTML
Percent-encoding#Current standard
UTF-EBCDIC
Notes[edit]
^ 17 planes times 216 code points per plane, minus 211 technically-invalid surrogates.
^ You might expect larger code points than U+10FFFF to be expressible, but in RFC3629 ¬ß3 UTF-8 is limited to match the limits of UTF-16. (As ¬ß12 notes, this is changed from RFC 2279.)
^ The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi), when the pure text was pasted to Notepad, generated 19 KB when saved as UTF-16 and 22 KB when saved as UTF-8.
^ The 2010-10-27 version of UTF-8 (in Japanese) generated 169 KB when converted with Notepad to UTF-16, and only 101 KB when converted back to UTF-8. The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi) required 119 KB in UTF-16 and 76 KB in UTF-8.
References[edit]
^ "Chapter 2. General Structure". The Unicode Standard (6.0 ed.). Mountain View, California, US: The Unicode Consortium. ISBN 978-1-936213-01-6.
^ Jump up to: a b Pike, Rob (30 April 2003). "UTF-8 history".
^ Pike, Rob; Thompson, Ken (1993). "Hello World or ŒöŒ±ŒªŒ∑ŒºŒ≠œÅŒ± Œ∫œåœÉŒºŒµ or „Åì„Çì„Å´„Å°„ÅØ ‰∏ñÁïå" (PDF). Proceedings of the Winter 1993 USENIX Conference.
^ Jump up to: a b c "Usage Survey of Character Encodings broken down by Ranking". w3techs.com. Retrieved 2020-08-24.
^ Jump up to: a b Davis, Mark (2012-02-03). "Unicode over 60 percent of the web". Official Google Blog. Archived from the original on 2018-08-09. Retrieved 2020-07-24.
^ "Encoding Standard". encoding.spec.whatwg.org. Retrieved 2020-04-15.
^ "Using International Characters in Internet Mail". Internet Mail Consortium. 1998-08-01. Archived from the original on 2007-10-26. Retrieved 2007-11-08.
^ "Encoding Standard". encoding.spec.whatwg.org. Retrieved 2018-11-15.
^ Davis, Mark (2008-05-05). "Moving to Unicode 5.1". Retrieved 2013-03-01.
^ "Specifying the document's character encoding". HTML5.2. World Wide Web Consortium. 14 December 2017. Retrieved 2018-06-03.
^ "The JavaScript Object Notation (JSON) Data Interchange Format". IETF. December 2017. Retrieved 16 February 2018.
^ "Usage Statistics and Market Share of US-ASCII for Websites, August 2020". w3techs.com. Retrieved 2020-08-28.
^ "Distribution of Character Encodings among websites that use Iranian languages". w3techs.com. Retrieved 2018-12-03.
^ "Distribution of Character Encodings among websites that use Sign Languages". w3techs.com. Retrieved 2018-12-03.
^ "Distribution of Character Encodings among websites that use .cn". w3techs.com. Retrieved 2020-09-01.
^ "Distribution of Character Encodings among websites that use Chinese". w3techs.com. Retrieved 2020-07-03.
^ "Distribution of Character Encodings among websites that use .ru". w3techs.com. Retrieved 2020-09-01.
^ "Distribution of Character Encodings among websites that use Greek". w3techs.com. Retrieved 2020-09-07.
^ "Distribution of Character Encodings among websites that use Hebrew". w3techs.com. Retrieved 2020-09-07.
^ "Historical trends in the usage of character encodings". Retrieved 2020-07-24.
^ "UTF-8 Usage Statistics". BuiltWith. Retrieved 2011-03-28.
^ "Usage Report of UTF-8 broken down by Content Languages". w3techs.com. Retrieved 2020-09-07.
^ "UTF-8 - ICU User Guide". userguide.icu-project.org. Retrieved 2018-04-03.
^ "#13311 (change illegal-UTF-8 handling to Unicode "best practice")". bugs.icu-project.org. Retrieved 2018-04-03.
^ "Use the Windows UTF-8 code page". UWP applications. docs.microsoft.com. Retrieved 2020-06-06.
^ Allen, Julie D.; Anderson, Deborah; Becker, Joe; Cook, Richard, eds. (2012). "The Unicode Standard, Version 6.1". Mountain View, California: Unicode Consortium.
^ https://ci.apache.org/projects/flink/flink-docs-release-1.9/api/java/org/apache/flink/table/dataformat/BinaryString.html#compareTo-org.apache.flink.table.dataformat.BinaryString-
^ "Chapter 3", The Unicode Standard (PDF), p. 54
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ "Chapter 3", The Unicode Standard (PDF), p. 54
^ Yergeau, F. (November 2003). UTF-8, a transformation format of ISO 10646. IETF. doi:10.17487/RFC3629. STD 63. RFC 3629. Retrieved August 20, 2020.
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ Yergeau, F. (November 2003). UTF-8, a transformation format of ISO 10646. IETF. doi:10.17487/RFC3629. STD 63. RFC 3629. Retrieved August 20, 2020.
^ Marin, Marvin (2000-10-17). "Web Server Folder Traversal MS00-078".
^ "Summary for CVE-2008-2938". National Vulnerability Database.
^ Jump up to: a b Yergeau, F. (2003). UTF-8, a transformation format of ISO 10646. Internet Engineering Task Force. doi:10.17487/RFC3629. RFC 3629. Retrieved 2015-02-03.
^ Java's DataInput IO Interface
^ "Non-decodable Bytes in System Character Interfaces". python.org. 2009-04-22. Retrieved 2014-08-13.
^ "Unicode 6.0.0".
^ 128 1-byte, (16+5)√ó64 2-byte, and 5√ó64√ó64 3-byte. There may be somewhat fewer if more precise tests are done for each continuation byte.
^ "Chapter 2", The Unicode Standard (PDF), p. 30
^ Jump up to: a b "Character Sets". Internet Assigned Numbers Authority. 2013-01-23. Retrieved 2013-02-08.
^ D√ºrst, Martin. "Setting the HTTP charset parameter". W3C. Retrieved 2013-02-08.
^ "Encoding Standard ¬ß 4.2. Names and labels". WHATWG. Retrieved 2018-04-29.
^ "BOM". suikawiki (in Japanese). Retrieved 2013-04-26.
^ Davis, Mark. "Forms of Unicode". IBM. Archived from the original on 2005-05-06. Retrieved 2013-09-18.
^ Liviu (2014-02-07). "UTF-8 codepage 65001 in Windows 7 - part I". Retrieved 2018-01-30.
^ "Script How to set default encoding to UTF-8 for notepad by PowerShell". gallery.technet.microsoft.com. Retrieved 2018-01-30.
^ "HP PCL Symbol Sets | Printer Control Language (PCL & PXL) Support Blog". 2015-02-19. Archived from the original on 2015-02-19. Retrieved 2018-01-30.
^ "Appendix F. FSS-UTF / File System Safe UCS Transformation format" (PDF). The Unicode Standard 1.1. Archived (PDF) from the original on 2016-06-07. Retrieved 2016-06-07.
^ Whistler, Kenneth (2001-06-12). "FSS-UTF, UTF-2, UTF-8, and UTF-16". Archived from the original on 2016-06-07. Retrieved 2006-06-07.
^ Jump up to: a b Pike, Rob (2003-04-30). "UTF-8 history". Retrieved 2012-09-07.
^ Pike, Rob (2012-09-06). "UTF-8 turned 20 years old yesterday". Retrieved 2012-09-07.
^ Alvestrand, Harald (January 1998). IETF Policy on Character Sets and Languages. doi:10.17487/RFC2277. BCP 18.
^ ISO/IEC 10646:2014 ¬ß9.1, 2014.
^ The Unicode Standard, Version 11.0 ¬ß3.9 D92, ¬ß3.10 D95, 2018.
^ Unicode Standard Annex #27: Unicode 3.1, 2001.
^ The Unicode Standard, Version 5.0 ¬ß3.9‚Äì¬ß3.10 ch. 3, 2006.
^ The Unicode Standard, Version 6.0 ¬ß3.9 D92, ¬ß3.10 D95, 2010.
^ McGowan, Rick (2011-12-19). "Compatibility Encoding Scheme for UTF-16: 8-Bit (CESU-8)". Unicode Consortium. Unicode Technical Report #26.
^ "Character Set Support". Oracle Database 19c Documentation, SQL Language Reference. Oracle Corporation.
^ "Supporting Multilingual Databases with Unicode ¬ß Support for the Unicode Standard in Oracle Database". Database Globalization Support Guide. Oracle Corporation.
^ "8.2.2.3. Character encodings". HTML 5.1 Standard. W3C.
^ "8.2.2.3. Character encodings". HTML 5 Standard. W3C.
^ "12.2.3.3 Character encodings". HTML Living Standard. WHATWG.
^ "The utf8mb3 Character Set (3-Byte UTF-8 Unicode Encoding)". MySQL 8.0 Reference Manual. Oracle Corporation.
^ "Java SE documentation for Interface java.io.DataInput, subsection on Modified UTF-8". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "Java Object Serialization Specification, chapter 6: Object Serialization Stream Protocol, section 2: Stream Elements". Oracle Corporation. 2010. Retrieved 2015-10-16.
^ "Java Native Interface Specification, chapter 3: JNI Types and Data Structures, section: Modified UTF-8 Strings". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "ART and Dalvik". Android Open Source Project. Archived from the original on 2013-04-26. Retrieved 2013-04-09.
^ "Tcler's Wiki: UTF-8 bit by bit (Revision 6)". 2009-04-25. Retrieved 2009-05-22.
^ Sapin, Simon (2016-03-11) [2014-09-25]. "The WTF-8 encoding". Archived from the original on 2016-05-24. Retrieved 2016-05-24.
^ Sapin, Simon (2015-03-25) [2014-09-25]. "The WTF-8 encoding ¬ß Motivation". Archived from the original on 2016-05-24. Retrieved 2020-08-26.
^ "WTF-8.com". 2006-05-18. Retrieved 2016-06-21.
^ Speer, Robyn (2015-05-21). "ftfy (fixes text for you) 4.0: changing less and fixing more". Archived from the original on 2015-05-30. Retrieved 2016-06-21.
^ "WTF-8, a transformation format of code page 1252". Archived from the original on 2016-10-13. Retrieved 2016-10-12.
^ Jump up to: a b von L√∂wis, Martin (2009-04-22). "Non-decodable Bytes in System Character Interfaces". Python Software Foundation. PEP 383.
^ "RTFM optu8to16(3), optu8to16vis(3)". www.mirbsd.org.
^ Jump up to: a b Davis, Mark; Suignard, Michel (2014). "3.7 Enabling Lossless Conversion". Unicode Security Considerations. Unicode Technical Report #36.
External links[edit]
Original UTF-8 paper (or pdf) for Plan 9 from Bell Labs
UTF-8 test pages:
Andreas Prilop
Jost Gippert
World Wide Web Consortium
Unix/Linux: UTF-8/Unicode FAQ, Linux Unicode HOWTO, 8.xml UTF-8 and Gentoo
Characters, Symbols and the Unicode Miracle on YouTube
showvte
Unicode
showvte
Character encodings
showvte
Rob Pike
showvte
Ken Thompson
Categories: Character encodingComputer-related introductions in 1993EncodingsUnicode Transformation Formats
Navigation menu
Not logged inTalkContributionsCreate accountLog in
ArticleTalk
ReadEditView history
Search

Main page
Contents
Current events
Random article
About Wikipedia
Contact us
Donate
Contribute
Help
Learn to edit
Community portal
Recent changes
Upload file
Tools
What links here
Related changes
Special pages
Permanent link
Page information
Cite this page
Wikidata item
Print/export
Download as PDF
Printable version

Languages
ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
Espa√±ol
Bahasa Indonesia
Italiano
Bahasa Melayu
Portugu√™s
–†—É—Å—Å–∫–∏–π
ÿßÿ±ÿØŸà
‰∏≠Êñá
32 more
Edit links
This page was last edited on 20 October 2020, at 18:05 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia¬Æ is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
Privacy policyAbout WikipediaDisclaimersContact WikipediaMobile viewDevelopersStatisticsCookie statement
Wikimedia FoundationPowered by MediaWiki

UTF-8
From Wikipedia, the free encyclopedia
Jump to navigationJump to search
UTF-8
Standard	Unicode Standard
Classification	Unicode Transformation Format, extended ASCII, variable-width encoding
Extends	US-ASCII
Transforms / Encodes	ISO 10646 (Unicode)
Preceded by	UTF-1
vte
UTF-8 is a variable-width character encoding used for electronic communication. Defined by the Unicode Standard, the name is derived from Unicode (or Universal Coded Character Set) Transformation Format ‚Äì 8-bit.[1]

UTF-8 is capable of encoding all 1,112,064[nb 1] valid character code points in Unicode using one to four one-byte (8-bit) code units. Code points with lower numerical values, which tend to occur more frequently, are encoded using fewer bytes. It was designed for backward compatibility with ASCII: the first 128 characters of Unicode, which correspond one-to-one with ASCII, are encoded using a single byte with the same binary value as ASCII, so that valid ASCII text is valid UTF-8-encoded Unicode as well. Since ASCII bytes do not occur when encoding non-ASCII code points into UTF-8, UTF-8 is safe to use within most programming and document languages that interpret certain ASCII characters in a special way, such as "/" (slash) in filenames, "\" (backslash) in escape sequences, and "%" in printf.

UTF-8 was designed as a superior alternative to UTF-1, a proposed variable-width encoding with partial ASCII compatibility which lacked some features including self-synchronization and fully ASCII-compatible handling of characters such as slashes. Ken Thompson and Rob Pike produced the first implementation for the Plan 9 operating system in September 1992.[2][3] This led to its adoption by X/Open as its specification for FSS-UTF, which would first be officially presented at USENIX in January 1993 and subsequently adopted by the Internet Engineering Task Force (IETF) in RFC 2277 (BCP 18) for future Internet standards work, replacing Single Byte Character Sets such as Latin-1 in older RFCs.

UTF-8 is by far the most common encoding for the World Wide Web, accounting for over 95% of all web pages, and up to 100% for some languages, as of 2020.[4]


Contents
1	Adoption
2	Encoding
2.1	Examples
2.2	Codepage layout
2.3	Overlong encodings
2.4	Invalid sequences and error handling
2.5	Byte order mark
3	Naming
4	History
5	Standards
6	Comparison with other encodings
6.1	Single-byte
6.2	Other multi-byte
6.3	UTF-16
7	Derivatives
7.1	CESU-8
7.2	MySQL utf8mb3
7.3	Modified UTF-8
7.4	WTF-8
7.5	PEP 383
8	See also
9	Notes
10	References
11	External links
Adoption[edit]

Use of the main encodings on the web from 2001 to 2012 as recorded by Google,[5] with UTF-8 overtaking all others in 2008 and over 60% of the web in 2012. The ASCII-only figure includes all web pages that only contain ASCII characters, regardless of the declared header.
UTF-8 is the recommendation from the WHATWG for HTML and DOM specifications,[6] and the Internet Mail Consortium recommends that all e-mail programs be able to display and create mail using UTF-8.[7][8]

Google reported that in 2008, UTF-8 (labelled "Unicode") became the most common encoding for HTML files.[9]

Since 2009, UTF-8 has been the most common encoding for the World Wide Web.[4] The World Wide Web Consortium recommends UTF-8 as the default encoding in XML and HTML (and not just using UTF-8, also stating it in metadata), "even when all characters are in the ASCII range .. Using non-UTF-8 encodings can have unexpected results".[10] Many other standards only support UTF-8, e.g. open JSON exchange requires it.[11]

As of October 2020, UTF-8 accounts on average for 95.5% of all web pages and 97% of the top 1,000 highest ranked web pages.[4] (This takes into account that ASCII is valid UTF-8.[12]) Several languages have 100.0% use of UTF-8 on the web, such as Punjabi, Tagalog, Lao, Marathi, Kannada, Kurdish, Pashto, Javanese, Greenlandic (Kalaallisut) and Iranian languages[13] and sign languages.[14]

In locales where UTF-8 is used alongside another encoding, the latter is typically more efficient for the associated language. The Chinese standard GB 2312 and with its extension GBK (which are both interpreted by web browsers as GB 18030, having support for the same letters as UTF-8) have a combined 14.5% share in China[15][16] and a 0.5% share world-wide. Big5 is another popular Chinese encoding with 0.1% share world-wide. The single-byte Windows-1251 is twice as efficient for the Cyrillic script and is used for 10.6% of Russian web sites.[17] E.g. Greek and Hebrew encodings are also twice as efficient, but still those languages have over 95% use of UTF-8.[18][19] EUC-KR is more efficient for Korean text and is used for 17.3% of South Korean websites. Shift JIS and EUC-JP have a 10.5% share on Japanese websites (the more popular Shift JIS has 0.2% global share).[20][21][5] With the exception of GB 18030 and UTF-16, these encodings were designed for specific languages, and do not support all Unicode characters. As of September 2020, the Breton language has the lowest UTF-8 use on the Web of any tracked language, with 79.4% use.[22]

International Components for Unicode (ICU) has historically used UTF-16, and still does only for Java; while for C/C++ UTF-8 is now supported as the "Default Charset",[23] including the correct handling of "illegal UTF-8".[24]

For local text files UTF-8 usage is lower, and many legacy single-byte encodings remain in use. This is primarily due to editors that will not display or write UTF-8 unless the first character in a file is a byte order mark, making it impossible for other software to use UTF-8 without being rewritten to ignore the byte order mark on input and add it on output. UTF-16 files are also fairly common on Windows, but not elsewhere.[original research?] Internally in software usage is even lower, with UCS-2 and UTF-32 in use, particularly in Windows but also Python, JavaScript, Qt, and many other software libraries. This is due to a belief that direct indexing of code points is more important than 8-bit compatibility.[citation needed] UTF-16 is also used due to being compatible with UCS-2, even though it does not have direct indexing. Microsoft now recommends UTF-8 for Windows programs,[25] while previously they emphasized "Unicode" (meaning UTF-16) Win32 API, this may mean internal use of UTF-8 will increase in the future.[original research?]

Encoding[edit]
Since the restriction of the Unicode code-space to 21-bit values in 2003, UTF-8 is defined to encode code points in one to four bytes, depending on the number of significant bits in the numerical value of the code point. The following table shows the structure of the encoding. The x characters are replaced by the bits of the code point.

Layout of UTF-8 byte sequences
Number of bytes	First code point	Last code point	Byte 1	Byte 2	Byte 3	Byte 4
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+07FF	110xxxxx	10xxxxxx
3	U+0800	U+FFFF	1110xxxx	10xxxxxx	10xxxxxx
4	U+10000	[nb 2]U+10FFFF	11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
The first 128 characters (US-ASCII) need one byte. The next 1,920 characters need two bytes to encode, which covers the remainder of almost all Latin-script alphabets, and also Greek, Cyrillic, Coptic, Armenian, Hebrew, Arabic, Syriac, Thaana and N'Ko alphabets, as well as Combining Diacritical Marks. Three bytes are needed for characters in the rest of the Basic Multilingual Plane, which contains virtually all characters in common use,[26] including most Chinese, Japanese and Korean characters. Four bytes are needed for characters in the other planes of Unicode, which include less common CJK characters, various historic scripts, mathematical symbols, and emoji (pictographic symbols).

Examples[edit]
Consider the encoding of the Euro sign, ‚Ç¨:

The Unicode code point for "‚Ç¨" is U+20AC.
As this code point lies between U+0800 and U+FFFF, this will take three bytes to encode.
Hexadecimal 20AC is binary 0010 0000 1010 1100. The two leading zeros are added because a three-byte encoding needs exactly sixteen bits from the code point.
Because the encoding will be three bytes long, its leading byte starts with three 1s, then a 0 (1110...)
The four most significant bits of the code point are stored in the remaining low order four bits of this byte (1110 0010), leaving 12 bits of the code point yet to be encoded (...0000 1010 1100).
All continuation bytes contain exactly six bits from the code point. So the next six bits of the code point are stored in the low order six bits of the next byte, and 10 is stored in the high order two bits to mark it as a continuation byte (so 1000 0010).
Finally the last six bits of the code point are stored in the low order six bits of the final byte, and again 10 is stored in the high order two bits (1010 1100).
The three bytes 1110 0010 1000 0010 1010 1100 can be more concisely written in hexadecimal, as E2 82 AC.

The following table summarises this conversion, as well as others with different lengths in UTF-8. The colors indicate how bits from the code point are distributed among the UTF-8 bytes. Additional bits added by the UTF-8 encoding process are shown in black.

Representation of UTF-8 characters
Character	Code point	UTF-8
Octal	Binary	Binary	Octal	Hexadecimal
$	U+0024	044	010 0100	00100100	044	24
¬¢	U+00A2	0242	000 1010 0010	11000010 10100010	302 242	C2 A2
‡§π	U+0939	004471	0000 1001 0011 1001	11100000 10100100 10111001	340 244 271	E0 A4 B9
‚Ç¨	U+20AC	020254	0010 0000 1010 1100	11100010 10000010 10101100	342 202 254	E2 82 AC
Ìïú	U+D55C	152534	1101 0101 0101 1100	11101101 10010101 10011100	355 225 234	ED 95 9C
êçà	U+10348	0201510	0 0001 0000 0011 0100 1000	11110000 10010000 10001101 10001000	360 220 215 210	F0 90 8D 88
UTF-8's use of six bits per byte to represent the actual characters being encoded means that octal notation (which uses 3-bit groups) can aid in the comparison of UTF-8 sequences with one another.[27]

Codepage layout[edit]
The following table summarizes usage of UTF-8 code units (individual bytes or octets) in a code page format. The upper half (0_ to 7_) is for bytes used only in single-byte codes, so it looks like a normal code page; the lower half is for continuation bytes (8_ to B_) and leading bytes (C_ to F_), and is explained further in the legend below.

UTF-8
_0	_1	_2	_3	_4	_5	_6	_7	_8	_9	_A	_B	_C	_D	_E	_F
0_	NUL
0000	SOH
0001	STX
0002	ETX
0003	EOT
0004	ENQ
0005	ACK
0006	BEL
0007	BS
0008	HT
0009	LF
000A	VT
000B	FF
000C	CR
000D	SO
000E	SI
000F
1_	DLE
0010	DC1
0011	DC2
0012	DC3
0013	DC4
0014	NAK
0015	SYN
0016	ETB
0017	CAN
0018	EM
0019	SUB
001A	ESC
001B	FS
001C	GS
001D	RS
001E	US
001F
2_	SP
0020	!
0021	"
0022	#
0023	$
0024	%
0025	&
0026	'
0027	(
0028	)
0029	*
002A	+
002B	,
002C	-
002D	.
002E	/
002F
3_	0
0030	1
0031	2
0032	3
0033	4
0034	5
0035	6
0036	7
0037	8
0038	9
0039	:
003A	;
003B	<
003C	=
003D	>
003E	?
003F
4_	@
0040	A
0041	B
0042	C
0043	D
0044	E
0045	F
0046	G
0047	H
0048	I
0049	J
004A	K
004B	L
004C	M
004D	N
004E	O
004F
5_	P
0050	Q
0051	R
0052	S
0053	T
0054	U
0055	V
0056	W
0057	X
0058	Y
0059	Z
005A	[
005B	\
005C	]
005D	^
005E	_
005F
6_	`
0060	a
0061	b
0062	c
0063	d
0064	e
0065	f
0066	g
0067	h
0068	i
0069	j
006A	k
006B	l
006C	m
006D	n
006E	o
006F
7_	p
0070	q
0071	r
0072	s
0073	t
0074	u
0075	v
0076	w
0077	x
0078	y
0079	z
007A	{
007B	|
007C	}
007D	~
007E	DEL
007F
8_	‚Ä¢
+00	‚Ä¢
+01	‚Ä¢
+02	‚Ä¢
+03	‚Ä¢
+04	‚Ä¢
+05	‚Ä¢
+06	‚Ä¢
+07	‚Ä¢
+08	‚Ä¢
+09	‚Ä¢
+0A	‚Ä¢
+0B	‚Ä¢
+0C	‚Ä¢
+0D	‚Ä¢
+0E	‚Ä¢
+0F
9_	‚Ä¢
+10	‚Ä¢
+11	‚Ä¢
+12	‚Ä¢
+13	‚Ä¢
+14	‚Ä¢
+15	‚Ä¢
+16	‚Ä¢
+17	‚Ä¢
+18	‚Ä¢
+19	‚Ä¢
+1A	‚Ä¢
+1B	‚Ä¢
+1C	‚Ä¢
+1D	‚Ä¢
+1E	‚Ä¢
+1F
A_	‚Ä¢
+20	‚Ä¢
+21	‚Ä¢
+22	‚Ä¢
+23	‚Ä¢
+24	‚Ä¢
+25	‚Ä¢
+26	‚Ä¢
+27	‚Ä¢
+28	‚Ä¢
+29	‚Ä¢
+2A	‚Ä¢
+2B	‚Ä¢
+2C	‚Ä¢
+2D	‚Ä¢
+2E	‚Ä¢
+2F
B_	‚Ä¢
+30	‚Ä¢
+31	‚Ä¢
+32	‚Ä¢
+33	‚Ä¢
+34	‚Ä¢
+35	‚Ä¢
+36	‚Ä¢
+37	‚Ä¢
+38	‚Ä¢
+39	‚Ä¢
+3A	‚Ä¢
+3B	‚Ä¢
+3C	‚Ä¢
+3D	‚Ä¢
+3E	‚Ä¢
+3F
2
C_	2
0000	2
0040	Latin
0080	Latin
00C0	Latin
0100	Latin
0140	Latin
0180	Latin
01C0	Latin
0200	IPA
0240	IPA
0280	IPA
02C0	accents
0300	accents
0340	Greek
0380	Greek
03C0
2
D_	Cyril
0400	Cyril
0440	Cyril
0480	Cyril
04C0	Cyril
0500	Armeni
0540	Hebrew
0580	Hebrew
05C0	Arabic
0600	Arabic
0640	Arabic
0680	Arabic
06C0	Syriac
0700	Arabic
0740	Thaana
0780	N'Ko
07C0
3
E_	Indic
0800	Misc.
1000	Symbol
2000	Kana‚Ä¶
3000	CJK
4000	CJK
5000	CJK
6000	CJK
7000	CJK
8000	CJK
9000	Asian
A000	Hangul
B000	Hangul
C000	Hangul
D000	PUA
E000	Forms
F000
4
F_	SMP‚Ä¶
10000	ÒÄÄÄ
40000	ÚÄÄÄ
80000	SSP‚Ä¶
C0000	SPU‚Ä¶
100000	4
140000	4
180000	4
1C0000	5
200000	5
1000000	5
2000000	5
3000000	6
4000000	6
40000000
  Blue cells are 7-bit (single-byte) sequences. They must not be followed by a continuation byte.[28]

  Orange cells with a large dot are continuation bytes.[29] The hexadecimal number shown after the + symbol is the value of the 6 bits they add.

  White cells are the leading bytes for a sequence of multiple bytes,[30] the length shown at the left edge of the row. The text shows the Unicode blocks encoded by sequences starting with this byte, and the hexadecimal code point shown in the cell is the lowest character value encoded using that leading byte.

  Red cells must never appear in a valid UTF-8 sequence. The first two red cells (C0 and C1) could be used only for a 2-byte encoding of a 7-bit ASCII character which should be encoded in 1 byte; as described below, such "overlong" sequences are disallowed.[31] The red cells in the F_ row (F5 to FD) indicate leading bytes of 4-byte or longer sequences that cannot be valid because they would encode code points larger than the U+10FFFF limit of Unicode (a limit derived from the maximum code point encodable in UTF-16 [32]). FE and FF do not match any allowed character pattern and are therefore not valid start bytes.[33]

  Pink cells are the leading bytes for a sequence of multiple bytes, of which some, but not all, possible continuation sequences are valid. E0 and F0 could start overlong encodings, in this case the lowest non-overlong-encoded code point is shown. F4 can start code points greater than U+10FFFF which are invalid. ED can start the encoding of a code point in the range U+D800‚ÄìU+DFFF; these are invalid since they are reserved for UTF-16 surrogate halves.[34]

Overlong encodings[edit]
In principle, it would be possible to inflate the number of bytes in an encoding by padding the code point with leading 0s. To encode the Euro sign ‚Ç¨ from the above example in four bytes instead of three, it could be padded with leading 0s until it was 21 bits long ‚Äì 000 000010 000010 101100, and encoded as 11110000 10000010 10000010 10101100 (or F0 82 82 AC in hexadecimal). This is called an overlong encoding.

The standard specifies that the correct encoding of a code point uses only the minimum number of bytes required to hold the significant bits of the code point. Longer encodings are called overlong and are not valid UTF-8 representations of the code point. This rule maintains a one-to-one correspondence between code points and their valid encodings, so that there is a unique valid encoding for each code point. This ensures that string comparisons and searches are well-defined.

Invalid sequences and error handling[edit]
Not all sequences of bytes are valid UTF-8. A UTF-8 decoder should be prepared for:

invalid bytes
an unexpected continuation byte
a non-continuation byte before the end of the character
the string ending before the end of the character (which can happen in simple string truncation)
an overlong encoding
a sequence that decodes to an invalid code point
Many of the first UTF-8 decoders would decode these, ignoring incorrect bits and accepting overlong results. Carefully crafted invalid UTF-8 could make them either skip or create ASCII characters such as NUL, slash, or quotes. Invalid UTF-8 has been used to bypass security validations in high-profile products including Microsoft's IIS web server[35] and Apache's Tomcat servlet container.[36] RFC 3629 states "Implementations of the decoding algorithm MUST protect against decoding invalid sequences."[37] The Unicode Standard requires decoders to "...treat any ill-formed code unit sequence as an error condition. This guarantees that it will neither interpret nor emit an ill-formed code unit sequence."

Since RFC 3629 (November 2003), the high and low surrogate halves used by UTF-16 (U+D800 through U+DFFF) and code points not encodable by UTF-16 (those after U+10FFFF) are not legal Unicode values, and their UTF-8 encoding must be treated as an invalid byte sequence. Not decoding unpaired surrogate halves makes it impossible to store invalid UTF-16 (such as Windows filenames or UTF-16 that has been split between the surrogates) as UTF-8.[citation needed]

Some implementations of decoders throw exceptions on errors.[38] This has the disadvantage that it can turn what would otherwise be harmless errors (such as a "no such file" error) into a denial of service. For instance early versions of Python 3.0 would exit immediately if the command line or environment variables contained invalid UTF-8.[39] An alternative practice is to replace errors with a replacement character. Since Unicode 6[40] (October 2010), the standard (chapter 3) has recommended a "best practice" where the error ends as soon as a disallowed byte is encountered. In these decoders E1,A0,C0 is two errors (2 bytes in the first one). This means an error is no more than three bytes long and never contains the start of a valid character, and there are 21,952 different possible errors.[41] The standard also recommends replacing each error with the replacement character "ÔøΩ" (U+FFFD).

Byte order mark[edit]
If the UTF-16 Unicode byte order mark (BOM) character is at the start of a UTF-8 file, the first three bytes will be 0xEF, 0xBB, 0xBF.

The Unicode Standard neither requires nor recommends the use of the BOM for UTF-8, but warns that it may be encountered at the start of a file trans-coded from another encoding.[42] While ASCII text encoded using UTF-8 is backward compatible with ASCII, this is not true when Unicode Standard recommendations are ignored and a BOM is added. Nevertheless, there was and still is software that always inserts a BOM when writing UTF-8, and refuses to correctly interpret UTF-8 unless the first character is a BOM (or the file only contains ASCII).[citation needed]

Naming[edit]
The official Internet Assigned Numbers Authority (IANA) code for the encoding is "UTF-8".[43] All letters are upper-case, and the name is hyphenated. This spelling is used in all the Unicode Consortium documents relating to the encoding.

Alternatively, the name "utf-8" may be used by all standards conforming to the IANA list (which include CSS, HTML, XML, and HTTP headers),[44] as the declaration is case insensitive.[43]

Other descriptions, such as those that omit the hyphen or replace it with a space, i.e. "utf8" or "UTF 8", are not accepted as correct by the governing standards.[37] Despite this, most agents such as browsers can understand them, and so standards intended to describe existing practice (such as HTML5) may effectively require their recognition.[45]

Unofficially, UTF-8-BOM and UTF-8-NOBOM are sometimes used to refer to text files which respectively contain and lack a byte order mark (BOM).[citation needed] In Japan especially, UTF-8 encoding without BOM is sometimes called "UTF-8N".[46][47]

Windows 7 and later, i.e. all supported Windows versions, have codepage 65001, as a synonym for UTF-8 (with better support than in older Windows),[48] and Microsoft has a script for Windows 10, to enable it by default for its program Microsoft Notepad.[49]

In PCL, UTF-8 is called Symbol-ID "18N" (PCL supports 183 character encodings, called Symbol Sets, which potentially could be reduced to one, 18N, that is UTF-8).[50]

History[edit]
See also: Universal Coded Character Set ¬ß History
The International Organization for Standardization (ISO) set out to compose a universal multi-byte character set in 1989. The draft ISO 10646 standard contained a non-required annex called UTF-1 that provided a byte stream encoding of its 32-bit code points. This encoding was not satisfactory on performance grounds, among other problems, and the biggest problem was probably that it did not have a clear separation between ASCII and non-ASCII: new UTF-1 tools would be backward compatible with ASCII-encoded text, but UTF-1-encoded text could confuse existing code expecting ASCII (or extended ASCII), because it could contain continuation bytes in the range 0x21‚Äì0x7E that meant something else in ASCII, e.g., 0x2F for '/', the Unix path directory separator, and this example is reflected in the name and introductory text of its replacement. The table below was derived from a textual description in the annex.

UTF-1
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5
1	U+0000	U+009F	00‚Äì9F
2	U+00A0	U+00FF	A0	A0‚ÄìFF
2	U+0100	U+4015	A1‚ÄìF5	21‚Äì7E, A0‚ÄìFF
3	U+4016	U+38E2D	F6‚ÄìFB	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF
5	U+38E2E	U+7FFFFFFF	FC‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF
In July 1992, the X/Open committee XoJIG was looking for a better encoding. Dave Prosser of Unix System Laboratories submitted a proposal for one that had faster implementation characteristics and introduced the improvement that 7-bit ASCII characters would only represent themselves; all multi-byte sequences would include only bytes where the high bit was set. The name File System Safe UCS Transformation Format (FSS-UTF) and most of the text of this proposal were later preserved in the final specification.[51][52][53][54]

FSS-UTF proposal (1992)
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+207F	10xxxxxx	1xxxxxxx
3	U+2080	U+8207F	110xxxxx	1xxxxxxx	1xxxxxxx
4	U+82080	U+208207F	1110xxxx	1xxxxxxx	1xxxxxxx	1xxxxxxx
5	U+2082080	U+7FFFFFFF	11110xxx	1xxxxxxx	1xxxxxxx	1xxxxxxx	1xxxxxxx
In August 1992, this proposal was circulated by an IBM X/Open representative to interested parties. A modification by Ken Thompson of the Plan 9 operating system group at Bell Labs made it somewhat less bit-efficient than the previous proposal but crucially allowed it to be self-synchronizing, letting a reader start anywhere and immediately detect byte sequence boundaries. It also abandoned the use of biases and instead added the rule that only the shortest possible encoding is allowed; the additional loss in compactness is relatively insignificant, but readers now have to look out for invalid encodings to avoid reliability and especially security issues. Thompson's design was outlined on September 2, 1992, on a placemat in a New Jersey diner with Rob Pike. In the following days, Pike and Thompson implemented it and updated Plan 9 to use it throughout, and then communicated their success back to X/Open, which accepted it as the specification for FSS-UTF.[53]

FSS-UTF (1992) / UTF-8 (1993)[2]
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5	Byte 6
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+07FF	110xxxxx	10xxxxxx
3	U+0800	U+FFFF	1110xxxx	10xxxxxx	10xxxxxx
4	U+10000	U+1FFFFF	11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
5	U+200000	U+3FFFFFF	111110xx	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx
6	U+4000000	U+7FFFFFFF	1111110x	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx
UTF-8 was first officially presented at the USENIX conference in San Diego, from January 25 to 29, 1993. The Internet Engineering Task Force adopted UTF-8 in its Policy on Character Sets and Languages in RFC 2277 (BCP 18) for future Internet standards work, replacing Single Byte Character Sets such as Latin-1 in older RFCs.[55]

In November 2003, UTF-8 was restricted by RFC 3629 to match the constraints of the UTF-16 character encoding: explicitly prohibiting code points corresponding to the high and low surrogate characters removed more than 3% of the three-byte sequences, and ending at U+10FFFF removed more than 48% of the four-byte sequences and all five- and six-byte sequences.

Standards[edit]
There are several current definitions of UTF-8 in various standards documents:

RFC 3629 / STD 63 (2003), which establishes UTF-8 as a standard Internet protocol element
RFC 5198 defines UTF-8 NFC for Network Interchange (2008)
ISO/IEC 10646:2014 ¬ß9.1 (2014)[56]
The Unicode Standard, Version 11.0 (2018)[57]
They supersede the definitions given in the following obsolete works:

The Unicode Standard, Version 2.0, Appendix A (1996)
ISO/IEC 10646-1:1993 Amendment 2 / Annex R (1996)
RFC 2044 (1996)
RFC 2279 (1998)
The Unicode Standard, Version 3.0, ¬ß2.3 (2000) plus Corrigendum #1 : UTF-8 Shortest Form (2000)
Unicode Standard Annex #27: Unicode 3.1 (2001)[58]
The Unicode Standard, Version 5.0 (2006)[59]
The Unicode Standard, Version 6.0 (2010)[60]
They are all the same in their general mechanics, with the main differences being on issues such as allowed range of code point values and safe handling of invalid input.

Comparison with other encodings[edit]
See also: Comparison of Unicode encodings
Some of the important features of this encoding are as follows:

Backward compatibility: Backward compatibility with ASCII and the enormous amount of software designed to process ASCII-encoded text was the main driving force behind the design of UTF-8. In UTF-8, single bytes with values in the range of 0 to 127 map directly to Unicode code points in the ASCII range. Single bytes in this range represent characters, as they do in ASCII. Moreover, 7-bit bytes (bytes where the most significant bit is 0) never appear in a multi-byte sequence, and no valid multi-byte sequence decodes to an ASCII code-point. A sequence of 7-bit bytes is both valid ASCII and valid UTF-8, and under either interpretation represents the same sequence of characters. Therefore, the 7-bit bytes in a UTF-8 stream represent all and only the ASCII characters in the stream. Thus, many text processors, parsers, protocols, file formats, text display programs, etc., which use ASCII characters for formatting and control purposes, will continue to work as intended by treating the UTF-8 byte stream as a sequence of single-byte characters, without decoding the multi-byte sequences. ASCII characters on which the processing turns, such as punctuation, whitespace, and control characters will never be encoded as multi-byte sequences. It is therefore safe for such processors to simply ignore or pass-through the multi-byte sequences, without decoding them. For example, ASCII whitespace may be used to tokenize a UTF-8 stream into words; ASCII line-feeds may be used to split a UTF-8 stream into lines; and ASCII NUL characters can be used to split UTF-8-encoded data into null-terminated strings. Similarly, many format strings used by library functions like "printf" will correctly handle UTF-8-encoded input arguments.
Fallback and auto-detection: Only a small subset of possible byte strings are a valid UTF-8 string: the bytes C0, C1, and F5 through FF cannot appear, and bytes with the high bit set must be in pairs, and other requirements. It is extremely unlikely that a readable text in any extended ASCII is valid UTF-8. Part of the popularity of UTF-8 is due to it providing a form of backward compatibility for these as well. A UTF-8 processor which erroneously receives extended ASCII as input can thus "auto-detect" this with very high reliability. Fallback errors will be false negatives, and these will be rare. Moreover, in many applications, such as text display, the consequence of incorrect fallback is usually slight.[original research?] A UTF-8 stream may simply contain errors, resulting in the auto-detection scheme producing false positives; but auto-detection is successful in the majority of cases, especially with longer texts, and is widely used. It also works to "fall back" or replace 8-bit bytes using the appropriate code-point for a legacy encoding only when errors in the UTF-8 are detected, allowing recovery even if UTF-8 and legacy encoding is concatenated in the same file.
Prefix code: The first byte indicates the number of bytes in the sequence. Reading from a stream can instantaneously decode each individual fully received sequence, without first having to wait for either the first byte of a next sequence or an end-of-stream indication. The length of multi-byte sequences is easily determined by humans as it is simply the number of high-order 1s in the leading byte. An incorrect character will not be decoded if a stream ends mid-sequence.
Self-synchronization: The leading bytes and the continuation bytes do not share values (continuation bytes start with the bits 10 while single bytes start with 0 and longer lead bytes start with 11). This means a search will not accidentally find the sequence for one character starting in the middle of another character. It also means the start of a character can be found from a random position by backing up at most 3 bytes to find the leading byte. An incorrect character will not be decoded if a stream starts mid-sequence, and a shorter sequence will never appear inside a longer one.
Sorting order: The chosen values of the leading bytes means that a list of UTF-8 strings can be sorted in code point order by sorting the corresponding byte sequences.
Single-byte[edit]
UTF-8 can encode any Unicode character, avoiding the need to figure out and set a "code page" or otherwise indicate what character set is in use, and allowing output in multiple scripts at the same time. For many scripts there have been more than one single-byte encoding in usage, so even knowing the script was insufficient information to display it correctly.
The bytes 0xFE and 0xFF do not appear, so a valid UTF-8 stream never matches the UTF-16 byte order mark and thus cannot be confused with it. The absence of 0xFF (0377) also eliminates the need to escape this byte in Telnet (and FTP control connection).
UTF-8 encoded text is larger than specialized single-byte encodings except for plain ASCII characters. In the case of scripts which used 8-bit character sets with non-Latin characters encoded in the upper half (such as most Cyrillic and Greek alphabet code pages), characters in UTF-8 will be double the size. For some scripts, such as Thai and Devanagari (which is used by various South Asian languages), characters will triple in size. There are even examples where a single byte turns into a composite character in Unicode and is thus six times larger in UTF-8. This has caused objections in India and other countries.
It is possible in UTF-8 (or any other variable-length encoding) to split or truncate a string in the middle of a character. If the two pieces are not re-appended later before interpretation as characters, this can introduce an invalid sequence at both the end of the previous section and the start of the next, and some decoders will not preserve these bytes and result in data loss. Because UTF-8 is self-synchronizing this will however never introduce a different valid character, and it is also fairly easy to move the truncation point backward to the start of a character.
If the code points are all the same size, measurements of a fixed number of them is easy. Due to ASCII-era documentation where "character" is used as a synonym for "byte" this is often considered important. However, by measuring string positions using bytes instead of "characters" most algorithms can be easily and efficiently adapted for UTF-8. Searching for a string within a long string can for example be done byte by byte; the self-synchronization property prevents false positives.
Other multi-byte[edit]
UTF-8 can encode any Unicode character. Files in different scripts can be displayed correctly without having to choose the correct code page or font. For instance, Chinese and Arabic can be written in the same file without specialised markup or manual settings that specify an encoding.
UTF-8 is self-synchronizing: character boundaries are easily identified by scanning for well-defined bit patterns in either direction. If bytes are lost due to error or corruption, one can always locate the next valid character and resume processing. If there is a need to shorten a string to fit a specified field, the previous valid character can easily be found. Many multi-byte encodings such as Shift JIS are much harder to resynchronize. This also means that byte-oriented string-searching algorithms can be used with UTF-8 (as a character is the same as a "word" made up of that many bytes), optimized versions of byte searches can be much faster due to hardware support and lookup tables that have only 256 entries. Self-synchronization does however require that bits be reserved for these markers in every byte, increasing the size.
Efficient to encode using simple bitwise operations. UTF-8 does not require slower mathematical operations such as multiplication or division (unlike Shift JIS, GB 2312 and other encodings).
UTF-8 will take more space than a multi-byte encoding designed for a specific script. East Asian legacy encodings generally used two bytes per character yet take three bytes per character in UTF-8.
UTF-16[edit]
Byte encodings and UTF-8 are represented by byte arrays in programs, and often nothing needs to be done to a function when converting source code from a byte encoding to UTF-8. UTF-16 is represented by 16-bit word arrays, and converting to UTF-16 while maintaining compatibility with existing ASCII-based programs (such as was done with Windows) requires every API and data structure that takes a string to be duplicated, one version accepting byte strings and another version accepting UTF-16. If backward compatibility is not needed, all string handling still must be modified.
Text encoded in UTF-8 will be smaller than the same text encoded in UTF-16 if there are more code points below U+0080 than in the range U+0800..U+FFFF. This is true for all modern European languages.
Text in (for example) Chinese, Japanese or Devanagari will take more space in UTF-8 if there are more of these characters than there are ASCII characters. This is likely when data mainly consist of pure prose, but is lessened by the degree to which the context uses ASCII whitespace, digits, and punctuation.[nb 3]
Most of the rich text formats (including HTML) contain a large proportion of ASCII characters for the sake of formatting, thus the size usually will be reduced significantly compared with UTF-16, even when the language mostly uses 3-byte long characters in UTF-8.[nb 4]
Most communication (e.g. HTML and IP) and storage (e.g. for Unix) was designed for a stream of bytes. A UTF-16 string must use a pair of bytes for each code unit:
The order of those two bytes becomes an issue and must be specified in the UTF-16 protocol, such as with a byte order mark.
If an odd number of bytes is missing from UTF-16, the whole rest of the string will be meaningless text. Any bytes missing from UTF-8 will still allow the text to be recovered accurately starting with the next character after the missing bytes.
Derivatives[edit]
The following implementations show slight differences from the UTF-8 specification. They are incompatible with the UTF-8 specification and may be rejected by conforming UTF-8 applications.

CESU-8[edit]
Main article: CESU-8
Unicode Technical Report #26[61] assigns the name CESU-8 to a nonstandard variant of UTF-8, in which Unicode characters in supplementary planes are encoded using six bytes, rather than the four bytes required by UTF-8. CESU-8 encoding treats each half of a four-byte UTF-16 surrogate pair as a two-byte UCS-2 character, yielding two three-byte UTF-8 characters, which together represent the original supplementary character. Unicode characters within the Basic Multilingual Plane appear as they would normally in UTF-8. The Report was written to acknowledge and formalize the existence of data encoded as CESU-8, despite the Unicode Consortium discouraging its use, and notes that a possible intentional reason for CESU-8 encoding is preservation of UTF-16 binary collation.

CESU-8 encoding can result from converting UTF-16 data with supplementary characters to UTF-8, using conversion methods that assume UCS-2 data, meaning they are unaware of four-byte UTF-16 supplementary characters. It is primarily an issue on operating systems which extensively use UTF-16 internally, such as Microsoft Windows.[citation needed]

In Oracle Database, the UTF8 character set uses CESU-8 encoding, and is deprecated. The AL32UTF8 character set uses standards-compliant UTF-8 encoding, and is preferred.[62][63]

CESU-8 is prohibited for use in HTML5 documents.[64][65][66]

MySQL utf8mb3[edit]
In MySQL, the utf8mb3 character set is defined to be UTF-8 encoded data with a maximum of three bytes per character, meaning only Unicode characters in the Basic Multilingual Plane are supported. Unicode characters in supplementary planes are explicitly not supported. utf8mb3 is deprecated in favor of the utf8mb4 character set, which uses standards-compliant UTF-8 encoding. utf8 is an alias for utf8mb3, but is intended to become an alias to utf8mb4 in a future release of MySQL.[67] It is possible, though unsupported, to store CESU-8 encoded data in utf8mb3, by handling UTF-16 data with supplementary characters as though it is UCS-2.

Modified UTF-8[edit]
Modified UTF-8 (MUTF-8) originated in the Java programming language. In Modified UTF-8, the null character (U+0000) uses the two-byte overlong encoding 11000000 10000000 (hexadecimal C0 80), instead of 00000000 (hexadecimal 00).[68] Modified UTF-8 strings never contain any actual null bytes but can contain all Unicode code points including U+0000,[69] which allows such strings (with a null byte appended) to be processed by traditional null-terminated string functions. All known Modified UTF-8 implementations also treat the surrogate pairs as in CESU-8.

In normal usage, the language supports standard UTF-8 when reading and writing strings through InputStreamReader and OutputStreamWriter (if it is the platform's default character set or as requested by the program). However it uses Modified UTF-8 for object serialization[70] among other applications of DataInput and DataOutput, for the Java Native Interface,[71] and for embedding constant strings in class files.[72]

The dex format defined by Dalvik also uses the same modified UTF-8 to represent string values.[73] Tcl also uses the same modified UTF-8[74] as Java for internal representation of Unicode data, but uses strict CESU-8 for external data.

WTF-8[edit]

This section contains a list of miscellaneous information. Please relocate any relevant information into other sections or articles. (August 2020)
In WTF-8 (Wobbly Transformation Format, 8-bit) unpaired surrogate halves (U+D800 through U+DFFF) are allowed.[75] This is necessary to store possibly-invalid UTF-16, such as Windows filenames. Many systems that deal with UTF-8 work this way without considering it a different encoding, as it is simpler.[76]

(The term "WTF-8" has also been used humorously to refer to erroneously doubly-encoded UTF-8[77][78] sometimes with the implication that CP1252 bytes are the only ones encoded)[79]

PEP 383[edit]
Version 3 of the Python programming language treats each byte of an invalid UTF-8 bytestream as an error; this gives 128 different possible errors. Extensions have been created to allow any byte sequence that is assumed to be UTF-8 to be lossless transformed to UTF-16 or UTF-32, by translating the 128 possible error bytes to reserved code points, and transforming those code points back to error bytes to output UTF-8. The most common approach is to translate the codes to U+DC80...U+DCFF which are low (trailing) surrogate values and thus "invalid" UTF-16, as used by Python's PEP 383 (or "surrogateescape") approach.[80] Another encoding called MirBSD OPTU-8/16 converts them to U+EF80...U+EFFF in a Private Use Area.[81] In either approach, the byte value is encoded in the low eight bits of the output code point.

These encodings are very useful because they avoid the need to deal with "invalid" byte strings until much later, if at all, and allow "text" and "data" byte arrays to be the same object. If a program wants to use UTF-16 internally these are required to preserve and use filenames that can use invalid UTF-8;[82] as the Windows filesystem API uses UTF-16, the need to support invalid UTF-8 is less there.[80]

For the encoding to be reversible, the standard UTF-8 encodings of the code points used for erroneous bytes must be considered invalid. This makes the encoding incompatible with WTF-8 or CESU-8 (though only for 128 code points). When re-encoding it is necessary to be careful of sequences of error code points which convert back to valid UTF-8, which may be used by malicious software to get unexpected characters in the output, though this cannot produce ASCII characters so it is considered comparatively safe, since malicious sequences (such as cross-site scripting) usually rely on ASCII characters.[82]

See also[edit]
Alt code
Character encodings in HTML
Comparison of e-mail clients#Features
Comparison of Unicode encodings
Iconv
Specials (Unicode block)
Unicode and email
Unicode and HTML
Percent-encoding#Current standard
UTF-EBCDIC
Notes[edit]
^ 17 planes times 216 code points per plane, minus 211 technically-invalid surrogates.
^ You might expect larger code points than U+10FFFF to be expressible, but in RFC3629 ¬ß3 UTF-8 is limited to match the limits of UTF-16. (As ¬ß12 notes, this is changed from RFC 2279.)
^ The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi), when the pure text was pasted to Notepad, generated 19 KB when saved as UTF-16 and 22 KB when saved as UTF-8.
^ The 2010-10-27 version of UTF-8 (in Japanese) generated 169 KB when converted with Notepad to UTF-16, and only 101 KB when converted back to UTF-8. The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi) required 119 KB in UTF-16 and 76 KB in UTF-8.
References[edit]
^ "Chapter 2. General Structure". The Unicode Standard (6.0 ed.). Mountain View, California, US: The Unicode Consortium. ISBN 978-1-936213-01-6.
^ Jump up to: a b Pike, Rob (30 April 2003). "UTF-8 history".
^ Pike, Rob; Thompson, Ken (1993). "Hello World or ŒöŒ±ŒªŒ∑ŒºŒ≠œÅŒ± Œ∫œåœÉŒºŒµ or „Åì„Çì„Å´„Å°„ÅØ ‰∏ñÁïå" (PDF). Proceedings of the Winter 1993 USENIX Conference.
^ Jump up to: a b c "Usage Survey of Character Encodings broken down by Ranking". w3techs.com. Retrieved 2020-08-24.
^ Jump up to: a b Davis, Mark (2012-02-03). "Unicode over 60 percent of the web". Official Google Blog. Archived from the original on 2018-08-09. Retrieved 2020-07-24.
^ "Encoding Standard". encoding.spec.whatwg.org. Retrieved 2020-04-15.
^ "Using International Characters in Internet Mail". Internet Mail Consortium. 1998-08-01. Archived from the original on 2007-10-26. Retrieved 2007-11-08.
^ "Encoding Standard". encoding.spec.whatwg.org. Retrieved 2018-11-15.
^ Davis, Mark (2008-05-05). "Moving to Unicode 5.1". Retrieved 2013-03-01.
^ "Specifying the document's character encoding". HTML5.2. World Wide Web Consortium. 14 December 2017. Retrieved 2018-06-03.
^ "The JavaScript Object Notation (JSON) Data Interchange Format". IETF. December 2017. Retrieved 16 February 2018.
^ "Usage Statistics and Market Share of US-ASCII for Websites, August 2020". w3techs.com. Retrieved 2020-08-28.
^ "Distribution of Character Encodings among websites that use Iranian languages". w3techs.com. Retrieved 2018-12-03.
^ "Distribution of Character Encodings among websites that use Sign Languages". w3techs.com. Retrieved 2018-12-03.
^ "Distribution of Character Encodings among websites that use .cn". w3techs.com. Retrieved 2020-09-01.
^ "Distribution of Character Encodings among websites that use Chinese". w3techs.com. Retrieved 2020-07-03.
^ "Distribution of Character Encodings among websites that use .ru". w3techs.com. Retrieved 2020-09-01.
^ "Distribution of Character Encodings among websites that use Greek". w3techs.com. Retrieved 2020-09-07.
^ "Distribution of Character Encodings among websites that use Hebrew". w3techs.com. Retrieved 2020-09-07.
^ "Historical trends in the usage of character encodings". Retrieved 2020-07-24.
^ "UTF-8 Usage Statistics". BuiltWith. Retrieved 2011-03-28.
^ "Usage Report of UTF-8 broken down by Content Languages". w3techs.com. Retrieved 2020-09-07.
^ "UTF-8 - ICU User Guide". userguide.icu-project.org. Retrieved 2018-04-03.
^ "#13311 (change illegal-UTF-8 handling to Unicode "best practice")". bugs.icu-project.org. Retrieved 2018-04-03.
^ "Use the Windows UTF-8 code page". UWP applications. docs.microsoft.com. Retrieved 2020-06-06.
^ Allen, Julie D.; Anderson, Deborah; Becker, Joe; Cook, Richard, eds. (2012). "The Unicode Standard, Version 6.1". Mountain View, California: Unicode Consortium.
^ https://ci.apache.org/projects/flink/flink-docs-release-1.9/api/java/org/apache/flink/table/dataformat/BinaryString.html#compareTo-org.apache.flink.table.dataformat.BinaryString-
^ "Chapter 3", The Unicode Standard (PDF), p. 54
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ "Chapter 3", The Unicode Standard (PDF), p. 54
^ Yergeau, F. (November 2003). UTF-8, a transformation format of ISO 10646. IETF. doi:10.17487/RFC3629. STD 63. RFC 3629. Retrieved August 20, 2020.
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ Yergeau, F. (November 2003). UTF-8, a transformation format of ISO 10646. IETF. doi:10.17487/RFC3629. STD 63. RFC 3629. Retrieved August 20, 2020.
^ Marin, Marvin (2000-10-17). "Web Server Folder Traversal MS00-078".
^ "Summary for CVE-2008-2938". National Vulnerability Database.
^ Jump up to: a b Yergeau, F. (2003). UTF-8, a transformation format of ISO 10646. Internet Engineering Task Force. doi:10.17487/RFC3629. RFC 3629. Retrieved 2015-02-03.
^ Java's DataInput IO Interface
^ "Non-decodable Bytes in System Character Interfaces". python.org. 2009-04-22. Retrieved 2014-08-13.
^ "Unicode 6.0.0".
^ 128 1-byte, (16+5)√ó64 2-byte, and 5√ó64√ó64 3-byte. There may be somewhat fewer if more precise tests are done for each continuation byte.
^ "Chapter 2", The Unicode Standard (PDF), p. 30
^ Jump up to: a b "Character Sets". Internet Assigned Numbers Authority. 2013-01-23. Retrieved 2013-02-08.
^ D√ºrst, Martin. "Setting the HTTP charset parameter". W3C. Retrieved 2013-02-08.
^ "Encoding Standard ¬ß 4.2. Names and labels". WHATWG. Retrieved 2018-04-29.
^ "BOM". suikawiki (in Japanese). Retrieved 2013-04-26.
^ Davis, Mark. "Forms of Unicode". IBM. Archived from the original on 2005-05-06. Retrieved 2013-09-18.
^ Liviu (2014-02-07). "UTF-8 codepage 65001 in Windows 7 - part I". Retrieved 2018-01-30.
^ "Script How to set default encoding to UTF-8 for notepad by PowerShell". gallery.technet.microsoft.com. Retrieved 2018-01-30.
^ "HP PCL Symbol Sets | Printer Control Language (PCL & PXL) Support Blog". 2015-02-19. Archived from the original on 2015-02-19. Retrieved 2018-01-30.
^ "Appendix F. FSS-UTF / File System Safe UCS Transformation format" (PDF). The Unicode Standard 1.1. Archived (PDF) from the original on 2016-06-07. Retrieved 2016-06-07.
^ Whistler, Kenneth (2001-06-12). "FSS-UTF, UTF-2, UTF-8, and UTF-16". Archived from the original on 2016-06-07. Retrieved 2006-06-07.
^ Jump up to: a b Pike, Rob (2003-04-30). "UTF-8 history". Retrieved 2012-09-07.
^ Pike, Rob (2012-09-06). "UTF-8 turned 20 years old yesterday". Retrieved 2012-09-07.
^ Alvestrand, Harald (January 1998). IETF Policy on Character Sets and Languages. doi:10.17487/RFC2277. BCP 18.
^ ISO/IEC 10646:2014 ¬ß9.1, 2014.
^ The Unicode Standard, Version 11.0 ¬ß3.9 D92, ¬ß3.10 D95, 2018.
^ Unicode Standard Annex #27: Unicode 3.1, 2001.
^ The Unicode Standard, Version 5.0 ¬ß3.9‚Äì¬ß3.10 ch. 3, 2006.
^ The Unicode Standard, Version 6.0 ¬ß3.9 D92, ¬ß3.10 D95, 2010.
^ McGowan, Rick (2011-12-19). "Compatibility Encoding Scheme for UTF-16: 8-Bit (CESU-8)". Unicode Consortium. Unicode Technical Report #26.
^ "Character Set Support". Oracle Database 19c Documentation, SQL Language Reference. Oracle Corporation.
^ "Supporting Multilingual Databases with Unicode ¬ß Support for the Unicode Standard in Oracle Database". Database Globalization Support Guide. Oracle Corporation.
^ "8.2.2.3. Character encodings". HTML 5.1 Standard. W3C.
^ "8.2.2.3. Character encodings". HTML 5 Standard. W3C.
^ "12.2.3.3 Character encodings". HTML Living Standard. WHATWG.
^ "The utf8mb3 Character Set (3-Byte UTF-8 Unicode Encoding)". MySQL 8.0 Reference Manual. Oracle Corporation.
^ "Java SE documentation for Interface java.io.DataInput, subsection on Modified UTF-8". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "Java Object Serialization Specification, chapter 6: Object Serialization Stream Protocol, section 2: Stream Elements". Oracle Corporation. 2010. Retrieved 2015-10-16.
^ "Java Native Interface Specification, chapter 3: JNI Types and Data Structures, section: Modified UTF-8 Strings". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "ART and Dalvik". Android Open Source Project. Archived from the original on 2013-04-26. Retrieved 2013-04-09.
^ "Tcler's Wiki: UTF-8 bit by bit (Revision 6)". 2009-04-25. Retrieved 2009-05-22.
^ Sapin, Simon (2016-03-11) [2014-09-25]. "The WTF-8 encoding". Archived from the original on 2016-05-24. Retrieved 2016-05-24.
^ Sapin, Simon (2015-03-25) [2014-09-25]. "The WTF-8 encoding ¬ß Motivation". Archived from the original on 2016-05-24. Retrieved 2020-08-26.
^ "WTF-8.com". 2006-05-18. Retrieved 2016-06-21.
^ Speer, Robyn (2015-05-21). "ftfy (fixes text for you) 4.0: changing less and fixing more". Archived from the original on 2015-05-30. Retrieved 2016-06-21.
^ "WTF-8, a transformation format of code page 1252". Archived from the original on 2016-10-13. Retrieved 2016-10-12.
^ Jump up to: a b von L√∂wis, Martin (2009-04-22). "Non-decodable Bytes in System Character Interfaces". Python Software Foundation. PEP 383.
^ "RTFM optu8to16(3), optu8to16vis(3)". www.mirbsd.org.
^ Jump up to: a b Davis, Mark; Suignard, Michel (2014). "3.7 Enabling Lossless Conversion". Unicode Security Considerations. Unicode Technical Report #36.
External links[edit]
Original UTF-8 paper (or pdf) for Plan 9 from Bell Labs
UTF-8 test pages:
Andreas Prilop
Jost Gippert
World Wide Web Consortium
Unix/Linux: UTF-8/Unicode FAQ, Linux Unicode HOWTO, 8.xml UTF-8 and Gentoo
Characters, Symbols and the Unicode Miracle on YouTube
showvte
Unicode
showvte
Character encodings
showvte
Rob Pike
showvte
Ken Thompson
Categories: Character encodingComputer-related introductions in 1993EncodingsUnicode Transformation Formats
Navigation menu
Not logged inTalkContributionsCreate accountLog in
ArticleTalk
ReadEditView history
Search

Main page
Contents
Current events
Random article
About Wikipedia
Contact us
Donate
Contribute
Help
Learn to edit
Community portal
Recent changes
Upload file
Tools
What links here
Related changes
Special pages
Permanent link
Page information
Cite this page
Wikidata item
Print/export
Download as PDF
Printable version

Languages
ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
Espa√±ol
Bahasa Indonesia
Italiano
Bahasa Melayu
Portugu√™s
–†—É—Å—Å–∫–∏–π
ÿßÿ±ÿØŸà
‰∏≠Êñá
32 more
Edit links
This page was last edited on 20 October 2020, at 18:05 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia¬Æ is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
Privacy policyAbout WikipediaDisclaimersContact WikipediaMobile viewDevelopersStatisticsCookie statement
Wikimedia FoundationPowered by MediaWiki

UTF-8
From Wikipedia, the free encyclopedia
Jump to navigationJump to search
UTF-8
Standard	Unicode Standard
Classification	Unicode Transformation Format, extended ASCII, variable-width encoding
Extends	US-ASCII
Transforms / Encodes	ISO 10646 (Unicode)
Preceded by	UTF-1
vte
UTF-8 is a variable-width character encoding used for electronic communication. Defined by the Unicode Standard, the name is derived from Unicode (or Universal Coded Character Set) Transformation Format ‚Äì 8-bit.[1]

UTF-8 is capable of encoding all 1,112,064[nb 1] valid character code points in Unicode using one to four one-byte (8-bit) code units. Code points with lower numerical values, which tend to occur more frequently, are encoded using fewer bytes. It was designed for backward compatibility with ASCII: the first 128 characters of Unicode, which correspond one-to-one with ASCII, are encoded using a single byte with the same binary value as ASCII, so that valid ASCII text is valid UTF-8-encoded Unicode as well. Since ASCII bytes do not occur when encoding non-ASCII code points into UTF-8, UTF-8 is safe to use within most programming and document languages that interpret certain ASCII characters in a special way, such as "/" (slash) in filenames, "\" (backslash) in escape sequences, and "%" in printf.

UTF-8 was designed as a superior alternative to UTF-1, a proposed variable-width encoding with partial ASCII compatibility which lacked some features including self-synchronization and fully ASCII-compatible handling of characters such as slashes. Ken Thompson and Rob Pike produced the first implementation for the Plan 9 operating system in September 1992.[2][3] This led to its adoption by X/Open as its specification for FSS-UTF, which would first be officially presented at USENIX in January 1993 and subsequently adopted by the Internet Engineering Task Force (IETF) in RFC 2277 (BCP 18) for future Internet standards work, replacing Single Byte Character Sets such as Latin-1 in older RFCs.

UTF-8 is by far the most common encoding for the World Wide Web, accounting for over 95% of all web pages, and up to 100% for some languages, as of 2020.[4]


Contents
1	Adoption
2	Encoding
2.1	Examples
2.2	Codepage layout
2.3	Overlong encodings
2.4	Invalid sequences and error handling
2.5	Byte order mark
3	Naming
4	History
5	Standards
6	Comparison with other encodings
6.1	Single-byte
6.2	Other multi-byte
6.3	UTF-16
7	Derivatives
7.1	CESU-8
7.2	MySQL utf8mb3
7.3	Modified UTF-8
7.4	WTF-8
7.5	PEP 383
8	See also
9	Notes
10	References
11	External links
Adoption[edit]

Use of the main encodings on the web from 2001 to 2012 as recorded by Google,[5] with UTF-8 overtaking all others in 2008 and over 60% of the web in 2012. The ASCII-only figure includes all web pages that only contain ASCII characters, regardless of the declared header.
UTF-8 is the recommendation from the WHATWG for HTML and DOM specifications,[6] and the Internet Mail Consortium recommends that all e-mail programs be able to display and create mail using UTF-8.[7][8]

Google reported that in 2008, UTF-8 (labelled "Unicode") became the most common encoding for HTML files.[9]

Since 2009, UTF-8 has been the most common encoding for the World Wide Web.[4] The World Wide Web Consortium recommends UTF-8 as the default encoding in XML and HTML (and not just using UTF-8, also stating it in metadata), "even when all characters are in the ASCII range .. Using non-UTF-8 encodings can have unexpected results".[10] Many other standards only support UTF-8, e.g. open JSON exchange requires it.[11]

As of October 2020, UTF-8 accounts on average for 95.5% of all web pages and 97% of the top 1,000 highest ranked web pages.[4] (This takes into account that ASCII is valid UTF-8.[12]) Several languages have 100.0% use of UTF-8 on the web, such as Punjabi, Tagalog, Lao, Marathi, Kannada, Kurdish, Pashto, Javanese, Greenlandic (Kalaallisut) and Iranian languages[13] and sign languages.[14]

In locales where UTF-8 is used alongside another encoding, the latter is typically more efficient for the associated language. The Chinese standard GB 2312 and with its extension GBK (which are both interpreted by web browsers as GB 18030, having support for the same letters as UTF-8) have a combined 14.5% share in China[15][16] and a 0.5% share world-wide. Big5 is another popular Chinese encoding with 0.1% share world-wide. The single-byte Windows-1251 is twice as efficient for the Cyrillic script and is used for 10.6% of Russian web sites.[17] E.g. Greek and Hebrew encodings are also twice as efficient, but still those languages have over 95% use of UTF-8.[18][19] EUC-KR is more efficient for Korean text and is used for 17.3% of South Korean websites. Shift JIS and EUC-JP have a 10.5% share on Japanese websites (the more popular Shift JIS has 0.2% global share).[20][21][5] With the exception of GB 18030 and UTF-16, these encodings were designed for specific languages, and do not support all Unicode characters. As of September 2020, the Breton language has the lowest UTF-8 use on the Web of any tracked language, with 79.4% use.[22]

International Components for Unicode (ICU) has historically used UTF-16, and still does only for Java; while for C/C++ UTF-8 is now supported as the "Default Charset",[23] including the correct handling of "illegal UTF-8".[24]

For local text files UTF-8 usage is lower, and many legacy single-byte encodings remain in use. This is primarily due to editors that will not display or write UTF-8 unless the first character in a file is a byte order mark, making it impossible for other software to use UTF-8 without being rewritten to ignore the byte order mark on input and add it on output. UTF-16 files are also fairly common on Windows, but not elsewhere.[original research?] Internally in software usage is even lower, with UCS-2 and UTF-32 in use, particularly in Windows but also Python, JavaScript, Qt, and many other software libraries. This is due to a belief that direct indexing of code points is more important than 8-bit compatibility.[citation needed] UTF-16 is also used due to being compatible with UCS-2, even though it does not have direct indexing. Microsoft now recommends UTF-8 for Windows programs,[25] while previously they emphasized "Unicode" (meaning UTF-16) Win32 API, this may mean internal use of UTF-8 will increase in the future.[original research?]

Encoding[edit]
Since the restriction of the Unicode code-space to 21-bit values in 2003, UTF-8 is defined to encode code points in one to four bytes, depending on the number of significant bits in the numerical value of the code point. The following table shows the structure of the encoding. The x characters are replaced by the bits of the code point.

Layout of UTF-8 byte sequences
Number of bytes	First code point	Last code point	Byte 1	Byte 2	Byte 3	Byte 4
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+07FF	110xxxxx	10xxxxxx
3	U+0800	U+FFFF	1110xxxx	10xxxxxx	10xxxxxx
4	U+10000	[nb 2]U+10FFFF	11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
The first 128 characters (US-ASCII) need one byte. The next 1,920 characters need two bytes to encode, which covers the remainder of almost all Latin-script alphabets, and also Greek, Cyrillic, Coptic, Armenian, Hebrew, Arabic, Syriac, Thaana and N'Ko alphabets, as well as Combining Diacritical Marks. Three bytes are needed for characters in the rest of the Basic Multilingual Plane, which contains virtually all characters in common use,[26] including most Chinese, Japanese and Korean characters. Four bytes are needed for characters in the other planes of Unicode, which include less common CJK characters, various historic scripts, mathematical symbols, and emoji (pictographic symbols).

Examples[edit]
Consider the encoding of the Euro sign, ‚Ç¨:

The Unicode code point for "‚Ç¨" is U+20AC.
As this code point lies between U+0800 and U+FFFF, this will take three bytes to encode.
Hexadecimal 20AC is binary 0010 0000 1010 1100. The two leading zeros are added because a three-byte encoding needs exactly sixteen bits from the code point.
Because the encoding will be three bytes long, its leading byte starts with three 1s, then a 0 (1110...)
The four most significant bits of the code point are stored in the remaining low order four bits of this byte (1110 0010), leaving 12 bits of the code point yet to be encoded (...0000 1010 1100).
All continuation bytes contain exactly six bits from the code point. So the next six bits of the code point are stored in the low order six bits of the next byte, and 10 is stored in the high order two bits to mark it as a continuation byte (so 1000 0010).
Finally the last six bits of the code point are stored in the low order six bits of the final byte, and again 10 is stored in the high order two bits (1010 1100).
The three bytes 1110 0010 1000 0010 1010 1100 can be more concisely written in hexadecimal, as E2 82 AC.

The following table summarises this conversion, as well as others with different lengths in UTF-8. The colors indicate how bits from the code point are distributed among the UTF-8 bytes. Additional bits added by the UTF-8 encoding process are shown in black.

Representation of UTF-8 characters
Character	Code point	UTF-8
Octal	Binary	Binary	Octal	Hexadecimal
$	U+0024	044	010 0100	00100100	044	24
¬¢	U+00A2	0242	000 1010 0010	11000010 10100010	302 242	C2 A2
‡§π	U+0939	004471	0000 1001 0011 1001	11100000 10100100 10111001	340 244 271	E0 A4 B9
‚Ç¨	U+20AC	020254	0010 0000 1010 1100	11100010 10000010 10101100	342 202 254	E2 82 AC
Ìïú	U+D55C	152534	1101 0101 0101 1100	11101101 10010101 10011100	355 225 234	ED 95 9C
êçà	U+10348	0201510	0 0001 0000 0011 0100 1000	11110000 10010000 10001101 10001000	360 220 215 210	F0 90 8D 88
UTF-8's use of six bits per byte to represent the actual characters being encoded means that octal notation (which uses 3-bit groups) can aid in the comparison of UTF-8 sequences with one another.[27]

Codepage layout[edit]
The following table summarizes usage of UTF-8 code units (individual bytes or octets) in a code page format. The upper half (0_ to 7_) is for bytes used only in single-byte codes, so it looks like a normal code page; the lower half is for continuation bytes (8_ to B_) and leading bytes (C_ to F_), and is explained further in the legend below.

UTF-8
_0	_1	_2	_3	_4	_5	_6	_7	_8	_9	_A	_B	_C	_D	_E	_F
0_	NUL
0000	SOH
0001	STX
0002	ETX
0003	EOT
0004	ENQ
0005	ACK
0006	BEL
0007	BS
0008	HT
0009	LF
000A	VT
000B	FF
000C	CR
000D	SO
000E	SI
000F
1_	DLE
0010	DC1
0011	DC2
0012	DC3
0013	DC4
0014	NAK
0015	SYN
0016	ETB
0017	CAN
0018	EM
0019	SUB
001A	ESC
001B	FS
001C	GS
001D	RS
001E	US
001F
2_	SP
0020	!
0021	"
0022	#
0023	$
0024	%
0025	&
0026	'
0027	(
0028	)
0029	*
002A	+
002B	,
002C	-
002D	.
002E	/
002F
3_	0
0030	1
0031	2
0032	3
0033	4
0034	5
0035	6
0036	7
0037	8
0038	9
0039	:
003A	;
003B	<
003C	=
003D	>
003E	?
003F
4_	@
0040	A
0041	B
0042	C
0043	D
0044	E
0045	F
0046	G
0047	H
0048	I
0049	J
004A	K
004B	L
004C	M
004D	N
004E	O
004F
5_	P
0050	Q
0051	R
0052	S
0053	T
0054	U
0055	V
0056	W
0057	X
0058	Y
0059	Z
005A	[
005B	\
005C	]
005D	^
005E	_
005F
6_	`
0060	a
0061	b
0062	c
0063	d
0064	e
0065	f
0066	g
0067	h
0068	i
0069	j
006A	k
006B	l
006C	m
006D	n
006E	o
006F
7_	p
0070	q
0071	r
0072	s
0073	t
0074	u
0075	v
0076	w
0077	x
0078	y
0079	z
007A	{
007B	|
007C	}
007D	~
007E	DEL
007F
8_	‚Ä¢
+00	‚Ä¢
+01	‚Ä¢
+02	‚Ä¢
+03	‚Ä¢
+04	‚Ä¢
+05	‚Ä¢
+06	‚Ä¢
+07	‚Ä¢
+08	‚Ä¢
+09	‚Ä¢
+0A	‚Ä¢
+0B	‚Ä¢
+0C	‚Ä¢
+0D	‚Ä¢
+0E	‚Ä¢
+0F
9_	‚Ä¢
+10	‚Ä¢
+11	‚Ä¢
+12	‚Ä¢
+13	‚Ä¢
+14	‚Ä¢
+15	‚Ä¢
+16	‚Ä¢
+17	‚Ä¢
+18	‚Ä¢
+19	‚Ä¢
+1A	‚Ä¢
+1B	‚Ä¢
+1C	‚Ä¢
+1D	‚Ä¢
+1E	‚Ä¢
+1F
A_	‚Ä¢
+20	‚Ä¢
+21	‚Ä¢
+22	‚Ä¢
+23	‚Ä¢
+24	‚Ä¢
+25	‚Ä¢
+26	‚Ä¢
+27	‚Ä¢
+28	‚Ä¢
+29	‚Ä¢
+2A	‚Ä¢
+2B	‚Ä¢
+2C	‚Ä¢
+2D	‚Ä¢
+2E	‚Ä¢
+2F
B_	‚Ä¢
+30	‚Ä¢
+31	‚Ä¢
+32	‚Ä¢
+33	‚Ä¢
+34	‚Ä¢
+35	‚Ä¢
+36	‚Ä¢
+37	‚Ä¢
+38	‚Ä¢
+39	‚Ä¢
+3A	‚Ä¢
+3B	‚Ä¢
+3C	‚Ä¢
+3D	‚Ä¢
+3E	‚Ä¢
+3F
2
C_	2
0000	2
0040	Latin
0080	Latin
00C0	Latin
0100	Latin
0140	Latin
0180	Latin
01C0	Latin
0200	IPA
0240	IPA
0280	IPA
02C0	accents
0300	accents
0340	Greek
0380	Greek
03C0
2
D_	Cyril
0400	Cyril
0440	Cyril
0480	Cyril
04C0	Cyril
0500	Armeni
0540	Hebrew
0580	Hebrew
05C0	Arabic
0600	Arabic
0640	Arabic
0680	Arabic
06C0	Syriac
0700	Arabic
0740	Thaana
0780	N'Ko
07C0
3
E_	Indic
0800	Misc.
1000	Symbol
2000	Kana‚Ä¶
3000	CJK
4000	CJK
5000	CJK
6000	CJK
7000	CJK
8000	CJK
9000	Asian
A000	Hangul
B000	Hangul
C000	Hangul
D000	PUA
E000	Forms
F000
4
F_	SMP‚Ä¶
10000	ÒÄÄÄ
40000	ÚÄÄÄ
80000	SSP‚Ä¶
C0000	SPU‚Ä¶
100000	4
140000	4
180000	4
1C0000	5
200000	5
1000000	5
2000000	5
3000000	6
4000000	6
40000000
  Blue cells are 7-bit (single-byte) sequences. They must not be followed by a continuation byte.[28]

  Orange cells with a large dot are continuation bytes.[29] The hexadecimal number shown after the + symbol is the value of the 6 bits they add.

  White cells are the leading bytes for a sequence of multiple bytes,[30] the length shown at the left edge of the row. The text shows the Unicode blocks encoded by sequences starting with this byte, and the hexadecimal code point shown in the cell is the lowest character value encoded using that leading byte.

  Red cells must never appear in a valid UTF-8 sequence. The first two red cells (C0 and C1) could be used only for a 2-byte encoding of a 7-bit ASCII character which should be encoded in 1 byte; as described below, such "overlong" sequences are disallowed.[31] The red cells in the F_ row (F5 to FD) indicate leading bytes of 4-byte or longer sequences that cannot be valid because they would encode code points larger than the U+10FFFF limit of Unicode (a limit derived from the maximum code point encodable in UTF-16 [32]). FE and FF do not match any allowed character pattern and are therefore not valid start bytes.[33]

  Pink cells are the leading bytes for a sequence of multiple bytes, of which some, but not all, possible continuation sequences are valid. E0 and F0 could start overlong encodings, in this case the lowest non-overlong-encoded code point is shown. F4 can start code points greater than U+10FFFF which are invalid. ED can start the encoding of a code point in the range U+D800‚ÄìU+DFFF; these are invalid since they are reserved for UTF-16 surrogate halves.[34]

Overlong encodings[edit]
In principle, it would be possible to inflate the number of bytes in an encoding by padding the code point with leading 0s. To encode the Euro sign ‚Ç¨ from the above example in four bytes instead of three, it could be padded with leading 0s until it was 21 bits long ‚Äì 000 000010 000010 101100, and encoded as 11110000 10000010 10000010 10101100 (or F0 82 82 AC in hexadecimal). This is called an overlong encoding.

The standard specifies that the correct encoding of a code point uses only the minimum number of bytes required to hold the significant bits of the code point. Longer encodings are called overlong and are not valid UTF-8 representations of the code point. This rule maintains a one-to-one correspondence between code points and their valid encodings, so that there is a unique valid encoding for each code point. This ensures that string comparisons and searches are well-defined.

Invalid sequences and error handling[edit]
Not all sequences of bytes are valid UTF-8. A UTF-8 decoder should be prepared for:

invalid bytes
an unexpected continuation byte
a non-continuation byte before the end of the character
the string ending before the end of the character (which can happen in simple string truncation)
an overlong encoding
a sequence that decodes to an invalid code point
Many of the first UTF-8 decoders would decode these, ignoring incorrect bits and accepting overlong results. Carefully crafted invalid UTF-8 could make them either skip or create ASCII characters such as NUL, slash, or quotes. Invalid UTF-8 has been used to bypass security validations in high-profile products including Microsoft's IIS web server[35] and Apache's Tomcat servlet container.[36] RFC 3629 states "Implementations of the decoding algorithm MUST protect against decoding invalid sequences."[37] The Unicode Standard requires decoders to "...treat any ill-formed code unit sequence as an error condition. This guarantees that it will neither interpret nor emit an ill-formed code unit sequence."

Since RFC 3629 (November 2003), the high and low surrogate halves used by UTF-16 (U+D800 through U+DFFF) and code points not encodable by UTF-16 (those after U+10FFFF) are not legal Unicode values, and their UTF-8 encoding must be treated as an invalid byte sequence. Not decoding unpaired surrogate halves makes it impossible to store invalid UTF-16 (such as Windows filenames or UTF-16 that has been split between the surrogates) as UTF-8.[citation needed]

Some implementations of decoders throw exceptions on errors.[38] This has the disadvantage that it can turn what would otherwise be harmless errors (such as a "no such file" error) into a denial of service. For instance early versions of Python 3.0 would exit immediately if the command line or environment variables contained invalid UTF-8.[39] An alternative practice is to replace errors with a replacement character. Since Unicode 6[40] (October 2010), the standard (chapter 3) has recommended a "best practice" where the error ends as soon as a disallowed byte is encountered. In these decoders E1,A0,C0 is two errors (2 bytes in the first one). This means an error is no more than three bytes long and never contains the start of a valid character, and there are 21,952 different possible errors.[41] The standard also recommends replacing each error with the replacement character "ÔøΩ" (U+FFFD).

Byte order mark[edit]
If the UTF-16 Unicode byte order mark (BOM) character is at the start of a UTF-8 file, the first three bytes will be 0xEF, 0xBB, 0xBF.

The Unicode Standard neither requires nor recommends the use of the BOM for UTF-8, but warns that it may be encountered at the start of a file trans-coded from another encoding.[42] While ASCII text encoded using UTF-8 is backward compatible with ASCII, this is not true when Unicode Standard recommendations are ignored and a BOM is added. Nevertheless, there was and still is software that always inserts a BOM when writing UTF-8, and refuses to correctly interpret UTF-8 unless the first character is a BOM (or the file only contains ASCII).[citation needed]

Naming[edit]
The official Internet Assigned Numbers Authority (IANA) code for the encoding is "UTF-8".[43] All letters are upper-case, and the name is hyphenated. This spelling is used in all the Unicode Consortium documents relating to the encoding.

Alternatively, the name "utf-8" may be used by all standards conforming to the IANA list (which include CSS, HTML, XML, and HTTP headers),[44] as the declaration is case insensitive.[43]

Other descriptions, such as those that omit the hyphen or replace it with a space, i.e. "utf8" or "UTF 8", are not accepted as correct by the governing standards.[37] Despite this, most agents such as browsers can understand them, and so standards intended to describe existing practice (such as HTML5) may effectively require their recognition.[45]

Unofficially, UTF-8-BOM and UTF-8-NOBOM are sometimes used to refer to text files which respectively contain and lack a byte order mark (BOM).[citation needed] In Japan especially, UTF-8 encoding without BOM is sometimes called "UTF-8N".[46][47]

Windows 7 and later, i.e. all supported Windows versions, have codepage 65001, as a synonym for UTF-8 (with better support than in older Windows),[48] and Microsoft has a script for Windows 10, to enable it by default for its program Microsoft Notepad.[49]

In PCL, UTF-8 is called Symbol-ID "18N" (PCL supports 183 character encodings, called Symbol Sets, which potentially could be reduced to one, 18N, that is UTF-8).[50]

History[edit]
See also: Universal Coded Character Set ¬ß History
The International Organization for Standardization (ISO) set out to compose a universal multi-byte character set in 1989. The draft ISO 10646 standard contained a non-required annex called UTF-1 that provided a byte stream encoding of its 32-bit code points. This encoding was not satisfactory on performance grounds, among other problems, and the biggest problem was probably that it did not have a clear separation between ASCII and non-ASCII: new UTF-1 tools would be backward compatible with ASCII-encoded text, but UTF-1-encoded text could confuse existing code expecting ASCII (or extended ASCII), because it could contain continuation bytes in the range 0x21‚Äì0x7E that meant something else in ASCII, e.g., 0x2F for '/', the Unix path directory separator, and this example is reflected in the name and introductory text of its replacement. The table below was derived from a textual description in the annex.

UTF-1
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5
1	U+0000	U+009F	00‚Äì9F
2	U+00A0	U+00FF	A0	A0‚ÄìFF
2	U+0100	U+4015	A1‚ÄìF5	21‚Äì7E, A0‚ÄìFF
3	U+4016	U+38E2D	F6‚ÄìFB	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF
5	U+38E2E	U+7FFFFFFF	FC‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF	21‚Äì7E, A0‚ÄìFF
In July 1992, the X/Open committee XoJIG was looking for a better encoding. Dave Prosser of Unix System Laboratories submitted a proposal for one that had faster implementation characteristics and introduced the improvement that 7-bit ASCII characters would only represent themselves; all multi-byte sequences would include only bytes where the high bit was set. The name File System Safe UCS Transformation Format (FSS-UTF) and most of the text of this proposal were later preserved in the final specification.[51][52][53][54]

FSS-UTF proposal (1992)
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+207F	10xxxxxx	1xxxxxxx
3	U+2080	U+8207F	110xxxxx	1xxxxxxx	1xxxxxxx
4	U+82080	U+208207F	1110xxxx	1xxxxxxx	1xxxxxxx	1xxxxxxx
5	U+2082080	U+7FFFFFFF	11110xxx	1xxxxxxx	1xxxxxxx	1xxxxxxx	1xxxxxxx
In August 1992, this proposal was circulated by an IBM X/Open representative to interested parties. A modification by Ken Thompson of the Plan 9 operating system group at Bell Labs made it somewhat less bit-efficient than the previous proposal but crucially allowed it to be self-synchronizing, letting a reader start anywhere and immediately detect byte sequence boundaries. It also abandoned the use of biases and instead added the rule that only the shortest possible encoding is allowed; the additional loss in compactness is relatively insignificant, but readers now have to look out for invalid encodings to avoid reliability and especially security issues. Thompson's design was outlined on September 2, 1992, on a placemat in a New Jersey diner with Rob Pike. In the following days, Pike and Thompson implemented it and updated Plan 9 to use it throughout, and then communicated their success back to X/Open, which accepted it as the specification for FSS-UTF.[53]

FSS-UTF (1992) / UTF-8 (1993)[2]
Number
of bytes	First
code point	Last
code point	Byte 1	Byte 2	Byte 3	Byte 4	Byte 5	Byte 6
1	U+0000	U+007F	0xxxxxxx
2	U+0080	U+07FF	110xxxxx	10xxxxxx
3	U+0800	U+FFFF	1110xxxx	10xxxxxx	10xxxxxx
4	U+10000	U+1FFFFF	11110xxx	10xxxxxx	10xxxxxx	10xxxxxx
5	U+200000	U+3FFFFFF	111110xx	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx
6	U+4000000	U+7FFFFFFF	1111110x	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx	10xxxxxx
UTF-8 was first officially presented at the USENIX conference in San Diego, from January 25 to 29, 1993. The Internet Engineering Task Force adopted UTF-8 in its Policy on Character Sets and Languages in RFC 2277 (BCP 18) for future Internet standards work, replacing Single Byte Character Sets such as Latin-1 in older RFCs.[55]

In November 2003, UTF-8 was restricted by RFC 3629 to match the constraints of the UTF-16 character encoding: explicitly prohibiting code points corresponding to the high and low surrogate characters removed more than 3% of the three-byte sequences, and ending at U+10FFFF removed more than 48% of the four-byte sequences and all five- and six-byte sequences.

Standards[edit]
There are several current definitions of UTF-8 in various standards documents:

RFC 3629 / STD 63 (2003), which establishes UTF-8 as a standard Internet protocol element
RFC 5198 defines UTF-8 NFC for Network Interchange (2008)
ISO/IEC 10646:2014 ¬ß9.1 (2014)[56]
The Unicode Standard, Version 11.0 (2018)[57]
They supersede the definitions given in the following obsolete works:

The Unicode Standard, Version 2.0, Appendix A (1996)
ISO/IEC 10646-1:1993 Amendment 2 / Annex R (1996)
RFC 2044 (1996)
RFC 2279 (1998)
The Unicode Standard, Version 3.0, ¬ß2.3 (2000) plus Corrigendum #1 : UTF-8 Shortest Form (2000)
Unicode Standard Annex #27: Unicode 3.1 (2001)[58]
The Unicode Standard, Version 5.0 (2006)[59]
The Unicode Standard, Version 6.0 (2010)[60]
They are all the same in their general mechanics, with the main differences being on issues such as allowed range of code point values and safe handling of invalid input.

Comparison with other encodings[edit]
See also: Comparison of Unicode encodings
Some of the important features of this encoding are as follows:

Backward compatibility: Backward compatibility with ASCII and the enormous amount of software designed to process ASCII-encoded text was the main driving force behind the design of UTF-8. In UTF-8, single bytes with values in the range of 0 to 127 map directly to Unicode code points in the ASCII range. Single bytes in this range represent characters, as they do in ASCII. Moreover, 7-bit bytes (bytes where the most significant bit is 0) never appear in a multi-byte sequence, and no valid multi-byte sequence decodes to an ASCII code-point. A sequence of 7-bit bytes is both valid ASCII and valid UTF-8, and under either interpretation represents the same sequence of characters. Therefore, the 7-bit bytes in a UTF-8 stream represent all and only the ASCII characters in the stream. Thus, many text processors, parsers, protocols, file formats, text display programs, etc., which use ASCII characters for formatting and control purposes, will continue to work as intended by treating the UTF-8 byte stream as a sequence of single-byte characters, without decoding the multi-byte sequences. ASCII characters on which the processing turns, such as punctuation, whitespace, and control characters will never be encoded as multi-byte sequences. It is therefore safe for such processors to simply ignore or pass-through the multi-byte sequences, without decoding them. For example, ASCII whitespace may be used to tokenize a UTF-8 stream into words; ASCII line-feeds may be used to split a UTF-8 stream into lines; and ASCII NUL characters can be used to split UTF-8-encoded data into null-terminated strings. Similarly, many format strings used by library functions like "printf" will correctly handle UTF-8-encoded input arguments.
Fallback and auto-detection: Only a small subset of possible byte strings are a valid UTF-8 string: the bytes C0, C1, and F5 through FF cannot appear, and bytes with the high bit set must be in pairs, and other requirements. It is extremely unlikely that a readable text in any extended ASCII is valid UTF-8. Part of the popularity of UTF-8 is due to it providing a form of backward compatibility for these as well. A UTF-8 processor which erroneously receives extended ASCII as input can thus "auto-detect" this with very high reliability. Fallback errors will be false negatives, and these will be rare. Moreover, in many applications, such as text display, the consequence of incorrect fallback is usually slight.[original research?] A UTF-8 stream may simply contain errors, resulting in the auto-detection scheme producing false positives; but auto-detection is successful in the majority of cases, especially with longer texts, and is widely used. It also works to "fall back" or replace 8-bit bytes using the appropriate code-point for a legacy encoding only when errors in the UTF-8 are detected, allowing recovery even if UTF-8 and legacy encoding is concatenated in the same file.
Prefix code: The first byte indicates the number of bytes in the sequence. Reading from a stream can instantaneously decode each individual fully received sequence, without first having to wait for either the first byte of a next sequence or an end-of-stream indication. The length of multi-byte sequences is easily determined by humans as it is simply the number of high-order 1s in the leading byte. An incorrect character will not be decoded if a stream ends mid-sequence.
Self-synchronization: The leading bytes and the continuation bytes do not share values (continuation bytes start with the bits 10 while single bytes start with 0 and longer lead bytes start with 11). This means a search will not accidentally find the sequence for one character starting in the middle of another character. It also means the start of a character can be found from a random position by backing up at most 3 bytes to find the leading byte. An incorrect character will not be decoded if a stream starts mid-sequence, and a shorter sequence will never appear inside a longer one.
Sorting order: The chosen values of the leading bytes means that a list of UTF-8 strings can be sorted in code point order by sorting the corresponding byte sequences.
Single-byte[edit]
UTF-8 can encode any Unicode character, avoiding the need to figure out and set a "code page" or otherwise indicate what character set is in use, and allowing output in multiple scripts at the same time. For many scripts there have been more than one single-byte encoding in usage, so even knowing the script was insufficient information to display it correctly.
The bytes 0xFE and 0xFF do not appear, so a valid UTF-8 stream never matches the UTF-16 byte order mark and thus cannot be confused with it. The absence of 0xFF (0377) also eliminates the need to escape this byte in Telnet (and FTP control connection).
UTF-8 encoded text is larger than specialized single-byte encodings except for plain ASCII characters. In the case of scripts which used 8-bit character sets with non-Latin characters encoded in the upper half (such as most Cyrillic and Greek alphabet code pages), characters in UTF-8 will be double the size. For some scripts, such as Thai and Devanagari (which is used by various South Asian languages), characters will triple in size. There are even examples where a single byte turns into a composite character in Unicode and is thus six times larger in UTF-8. This has caused objections in India and other countries.
It is possible in UTF-8 (or any other variable-length encoding) to split or truncate a string in the middle of a character. If the two pieces are not re-appended later before interpretation as characters, this can introduce an invalid sequence at both the end of the previous section and the start of the next, and some decoders will not preserve these bytes and result in data loss. Because UTF-8 is self-synchronizing this will however never introduce a different valid character, and it is also fairly easy to move the truncation point backward to the start of a character.
If the code points are all the same size, measurements of a fixed number of them is easy. Due to ASCII-era documentation where "character" is used as a synonym for "byte" this is often considered important. However, by measuring string positions using bytes instead of "characters" most algorithms can be easily and efficiently adapted for UTF-8. Searching for a string within a long string can for example be done byte by byte; the self-synchronization property prevents false positives.
Other multi-byte[edit]
UTF-8 can encode any Unicode character. Files in different scripts can be displayed correctly without having to choose the correct code page or font. For instance, Chinese and Arabic can be written in the same file without specialised markup or manual settings that specify an encoding.
UTF-8 is self-synchronizing: character boundaries are easily identified by scanning for well-defined bit patterns in either direction. If bytes are lost due to error or corruption, one can always locate the next valid character and resume processing. If there is a need to shorten a string to fit a specified field, the previous valid character can easily be found. Many multi-byte encodings such as Shift JIS are much harder to resynchronize. This also means that byte-oriented string-searching algorithms can be used with UTF-8 (as a character is the same as a "word" made up of that many bytes), optimized versions of byte searches can be much faster due to hardware support and lookup tables that have only 256 entries. Self-synchronization does however require that bits be reserved for these markers in every byte, increasing the size.
Efficient to encode using simple bitwise operations. UTF-8 does not require slower mathematical operations such as multiplication or division (unlike Shift JIS, GB 2312 and other encodings).
UTF-8 will take more space than a multi-byte encoding designed for a specific script. East Asian legacy encodings generally used two bytes per character yet take three bytes per character in UTF-8.
UTF-16[edit]
Byte encodings and UTF-8 are represented by byte arrays in programs, and often nothing needs to be done to a function when converting source code from a byte encoding to UTF-8. UTF-16 is represented by 16-bit word arrays, and converting to UTF-16 while maintaining compatibility with existing ASCII-based programs (such as was done with Windows) requires every API and data structure that takes a string to be duplicated, one version accepting byte strings and another version accepting UTF-16. If backward compatibility is not needed, all string handling still must be modified.
Text encoded in UTF-8 will be smaller than the same text encoded in UTF-16 if there are more code points below U+0080 than in the range U+0800..U+FFFF. This is true for all modern European languages.
Text in (for example) Chinese, Japanese or Devanagari will take more space in UTF-8 if there are more of these characters than there are ASCII characters. This is likely when data mainly consist of pure prose, but is lessened by the degree to which the context uses ASCII whitespace, digits, and punctuation.[nb 3]
Most of the rich text formats (including HTML) contain a large proportion of ASCII characters for the sake of formatting, thus the size usually will be reduced significantly compared with UTF-16, even when the language mostly uses 3-byte long characters in UTF-8.[nb 4]
Most communication (e.g. HTML and IP) and storage (e.g. for Unix) was designed for a stream of bytes. A UTF-16 string must use a pair of bytes for each code unit:
The order of those two bytes becomes an issue and must be specified in the UTF-16 protocol, such as with a byte order mark.
If an odd number of bytes is missing from UTF-16, the whole rest of the string will be meaningless text. Any bytes missing from UTF-8 will still allow the text to be recovered accurately starting with the next character after the missing bytes.
Derivatives[edit]
The following implementations show slight differences from the UTF-8 specification. They are incompatible with the UTF-8 specification and may be rejected by conforming UTF-8 applications.

CESU-8[edit]
Main article: CESU-8
Unicode Technical Report #26[61] assigns the name CESU-8 to a nonstandard variant of UTF-8, in which Unicode characters in supplementary planes are encoded using six bytes, rather than the four bytes required by UTF-8. CESU-8 encoding treats each half of a four-byte UTF-16 surrogate pair as a two-byte UCS-2 character, yielding two three-byte UTF-8 characters, which together represent the original supplementary character. Unicode characters within the Basic Multilingual Plane appear as they would normally in UTF-8. The Report was written to acknowledge and formalize the existence of data encoded as CESU-8, despite the Unicode Consortium discouraging its use, and notes that a possible intentional reason for CESU-8 encoding is preservation of UTF-16 binary collation.

CESU-8 encoding can result from converting UTF-16 data with supplementary characters to UTF-8, using conversion methods that assume UCS-2 data, meaning they are unaware of four-byte UTF-16 supplementary characters. It is primarily an issue on operating systems which extensively use UTF-16 internally, such as Microsoft Windows.[citation needed]

In Oracle Database, the UTF8 character set uses CESU-8 encoding, and is deprecated. The AL32UTF8 character set uses standards-compliant UTF-8 encoding, and is preferred.[62][63]

CESU-8 is prohibited for use in HTML5 documents.[64][65][66]

MySQL utf8mb3[edit]
In MySQL, the utf8mb3 character set is defined to be UTF-8 encoded data with a maximum of three bytes per character, meaning only Unicode characters in the Basic Multilingual Plane are supported. Unicode characters in supplementary planes are explicitly not supported. utf8mb3 is deprecated in favor of the utf8mb4 character set, which uses standards-compliant UTF-8 encoding. utf8 is an alias for utf8mb3, but is intended to become an alias to utf8mb4 in a future release of MySQL.[67] It is possible, though unsupported, to store CESU-8 encoded data in utf8mb3, by handling UTF-16 data with supplementary characters as though it is UCS-2.

Modified UTF-8[edit]
Modified UTF-8 (MUTF-8) originated in the Java programming language. In Modified UTF-8, the null character (U+0000) uses the two-byte overlong encoding 11000000 10000000 (hexadecimal C0 80), instead of 00000000 (hexadecimal 00).[68] Modified UTF-8 strings never contain any actual null bytes but can contain all Unicode code points including U+0000,[69] which allows such strings (with a null byte appended) to be processed by traditional null-terminated string functions. All known Modified UTF-8 implementations also treat the surrogate pairs as in CESU-8.

In normal usage, the language supports standard UTF-8 when reading and writing strings through InputStreamReader and OutputStreamWriter (if it is the platform's default character set or as requested by the program). However it uses Modified UTF-8 for object serialization[70] among other applications of DataInput and DataOutput, for the Java Native Interface,[71] and for embedding constant strings in class files.[72]

The dex format defined by Dalvik also uses the same modified UTF-8 to represent string values.[73] Tcl also uses the same modified UTF-8[74] as Java for internal representation of Unicode data, but uses strict CESU-8 for external data.

WTF-8[edit]

This section contains a list of miscellaneous information. Please relocate any relevant information into other sections or articles. (August 2020)
In WTF-8 (Wobbly Transformation Format, 8-bit) unpaired surrogate halves (U+D800 through U+DFFF) are allowed.[75] This is necessary to store possibly-invalid UTF-16, such as Windows filenames. Many systems that deal with UTF-8 work this way without considering it a different encoding, as it is simpler.[76]

(The term "WTF-8" has also been used humorously to refer to erroneously doubly-encoded UTF-8[77][78] sometimes with the implication that CP1252 bytes are the only ones encoded)[79]

PEP 383[edit]
Version 3 of the Python programming language treats each byte of an invalid UTF-8 bytestream as an error; this gives 128 different possible errors. Extensions have been created to allow any byte sequence that is assumed to be UTF-8 to be lossless transformed to UTF-16 or UTF-32, by translating the 128 possible error bytes to reserved code points, and transforming those code points back to error bytes to output UTF-8. The most common approach is to translate the codes to U+DC80...U+DCFF which are low (trailing) surrogate values and thus "invalid" UTF-16, as used by Python's PEP 383 (or "surrogateescape") approach.[80] Another encoding called MirBSD OPTU-8/16 converts them to U+EF80...U+EFFF in a Private Use Area.[81] In either approach, the byte value is encoded in the low eight bits of the output code point.

These encodings are very useful because they avoid the need to deal with "invalid" byte strings until much later, if at all, and allow "text" and "data" byte arrays to be the same object. If a program wants to use UTF-16 internally these are required to preserve and use filenames that can use invalid UTF-8;[82] as the Windows filesystem API uses UTF-16, the need to support invalid UTF-8 is less there.[80]

For the encoding to be reversible, the standard UTF-8 encodings of the code points used for erroneous bytes must be considered invalid. This makes the encoding incompatible with WTF-8 or CESU-8 (though only for 128 code points). When re-encoding it is necessary to be careful of sequences of error code points which convert back to valid UTF-8, which may be used by malicious software to get unexpected characters in the output, though this cannot produce ASCII characters so it is considered comparatively safe, since malicious sequences (such as cross-site scripting) usually rely on ASCII characters.[82]

See also[edit]
Alt code
Character encodings in HTML
Comparison of e-mail clients#Features
Comparison of Unicode encodings
Iconv
Specials (Unicode block)
Unicode and email
Unicode and HTML
Percent-encoding#Current standard
UTF-EBCDIC
Notes[edit]
^ 17 planes times 216 code points per plane, minus 211 technically-invalid surrogates.
^ You might expect larger code points than U+10FFFF to be expressible, but in RFC3629 ¬ß3 UTF-8 is limited to match the limits of UTF-16. (As ¬ß12 notes, this is changed from RFC 2279.)
^ The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi), when the pure text was pasted to Notepad, generated 19 KB when saved as UTF-16 and 22 KB when saved as UTF-8.
^ The 2010-10-27 version of UTF-8 (in Japanese) generated 169 KB when converted with Notepad to UTF-16, and only 101 KB when converted back to UTF-8. The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi) required 119 KB in UTF-16 and 76 KB in UTF-8.
References[edit]
^ "Chapter 2. General Structure". The Unicode Standard (6.0 ed.). Mountain View, California, US: The Unicode Consortium. ISBN 978-1-936213-01-6.
^ Jump up to: a b Pike, Rob (30 April 2003). "UTF-8 history".
^ Pike, Rob; Thompson, Ken (1993). "Hello World or ŒöŒ±ŒªŒ∑ŒºŒ≠œÅŒ± Œ∫œåœÉŒºŒµ or „Åì„Çì„Å´„Å°„ÅØ ‰∏ñÁïå" (PDF). Proceedings of the Winter 1993 USENIX Conference.
^ Jump up to: a b c "Usage Survey of Character Encodings broken down by Ranking". w3techs.com. Retrieved 2020-08-24.
^ Jump up to: a b Davis, Mark (2012-02-03). "Unicode over 60 percent of the web". Official Google Blog. Archived from the original on 2018-08-09. Retrieved 2020-07-24.
^ "Encoding Standard". encoding.spec.whatwg.org. Retrieved 2020-04-15.
^ "Using International Characters in Internet Mail". Internet Mail Consortium. 1998-08-01. Archived from the original on 2007-10-26. Retrieved 2007-11-08.
^ "Encoding Standard". encoding.spec.whatwg.org. Retrieved 2018-11-15.
^ Davis, Mark (2008-05-05). "Moving to Unicode 5.1". Retrieved 2013-03-01.
^ "Specifying the document's character encoding". HTML5.2. World Wide Web Consortium. 14 December 2017. Retrieved 2018-06-03.
^ "The JavaScript Object Notation (JSON) Data Interchange Format". IETF. December 2017. Retrieved 16 February 2018.
^ "Usage Statistics and Market Share of US-ASCII for Websites, August 2020". w3techs.com. Retrieved 2020-08-28.
^ "Distribution of Character Encodings among websites that use Iranian languages". w3techs.com. Retrieved 2018-12-03.
^ "Distribution of Character Encodings among websites that use Sign Languages". w3techs.com. Retrieved 2018-12-03.
^ "Distribution of Character Encodings among websites that use .cn". w3techs.com. Retrieved 2020-09-01.
^ "Distribution of Character Encodings among websites that use Chinese". w3techs.com. Retrieved 2020-07-03.
^ "Distribution of Character Encodings among websites that use .ru". w3techs.com. Retrieved 2020-09-01.
^ "Distribution of Character Encodings among websites that use Greek". w3techs.com. Retrieved 2020-09-07.
^ "Distribution of Character Encodings among websites that use Hebrew". w3techs.com. Retrieved 2020-09-07.
^ "Historical trends in the usage of character encodings". Retrieved 2020-07-24.
^ "UTF-8 Usage Statistics". BuiltWith. Retrieved 2011-03-28.
^ "Usage Report of UTF-8 broken down by Content Languages". w3techs.com. Retrieved 2020-09-07.
^ "UTF-8 - ICU User Guide". userguide.icu-project.org. Retrieved 2018-04-03.
^ "#13311 (change illegal-UTF-8 handling to Unicode "best practice")". bugs.icu-project.org. Retrieved 2018-04-03.
^ "Use the Windows UTF-8 code page". UWP applications. docs.microsoft.com. Retrieved 2020-06-06.
^ Allen, Julie D.; Anderson, Deborah; Becker, Joe; Cook, Richard, eds. (2012). "The Unicode Standard, Version 6.1". Mountain View, California: Unicode Consortium.
^ https://ci.apache.org/projects/flink/flink-docs-release-1.9/api/java/org/apache/flink/table/dataformat/BinaryString.html#compareTo-org.apache.flink.table.dataformat.BinaryString-
^ "Chapter 3", The Unicode Standard (PDF), p. 54
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ "Chapter 3", The Unicode Standard (PDF), p. 54
^ Yergeau, F. (November 2003). UTF-8, a transformation format of ISO 10646. IETF. doi:10.17487/RFC3629. STD 63. RFC 3629. Retrieved August 20, 2020.
^ "Chapter 3", The Unicode Standard (PDF), p. 55
^ Yergeau, F. (November 2003). UTF-8, a transformation format of ISO 10646. IETF. doi:10.17487/RFC3629. STD 63. RFC 3629. Retrieved August 20, 2020.
^ Marin, Marvin (2000-10-17). "Web Server Folder Traversal MS00-078".
^ "Summary for CVE-2008-2938". National Vulnerability Database.
^ Jump up to: a b Yergeau, F. (2003). UTF-8, a transformation format of ISO 10646. Internet Engineering Task Force. doi:10.17487/RFC3629. RFC 3629. Retrieved 2015-02-03.
^ Java's DataInput IO Interface
^ "Non-decodable Bytes in System Character Interfaces". python.org. 2009-04-22. Retrieved 2014-08-13.
^ "Unicode 6.0.0".
^ 128 1-byte, (16+5)√ó64 2-byte, and 5√ó64√ó64 3-byte. There may be somewhat fewer if more precise tests are done for each continuation byte.
^ "Chapter 2", The Unicode Standard (PDF), p. 30
^ Jump up to: a b "Character Sets". Internet Assigned Numbers Authority. 2013-01-23. Retrieved 2013-02-08.
^ D√ºrst, Martin. "Setting the HTTP charset parameter". W3C. Retrieved 2013-02-08.
^ "Encoding Standard ¬ß 4.2. Names and labels". WHATWG. Retrieved 2018-04-29.
^ "BOM". suikawiki (in Japanese). Retrieved 2013-04-26.
^ Davis, Mark. "Forms of Unicode". IBM. Archived from the original on 2005-05-06. Retrieved 2013-09-18.
^ Liviu (2014-02-07). "UTF-8 codepage 65001 in Windows 7 - part I". Retrieved 2018-01-30.
^ "Script How to set default encoding to UTF-8 for notepad by PowerShell". gallery.technet.microsoft.com. Retrieved 2018-01-30.
^ "HP PCL Symbol Sets | Printer Control Language (PCL & PXL) Support Blog". 2015-02-19. Archived from the original on 2015-02-19. Retrieved 2018-01-30.
^ "Appendix F. FSS-UTF / File System Safe UCS Transformation format" (PDF). The Unicode Standard 1.1. Archived (PDF) from the original on 2016-06-07. Retrieved 2016-06-07.
^ Whistler, Kenneth (2001-06-12). "FSS-UTF, UTF-2, UTF-8, and UTF-16". Archived from the original on 2016-06-07. Retrieved 2006-06-07.
^ Jump up to: a b Pike, Rob (2003-04-30). "UTF-8 history". Retrieved 2012-09-07.
^ Pike, Rob (2012-09-06). "UTF-8 turned 20 years old yesterday". Retrieved 2012-09-07.
^ Alvestrand, Harald (January 1998). IETF Policy on Character Sets and Languages. doi:10.17487/RFC2277. BCP 18.
^ ISO/IEC 10646:2014 ¬ß9.1, 2014.
^ The Unicode Standard, Version 11.0 ¬ß3.9 D92, ¬ß3.10 D95, 2018.
^ Unicode Standard Annex #27: Unicode 3.1, 2001.
^ The Unicode Standard, Version 5.0 ¬ß3.9‚Äì¬ß3.10 ch. 3, 2006.
^ The Unicode Standard, Version 6.0 ¬ß3.9 D92, ¬ß3.10 D95, 2010.
^ McGowan, Rick (2011-12-19). "Compatibility Encoding Scheme for UTF-16: 8-Bit (CESU-8)". Unicode Consortium. Unicode Technical Report #26.
^ "Character Set Support". Oracle Database 19c Documentation, SQL Language Reference. Oracle Corporation.
^ "Supporting Multilingual Databases with Unicode ¬ß Support for the Unicode Standard in Oracle Database". Database Globalization Support Guide. Oracle Corporation.
^ "8.2.2.3. Character encodings". HTML 5.1 Standard. W3C.
^ "8.2.2.3. Character encodings". HTML 5 Standard. W3C.
^ "12.2.3.3 Character encodings". HTML Living Standard. WHATWG.
^ "The utf8mb3 Character Set (3-Byte UTF-8 Unicode Encoding)". MySQL 8.0 Reference Manual. Oracle Corporation.
^ "Java SE documentation for Interface java.io.DataInput, subsection on Modified UTF-8". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "Java Object Serialization Specification, chapter 6: Object Serialization Stream Protocol, section 2: Stream Elements". Oracle Corporation. 2010. Retrieved 2015-10-16.
^ "Java Native Interface Specification, chapter 3: JNI Types and Data Structures, section: Modified UTF-8 Strings". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16.
^ "ART and Dalvik". Android Open Source Project. Archived from the original on 2013-04-26. Retrieved 2013-04-09.
^ "Tcler's Wiki: UTF-8 bit by bit (Revision 6)". 2009-04-25. Retrieved 2009-05-22.
^ Sapin, Simon (2016-03-11) [2014-09-25]. "The WTF-8 encoding". Archived from the original on 2016-05-24. Retrieved 2016-05-24.
^ Sapin, Simon (2015-03-25) [2014-09-25]. "The WTF-8 encoding ¬ß Motivation". Archived from the original on 2016-05-24. Retrieved 2020-08-26.
^ "WTF-8.com". 2006-05-18. Retrieved 2016-06-21.
^ Speer, Robyn (2015-05-21). "ftfy (fixes text for you) 4.0: changing less and fixing more". Archived from the original on 2015-05-30. Retrieved 2016-06-21.
^ "WTF-8, a transformation format of code page 1252". Archived from the original on 2016-10-13. Retrieved 2016-10-12.
^ Jump up to: a b von L√∂wis, Martin (2009-04-22). "Non-decodable Bytes in System Character Interfaces". Python Software Foundation. PEP 383.
^ "RTFM optu8to16(3), optu8to16vis(3)". www.mirbsd.org.
^ Jump up to: a b Davis, Mark; Suignard, Michel (2014). "3.7 Enabling Lossless Conversion". Unicode Security Considerations. Unicode Technical Report #36.
External links[edit]
Original UTF-8 paper (or pdf) for Plan 9 from Bell Labs
UTF-8 test pages:
Andreas Prilop
Jost Gippert
World Wide Web Consortium
Unix/Linux: UTF-8/Unicode FAQ, Linux Unicode HOWTO, 8.xml UTF-8 and Gentoo
Characters, Symbols and the Unicode Miracle on YouTube
showvte
Unicode
showvte
Character encodings
showvte
Rob Pike
showvte
Ken Thompson
Categories: Character encodingComputer-related introductions in 1993EncodingsUnicode Transformation Formats
Navigation menu
Not logged inTalkContributionsCreate accountLog in
ArticleTalk
ReadEditView history
Search

Main page
Contents
Current events
Random article
About Wikipedia
Contact us
Donate
Contribute
Help
Learn to edit
Community portal
Recent changes
Upload file
Tools
What links here
Related changes
Special pages
Permanent link
Page information
Cite this page
Wikidata item
Print/export
Download as PDF
Printable version

Languages
ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
Espa√±ol
Bahasa Indonesia
Italiano
Bahasa Melayu
Portugu√™s
–†—É—Å—Å–∫–∏–π
ÿßÿ±ÿØŸà
‰∏≠Êñá
32 more
Edit links
This page was last edited on 20 October 2020, at 18:05 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia¬Æ is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
Privacy policyAbout WikipediaDisclaimersContact WikipediaMobile viewDevelopersStatisticsCookie statement
Wikimedia FoundationPowered by MediaWiki

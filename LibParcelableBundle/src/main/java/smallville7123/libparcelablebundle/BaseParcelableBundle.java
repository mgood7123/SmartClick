package smallville7123.libparcelablebundle;

/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import android.os.BadParcelableException;
import android.os.Build;
import android.os.Bundle;
import android.os.Parcel;
import android.os.PersistableBundle;
import android.util.Log;
import android.util.SparseArray;

import androidx.annotation.CallSuper;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.annotation.VisibleForTesting;

import java.io.Serializable;
import java.lang.ref.PhantomReference;
import java.lang.ref.WeakReference;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Map;
import java.util.Set;

import smallville7123.libparcelablebundle.tools.ArrayMap;
import smallville7123.libparcelablebundle.tools.IndentingPrintWriter;
import smallville7123.libparcelablebundle.tools.LogWriter;
import smallville7123.libparcelablebundle.tools.MathUtils;
import smallville7123.libparcelablebundle.tools.Slog;
import smallville7123.todo.TODO;

/**
 * A mapping from String keys to values of various types. In most cases, you
 * should work directly with either the {@link Bundle} or
 * {@link PersistableBundle} subclass.
 */
public class BaseParcelableBundle {
    static final String TAG = "ParcelableBundle";
    static final boolean DEBUG = true;
    static LogWriter log = new LogWriter("logWriter").toSystemOut();

    // Keep them in sync with frameworks/native/libs/binder/PersistableBundle.cpp.
    static final int BUNDLE_MAGIC = 0x4C444E42; // 'B' 'N' 'D' 'L'
    static final int BUNDLE_MAGIC_NATIVE = 0x4C444E44; // 'B' 'N' 'D' 'N'

    /**
     * Flag indicating that this Bundle is okay to "defuse." That is, it's okay
     * for system processes to ignore any {@link BadParcelableException}
     * encountered when unparceling it, leaving an empty bundle in its place.
     * <p>
     * This should <em>only</em> be set when the Bundle reaches its final
     * destination, otherwise a system process may clobber contents that were
     * destined for an app that could have unparceled them.
     */
    static final int FLAG_DEFUSABLE = 1 << 0;

    private static final boolean LOG_DEFUSABLE = false;

    private static volatile boolean sShouldDefuse = false;
    
    /**
     * Set global variable indicating that any Bundles parsed in this process
     * should be "defused." That is, any {@link BadParcelableException}
     * encountered will be suppressed and logged, leaving an empty Bundle
     * instead of crashing.
     *
     * @hide
     */
    public static void setShouldDefuse(boolean shouldDefuse) {
        sShouldDefuse = shouldDefuse;
    }

    // A parcel cannot be obtained during compile-time initialization. Put the
    // empty parcel into an inner class that can be initialized separately. This
    // allows to initialize BaseParcelableBundle, and classes depending on it.
    /** {@hide} */
    static final class NoImagePreloadHolder {
        public static final Parcel EMPTY_PARCEL = Parcel.obtain();
    }

    // Invariant - exactly one of mMap / mParcelledData will be null
    // (except inside a call to unparcel)

    ArrayMap<String, Object> mMap = null;

    /*
     * If mParcelledData is non-null, then mMap will be null and the
     * data are stored as a Parcel containing a Bundle.  When the data
     * are unparcelled, mParcelledData willbe set to null.
     */
    Parcel mParcelledData = null;

    /**
     * Whether {@link #mParcelledData} was generated by native coed or not.
     */
    boolean mParcelledByNative;

    /**
     * The ClassLoader used when unparcelling data from mParcelledData.
     */
    ClassLoader mClassLoader;

    /** {@hide} */
    @VisibleForTesting
    public int mFlags;

    /**
     * Constructs a new, empty Bundle that uses a specific ClassLoader for
     * instantiating Parcelable and Serializable objects.
     *
     * @param loader An explicit ClassLoader to use when instantiating objects
     * inside of the Bundle.
     * @param capacity Initial size of the ArrayMap.
     */
    BaseParcelableBundle(@Nullable ClassLoader loader, int capacity) {
        mMap = capacity > 0 ?
                new ArrayMap<String, Object>(capacity) : new ArrayMap<String, Object>();
        mClassLoader = loader == null ? getClass().getClassLoader() : loader;
    }

    /**
     * Constructs a new, empty Bundle.
     */
    BaseParcelableBundle() {
        this((ClassLoader) null, 0);
    }

    /**
     * Constructs a Bundle whose data is stored as a Parcel.  The data
     * will be unparcelled on first contact, using the assigned ClassLoader.
     *
     * @param parcelledData a Parcel containing a Bundle
     */
    BaseParcelableBundle(Parcel parcelledData) {
        readFromParcelInner(parcelledData);
    }

    BaseParcelableBundle(Parcel parcelledData, int length) {
        readFromParcelInner(parcelledData, length);
    }

    /**
     * Constructs a new, empty Bundle that uses a specific ClassLoader for
     * instantiating Parcelable and Serializable objects.
     *
     * @param loader An explicit ClassLoader to use when instantiating objects
     * inside of the Bundle.
     */
    BaseParcelableBundle(ClassLoader loader) {
        this(loader, 0);
    }

    /**
     * Constructs a new, empty Bundle sized to hold the given number of
     * elements. The Bundle will grow as needed.
     *
     * @param capacity the initial capacity of the Bundle
     */
    BaseParcelableBundle(int capacity) {
        this((ClassLoader) null, capacity);
    }

    /**
     * Constructs a Bundle containing a copy of the mappings from the given
     * Bundle.
     *
     * @param b a Bundle to be copied.
     */
    @RequiresApi(api = Build.VERSION_CODES.O)
    BaseParcelableBundle(Bundle b) {
        copyInternal(b, false);
    }

    /**
     * Constructs a PersistableBundle containing a copy of the mappings from the given
     * PersistableBundle.
     *
     * @param b a PersistableBundle to be copied.
     */
    @RequiresApi(api = Build.VERSION_CODES.O)
    BaseParcelableBundle(PersistableBundle b) {
        copyInternal(b, false);
    }

    /**
     * Constructs a BaseParcelableBundle containing a copy of the mappings from the given
     * BaseParcelableBundle.
     *
     * @param b a BaseParcelableBundle to be copied.
     */
    @RequiresApi(api = Build.VERSION_CODES.O)
    BaseParcelableBundle(BaseParcelableBundle b) {
        copyInternal(b, false);
    }

    /**
     * Special constructor that does not initialize the bundle.
     */
    BaseParcelableBundle(boolean doInit) {
    }

    /**
     * TODO: optimize this later (getting just the value part of a Bundle
     * with a single pair) once Bundle.forPair() above is implemented
     * with a special single-value Map implementation/serialization.
     *
     * Note: value in single-pair Bundle may be null.
     *
     * @hide
     */
    public String getPairValue() {
        unparcel();
        int size = mMap.size();
        if (size > 1) {
            Log.w(TAG, "getPairValue() used on Bundle with multiple pairs.");
        }
        if (size == 0) {
            return null;
        }
        Object o = mMap.valueAt(0);
        try {
            return (String) o;
        } catch (ClassCastException e) {
            typeWarning("getPairValue()", o, "String", e);
            return null;
        }
    }

    /**
     * Changes the ClassLoader this Bundle uses when instantiating objects.
     *
     * @param loader An explicit ClassLoader to use when instantiating objects
     * inside of the Bundle.
     */
    void setClassLoader(ClassLoader loader) {
        mClassLoader = loader;
    }

    /**
     * Return the ClassLoader currently associated with this Bundle.
     */
    ClassLoader getClassLoader() {
        return mClassLoader;
    }

    /**
     * If the underlying data are stored as a Parcel, unparcel them
     * using the currently assigned class loader.
     */
    /* package */ void unparcel() {
        synchronized (this) {
            final Parcel source = mParcelledData;
            if (source != null) {
                initializeFromParcelLocked(source, /*recycleParcel=*/ true, mParcelledByNative);
            } else {
                if (DEBUG) {
                    Log.d(TAG, "unparcel "
                            + Integer.toHexString(System.identityHashCode(this))
                            + ": no parcelled data");
                }
            }
        }
    }

    private static Method sGetBundleUnparcelMethod;
    private static boolean sGetBundleUnparcelMethodFetched;
    /**
     * If the given Bundle's data is stored as a Parcel, unparcel them
     * using the given Bundle's currently assigned class loader.
     */
    /* package */ void unparcel(Bundle bundle) {
        if (!sGetBundleUnparcelMethodFetched) {
            try {
                sGetBundleUnparcelMethod = Bundle.class.getMethod("unparcel");
                sGetBundleUnparcelMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                Log.i(TAG, "Failed to retrieve Unparcel method", e);
            }
            sGetBundleUnparcelMethodFetched = true;
        }

        if (sGetBundleUnparcelMethod != null) {
            try {
                sGetBundleUnparcelMethod.invoke(bundle);
            } catch (InvocationTargetException | IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to invoke getIBinder via reflection", e);
                sGetBundleUnparcelMethod = null;
            }
        }
    }

    private static Method sGetPersistableBundleUnparcelMethod;
    private static boolean sGetPersistableBundleUnparcelMethodFetched;

    /**
     * If the given PersistableBundle's data is stored as a Parcel, unparcel them
     * using the given PersistableBundle's currently assigned class loader.
     */
    /* package */ void unparcel(PersistableBundle bundle) {
        if (!sGetPersistableBundleUnparcelMethodFetched) {
            try {
                sGetPersistableBundleUnparcelMethod = Bundle.class.getMethod("unparcel");
                sGetPersistableBundleUnparcelMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                Log.i(TAG, "Failed to retrieve Unparcel method", e);
            }
            sGetPersistableBundleUnparcelMethodFetched = true;
        }

        if (sGetPersistableBundleUnparcelMethod != null) {
            try {
                sGetPersistableBundleUnparcelMethod.invoke(bundle);
            } catch (InvocationTargetException | IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to invoke getIBinder via reflection", e);
                sGetPersistableBundleUnparcelMethod = null;
            }
        }
    }

    private static Method sGetParcelReadArrayMapSafelyInternalMethod;
    private static boolean sGetParcelReadArrayMapSafelyInternalMethodFetched;
    /**
     * If the given Bundle's data is stored as a Parcel, unparcel them
     * using the given Bundle's currently assigned class loader.
     */
    /* package */ void readArrayMapSafelyInternal(Parcel parcel, android.util.ArrayMap outVal, int N,
                                                  ClassLoader loader) {
        if (!sGetParcelReadArrayMapSafelyInternalMethodFetched) {
            try {
                sGetParcelReadArrayMapSafelyInternalMethod = Bundle.class.getMethod("readArrayMapSafelyInternal");
                sGetParcelReadArrayMapSafelyInternalMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                Log.i(TAG, "Failed to retrieve readArrayMapSafelyInternal method", e);
            }
            sGetParcelReadArrayMapSafelyInternalMethodFetched = true;
        }

        if (sGetParcelReadArrayMapSafelyInternalMethod != null) {
            try {
                sGetParcelReadArrayMapSafelyInternalMethod.invoke(parcel, outVal, N, loader);
            } catch (InvocationTargetException | IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to invoke readArrayMapSafelyInternal via reflection", e);
                sGetParcelReadArrayMapSafelyInternalMethod = null;
            }
        }
    }

    private static Method sGetParcelReadArrayMapInternalMethod;
    private static boolean sGetParcelReadArrayMapInternalMethodFetched;
    /**
     * If the given Bundle's data is stored as a Parcel, unparcel them
     * using the given Bundle's currently assigned class loader.
     */
    /* package */ void readArrayMapInternal(Parcel parcel, android.util.ArrayMap outVal, int N,
                                            ClassLoader loader) {
        if (!sGetParcelReadArrayMapInternalMethodFetched) {
            try {
                sGetParcelReadArrayMapInternalMethod = Bundle.class.getMethod("readArrayMapInternal");
                sGetParcelReadArrayMapInternalMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                Log.i(TAG, "Failed to retrieve readArrayMapInternal method", e);
            }
            sGetParcelReadArrayMapInternalMethodFetched = true;
        }

        if (sGetParcelReadArrayMapInternalMethod != null) {
            try {
                sGetParcelReadArrayMapInternalMethod.invoke(parcel, outVal, N, loader);
            } catch (InvocationTargetException | IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to invoke readArrayMapInternal via reflection", e);
                sGetParcelReadArrayMapInternalMethod = null;
            }
        }
    }

    private void initializeFromParcelLocked(@NonNull Parcel parcelledData, boolean recycleParcel,
                                            boolean parcelledByNative) {
        if (LOG_DEFUSABLE && sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
            Slog.wtf(TAG, "Attempting to unparcel a Bundle while in transit; this may "
                    + "clobber all data inside!", new Throwable());
        }

        if (isEmptyParcel(parcelledData)) {
            if (DEBUG) {
                Log.d(TAG, "unparcel "
                        + Integer.toHexString(System.identityHashCode(this)) + ": empty");
            }
            if (mMap == null) {
                mMap = new ArrayMap<>(1);
            } else {
                mMap.erase();
            }
            mParcelledData = null;
            mParcelledByNative = false;
            return;
        }

        final int count = parcelledData.readInt();
        if (DEBUG) {
            Log.d(TAG, "unparcel " + Integer.toHexString(System.identityHashCode(this))
                    + ": reading " + count + " maps");
        }
        if (count < 0) {
            return;
        }
        ArrayMap<String, Object> map = mMap;
        if (map == null) {
            map = new ArrayMap<>(count);
        } else {
            map.erase();
            map.ensureCapacity(count);
        }
        try {
            if (parcelledByNative) {
                // If it was parcelled by native code, then the array map keys aren't sorted
                // by their hash codes, so use the safe (slow) one.
                android.util.ArrayMap<String, Object> x = map.toAndroidDotUtilDotArrayMap();
                readArrayMapSafelyInternal(parcelledData, x, count, mClassLoader);
                map.clear();
                map.putAll(x);
            } else {
                // If parcelled by Java, we know the contents are sorted properly,
                // so we can use ArrayMap.append().
                android.util.ArrayMap<String, Object> x = map.toAndroidDotUtilDotArrayMap();
                readArrayMapInternal(parcelledData, x, count, mClassLoader);
                map.clear();
                map.putAll(x);
            }
        } catch (BadParcelableException e) {
            if (sShouldDefuse) {
                Log.w(TAG, "Failed to parse Bundle, but defusing quietly", e);
                map.erase();
            } else {
                throw e;
            }
        } finally {
            mMap = map;
            if (recycleParcel) {
                recycleParcel(parcelledData);
            }
            mParcelledData = null;
            mParcelledByNative = false;
        }
        if (DEBUG) {
            Log.d(TAG, "unparcel " + Integer.toHexString(System.identityHashCode(this))
                    + " final map: " + mMap);
        }
    }

    /**
     * @hide
     */
    public boolean isParcelled() {
        return mParcelledData != null;
    }

    /**
     * @hide
     */
    public boolean isEmptyParcel() {
        return isEmptyParcel(mParcelledData);
    }

    /**
     * @hide
     */
    private static boolean isEmptyParcel(Parcel p) {
        return p == NoImagePreloadHolder.EMPTY_PARCEL;
    }

    private static boolean recycleParcel(Parcel p) {
        if (p != null && !isEmptyParcel(p)) {
            p.recycle();
            return true;
        }
        return false;
    }

    /** @hide */
    ArrayMap<String, Object> getMap() {
        unparcel();
        return mMap;
    }

    /**
     * Returns the number of mappings contained in this Bundle.
     *
     * @return the number of mappings as an int.
     */
    public int size() {
        unparcel();
        return mMap.size();
    }

    /**
     * Returns true if the mapping of this Bundle is empty, false otherwise.
     */
    public boolean isEmpty() {
        unparcel();
        return mMap.isEmpty();
    }

    /**
     * @hide this should probably be the implementation of isEmpty().  To do that we
     * need to ensure we always use the special empty parcel form when the bundle is
     * empty.  (This may already be the case, but to be safe we'll do this later when
     * we aren't trying to stabilize.)
     */
    public boolean maybeIsEmpty() {
        if (isParcelled()) {
            return isEmptyParcel();
        } else {
            return isEmpty();
        }
    }

    /**
     * Does a loose equality check between two given {@link BaseParcelableBundle} objects.
     * Returns {@code true} if both are {@code null}, or if both are equal as per
     * {@link #kindofEquals(BaseParcelableBundle)}
     *
     * @param a A {@link BaseParcelableBundle} object
     * @param b Another {@link BaseParcelableBundle} to compare with a
     * @return {@code true} if both are the same, {@code false} otherwise
     *
     * @see #kindofEquals(BaseParcelableBundle)
     *
     * @hide
     */
    public static boolean kindofEquals(BaseParcelableBundle a, BaseParcelableBundle b) {
        return (a == b) || (a != null && a.kindofEquals(b));
    }

    /**
     * @hide This kind-of does an equality comparison.  Kind-of.
     */
    public boolean kindofEquals(BaseParcelableBundle other) {
        if (other == null) {
            return false;
        }
        if (isParcelled() != other.isParcelled()) {
            // Big kind-of here!
            return false;
        } else if (isParcelled()) {
            {
//            return mParcelledData.compareData(other.mParcelledData) == 0;
                TODO.TODO();
                return false; // not reached
            }
        } else {
            return mMap.equals(other.mMap);
        }
    }

    /**
     * Removes all elements from the mapping of this Bundle.
     */
    public void clear() {
        unparcel();
        mMap.clear();
    }

    private static Field sGetBundleParcelledDataField;
    private static boolean sGetBundleParcelledDataFieldFetched;

    /**
     * obtains the current map from the given Bundle.
     *
     * @param bundle a Bundle
     * @return
     */
    Parcel getParcelledData(Bundle bundle) {
        if (!sGetBundleParcelledDataFieldFetched) {
            try {
                sGetBundleParcelledDataField = Bundle.class.getField("mParcelledData");
                sGetBundleParcelledDataField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mParcelledData field", e);
            }
            sGetBundleParcelledDataFieldFetched = true;
        }

        if (sGetBundleParcelledDataField != null) {
            try {
                return (Parcel) sGetBundleParcelledDataField.get(bundle);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mParcelledData via reflection", e);
                sGetBundleParcelledDataField = null;
            }
        }
        return null;
    }
    
    private static Field sGetBundleParcelledByNativeField;
    private static boolean sGetBundleParcelledByNativeFieldFetched;

    /**
     * obtains the current map from the given Bundle.
     *
     * @param bundle a Bundle
     * @return
     */
    boolean getParcelledByNative(Bundle bundle) {
        if (!sGetBundleParcelledByNativeFieldFetched) {
            try {
                sGetBundleParcelledByNativeField = Bundle.class.getField("mParcelledByNative");
                sGetBundleParcelledByNativeField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mParcelledByNative field", e);
            }
            sGetBundleParcelledByNativeFieldFetched = true;
        }

        if (sGetBundleParcelledByNativeField != null) {
            try {
                return (boolean) sGetBundleParcelledByNativeField.get(bundle);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mParcelledByNative via reflection", e);
                sGetBundleParcelledByNativeField = null;
            }
        }
        return false;
    }

    private static Field sGetBundleClassLoaderField;
    private static boolean sGetBundleClassLoaderFieldFetched;

    /**
     * obtains the current map from the given Bundle.
     *
     * @param bundle a Bundle
     * @return
     */
    ClassLoader getClassLoader(Bundle bundle) {
        if (!sGetBundleClassLoaderFieldFetched) {
            try {
                sGetBundleClassLoaderField = Bundle.class.getField("mClassLoader");
                sGetBundleClassLoaderField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mClassLoader field", e);
            }
            sGetBundleClassLoaderFieldFetched = true;
        }

        if (sGetBundleClassLoaderField != null) {
            try {
                return (ClassLoader) sGetBundleClassLoaderField.get(bundle);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mClassLoader via reflection", e);
                sGetBundleClassLoaderField = null;
            }
        }
        return null;
    }
    
    @RequiresApi(api = Build.VERSION_CODES.O)
    void copyInternal(Bundle from, boolean deep) {
        synchronized (from) {
            // TODO: copy internalParcel
            TODO.TODO();
            if (mParcelledData != NoImagePreloadHolder.EMPTY_PARCEL) mParcelledData.recycle();
            Parcel fromParcelledData = getParcelledData(from);
            if (fromParcelledData != null) {
                Parcel tmp = Parcel.obtain();
                if (fromParcelledData == tmp) {
                    tmp.recycle();
                    mParcelledData = NoImagePreloadHolder.EMPTY_PARCEL;
                    mParcelledByNative = false;
                } else {
                    tmp.recycle();
                    mParcelledData = Parcel.obtain();
                    mParcelledData.appendFrom(fromParcelledData, 0,
                            fromParcelledData.dataSize());
                    mParcelledData.setDataPosition(0);
                    mParcelledByNative = getParcelledByNative(from);
                }
            } else {
                mParcelledData = null;
                mParcelledByNative = false;
            }

            final ArrayMap<String, Object> map = getMap(from);

            if (map != null) {
                if (!deep) {
                    mMap = new ArrayMap<>(map);
                } else {
                    final ArrayMap<String, Object> fromMap = mMap;
                    final int N = fromMap.size();
                    mMap = new ArrayMap<>(N);
                    for (int i = 0; i < N; i++) {
                        mMap.append(fromMap.keyAt(i), deepCopyValue(fromMap.valueAt(i)));
                    }
                }
            } else {
                mMap = null;
            }

            mClassLoader = getClassLoader(from);
        }
    }

    private static Field sGetPersistableBundleParcelledDataField;
    private static boolean sGetPersistableBundleParcelledDataFieldFetched;

    /**
     * obtains the current map from the given PersistableBundle.
     *
     * @param persistableBundle a PersistableBundle
     * @return
     */
    Parcel getParcelledData(PersistableBundle persistableBundle) {
        if (!sGetPersistableBundleParcelledDataFieldFetched) {
            try {
                sGetPersistableBundleParcelledDataField = PersistableBundle.class.getField("mParcelledData");
                sGetPersistableBundleParcelledDataField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mParcelledData field", e);
            }
            sGetPersistableBundleParcelledDataFieldFetched = true;
        }

        if (sGetPersistableBundleParcelledDataField != null) {
            try {
                return (Parcel) sGetPersistableBundleParcelledDataField.get(persistableBundle);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mParcelledData via reflection", e);
                sGetPersistableBundleParcelledDataField = null;
            }
        }
        return null;
    }

    private static Field sGetPersistableBundleParcelledByNativeField;
    private static boolean sGetPersistableBundleParcelledByNativeFieldFetched;

    /**
     * obtains the current map from the given PersistableBundle.
     *
     * @param persistableBundle a PersistableBundle
     * @return
     */
    boolean getParcelledByNative(PersistableBundle persistableBundle) {
        if (!sGetPersistableBundleParcelledByNativeFieldFetched) {
            try {
                sGetPersistableBundleParcelledByNativeField = PersistableBundle.class.getField("mParcelledByNative");
                sGetPersistableBundleParcelledByNativeField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mParcelledByNative field", e);
            }
            sGetPersistableBundleParcelledByNativeFieldFetched = true;
        }

        if (sGetPersistableBundleParcelledByNativeField != null) {
            try {
                return (boolean) sGetPersistableBundleParcelledByNativeField.get(persistableBundle);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mParcelledByNative via reflection", e);
                sGetPersistableBundleParcelledByNativeField = null;
            }
        }
        return false;
    }

    private static Field sGetPersistableBundleClassLoaderField;
    private static boolean sGetPersistableBundleClassLoaderFieldFetched;

    /**
     * obtains the current map from the given PersistableBundle.
     *
     * @param persistableBundle a PersistableBundle
     * @return
     */
    ClassLoader getClassLoader(PersistableBundle persistableBundle) {
        if (!sGetPersistableBundleClassLoaderFieldFetched) {
            try {
                sGetPersistableBundleClassLoaderField = PersistableBundle.class.getField("mClassLoader");
                sGetPersistableBundleClassLoaderField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mClassLoader field", e);
            }
            sGetPersistableBundleClassLoaderFieldFetched = true;
        }

        if (sGetPersistableBundleClassLoaderField != null) {
            try {
                return (ClassLoader) sGetPersistableBundleClassLoaderField.get(persistableBundle);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mClassLoader via reflection", e);
                sGetPersistableBundleClassLoaderField = null;
            }
        }
        return null;
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    void copyInternal(PersistableBundle from, boolean deep) {
        synchronized (from) {
            Parcel fromParcelledData = getParcelledData(from);
            if (fromParcelledData != null) {
                Parcel tmp = Parcel.obtain();
                if (fromParcelledData == tmp) {
                    tmp.recycle();
                    mParcelledData = NoImagePreloadHolder.EMPTY_PARCEL;
                    mParcelledByNative = false;
                } else {
                    tmp.recycle();
                    mParcelledData = Parcel.obtain();
                    mParcelledData.appendFrom(fromParcelledData, 0,
                            fromParcelledData.dataSize());
                    mParcelledData.setDataPosition(0);
                    mParcelledByNative = getParcelledByNative(from);
                }
            } else {
                mParcelledData = null;
                mParcelledByNative = false;
            }

            final ArrayMap<String, Object> map = getMap(from);

            if (map != null) {
                if (!deep) {
                    mMap = new ArrayMap<>(map);
                } else {
                    final ArrayMap<String, Object> fromMap = mMap;
                    final int N = fromMap.size();
                    mMap = new ArrayMap<>(N);
                    for (int i = 0; i < N; i++) {
                        mMap.append(fromMap.keyAt(i), deepCopyValue(fromMap.valueAt(i)));
                    }
                }
            } else {
                mMap = null;
            }

            mClassLoader = getClassLoader(from);
        }
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    void copyInternal(BaseParcelableBundle from, boolean deep) {
        synchronized (from) {
            if (from.mParcelledData != null) {
                if (from.isEmptyParcel()) {
                    mParcelledData = NoImagePreloadHolder.EMPTY_PARCEL;
                    mParcelledByNative = false;
                } else {
                    mParcelledData = Parcel.obtain();
                    mParcelledData.appendFrom(from.mParcelledData, 0,
                            from.mParcelledData.dataSize());
                    mParcelledData.setDataPosition(0);
                    mParcelledByNative = from.mParcelledByNative;
                }
            } else {
                mParcelledData = null;
                mParcelledByNative = false;
            }

            if (from.mMap != null) {
                if (!deep) {
                    mMap = new ArrayMap<>(from.mMap);
                } else {
                    final ArrayMap<String, Object> fromMap = from.mMap;
                    final int N = fromMap.size();
                    mMap = new ArrayMap<>(N);
                    for (int i = 0; i < N; i++) {
                        mMap.append(fromMap.keyAt(i), deepCopyValue(fromMap.valueAt(i)));
                    }
                }
            } else {
                mMap = null;
            }

            mClassLoader = from.mClassLoader;
        }
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    Object deepCopyValue(Object value) {
        if (value == null) {
            return null;
        }
        if (value instanceof Bundle) {
            return ((Bundle)value).deepCopy();
        } else if (value instanceof PersistableBundle) {
            return ((PersistableBundle)value).deepCopy();
        } else if (value instanceof ParcelableBundle) {
            return ((ParcelableBundle)value).deepCopy();
        } else if (value instanceof ArrayList) {
            return deepcopyArrayList((ArrayList) value);
        } else if (value.getClass().isArray()) {
            if (value instanceof int[]) {
                return ((int[])value).clone();
            } else if (value instanceof long[]) {
                return ((long[])value).clone();
            } else if (value instanceof float[]) {
                return ((float[])value).clone();
            } else if (value instanceof double[]) {
                return ((double[])value).clone();
            } else if (value instanceof Object[]) {
                return ((Object[])value).clone();
            } else if (value instanceof byte[]) {
                return ((byte[])value).clone();
            } else if (value instanceof short[]) {
                return ((short[])value).clone();
            } else if (value instanceof char[]) {
                return ((char[]) value).clone();
            }
        }
        return value;
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    ArrayList deepcopyArrayList(ArrayList from) {
        final int N = from.size();
        ArrayList out = new ArrayList(N);
        for (int i=0; i<N; i++) {
            out.add(deepCopyValue(from.get(i)));
        }
        return out;
    }

    /**
     * Returns true if the given key is contained in the mapping
     * of this Bundle.
     *
     * @param key a String key
     * @return true if the key is part of the mapping, false otherwise
     */
    public boolean containsKey(String key) {
        unparcel();
        return mMap.containsKey(key);
    }

    /**
     * Returns the entry with the given key as an object.
     *
     * @param key a String key
     * @return an Object, or null
     */
    @Nullable
    public Object get(String key) {
        unparcel();
        return mMap.get(key);
    }

    /**
     * Removes any entry with the given key from the mapping of this Bundle.
     *
     * @param key a String key
     */
    public void remove(String key) {
        unparcel();
        mMap.remove(key);
    }
    
    private static Field sGetBundleArrayMapField;
    private static boolean sGetBundleArrayMapFieldFetched;
    
    /**
     * obtains the current map from the given Bundle.
     *
     * @param bundle a Bundle
     * @return
     */
    ArrayMap<String, Object> getMap(Bundle bundle) {
        if (!sGetBundleArrayMapFieldFetched) {
            try {
                sGetBundleArrayMapField = Bundle.class.getField("mMap");
                sGetBundleArrayMapField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mMap field", e);
            }
            sGetBundleArrayMapFieldFetched = true;
        }

        if (sGetBundleArrayMapField != null) {
            try {
                return (ArrayMap<String, Object>) sGetBundleArrayMapField.get(bundle);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mMap via reflection", e);
                sGetBundleArrayMapField = null;
            }
        }
        return null;
    }

    private static Field sGetPersistableBundleArrayMapField;
    private static boolean sGetPersistableBundleArrayMapFieldFetched;

    /**
     * obtains the current map from the given PersistableBundle.
     *
     * @param bundle a PersistableBundle
     * @return
     */
    ArrayMap<String, Object> getMap(PersistableBundle bundle) {
        if (!sGetPersistableBundleArrayMapFieldFetched) {
            try {
                sGetPersistableBundleArrayMapField = PersistableBundle.class.getField("mMap");
                sGetPersistableBundleArrayMapField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mMap field", e);
            }
            sGetPersistableBundleArrayMapFieldFetched = true;
        }

        if (sGetPersistableBundleArrayMapField != null) {
            try {
                return (ArrayMap<String, Object>) sGetPersistableBundleArrayMapField.get(bundle);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mMap via reflection", e);
                sGetPersistableBundleArrayMapField = null;
            }
        }
        return null;
    }

    /**
     * Inserts all mappings from the given PersistableBundle into this BaseParcelableBundle.
     *
     * @param bundle a PersistableBundle
     */
    public void putAll(Bundle bundle) {
        unparcel();
        unparcel(bundle);
        mMap.putAll(getMap(bundle));
    }

    /**
     * Inserts all mappings from the given PersistableBundle into this BaseParcelableBundle.
     *
     * @param bundle a PersistableBundle
     */
    public void putAll(PersistableBundle bundle) {
        unparcel();
        unparcel(bundle);
        mMap.putAll(getMap(bundle));
    }

    /**
     * Inserts all mappings from the given Map into this BaseParcelableBundle.
     *
     * @param map a Map
     */
    void putAll(ArrayMap map) {
        unparcel();
        mMap.putAll(map);
    }

    /**
     * Returns a Set containing the Strings used as keys in this Bundle.
     *
     * @return a Set of String keys
     */
    public Set<String> keySet() {
        unparcel();
        return mMap.keySet();
    }

    /**
     * Inserts a Boolean value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a boolean
     */
    public void putBoolean(@Nullable String key, boolean value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a byte value into the mapping of this Bundle, replacing
     * any existing value for the given key.
     *
     * @param key a String, or null
     * @param value a byte
     */
    void putByte(@Nullable String key, byte value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a char value into the mapping of this Bundle, replacing
     * any existing value for the given key.
     *
     * @param key a String, or null
     * @param value a char
     */
    void putChar(@Nullable String key, char value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a short value into the mapping of this Bundle, replacing
     * any existing value for the given key.
     *
     * @param key a String, or null
     * @param value a short
     */
    void putShort(@Nullable String key, short value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts an int value into the mapping of this Bundle, replacing
     * any existing value for the given key.
     *
     * @param key a String, or null
     * @param value an int
     */
    public void putInt(@Nullable String key, int value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a long value into the mapping of this Bundle, replacing
     * any existing value for the given key.
     *
     * @param key a String, or null
     * @param value a long
     */
    public void putLong(@Nullable String key, long value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a float value into the mapping of this Bundle, replacing
     * any existing value for the given key.
     *
     * @param key a String, or null
     * @param value a float
     */
    void putFloat(@Nullable String key, float value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a double value into the mapping of this Bundle, replacing
     * any existing value for the given key.
     *
     * @param key a String, or null
     * @param value a double
     */
    public void putDouble(@Nullable String key, double value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a String value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a String, or null
     */
    public void putString(@Nullable String key, @Nullable String value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a CharSequence value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a CharSequence, or null
     */
    void putCharSequence(@Nullable String key, @Nullable CharSequence value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts an ArrayList<Integer> value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value an ArrayList<Integer> object, or null
     */
    void putIntegerArrayList(@Nullable String key, @Nullable ArrayList<Integer> value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts an ArrayList<String> value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value an ArrayList<String> object, or null
     */
    void putStringArrayList(@Nullable String key, @Nullable ArrayList<String> value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts an ArrayList<CharSequence> value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value an ArrayList<CharSequence> object, or null
     */
    void putCharSequenceArrayList(@Nullable String key, @Nullable ArrayList<CharSequence> value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a Serializable value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a Serializable object, or null
     */
    void putSerializable(@Nullable String key, @Nullable Serializable value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a boolean array value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a boolean array object, or null
     */
    public void putBooleanArray(@Nullable String key, @Nullable boolean[] value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a byte array value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a byte array object, or null
     */
    void putByteArray(@Nullable String key, @Nullable byte[] value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a short array value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a short array object, or null
     */
    void putShortArray(@Nullable String key, @Nullable short[] value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a char array value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a char array object, or null
     */
    void putCharArray(@Nullable String key, @Nullable char[] value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts an int array value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value an int array object, or null
     */
    public void putIntArray(@Nullable String key, @Nullable int[] value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a long array value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a long array object, or null
     */
    public void putLongArray(@Nullable String key, @Nullable long[] value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a float array value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a float array object, or null
     */
    void putFloatArray(@Nullable String key, @Nullable float[] value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a double array value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a double array object, or null
     */
    public void putDoubleArray(@Nullable String key, @Nullable double[] value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a String array value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a String array object, or null
     */
    public void putStringArray(@Nullable String key, @Nullable String[] value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Inserts a CharSequence array value into the mapping of this Bundle, replacing
     * any existing value for the given key.  Either key or value may be null.
     *
     * @param key a String, or null
     * @param value a CharSequence array object, or null
     */
    void putCharSequenceArray(@Nullable String key, @Nullable CharSequence[] value) {
        unparcel();
        mMap.put(key, value);
    }

    /**
     * Returns the value associated with the given key, or false if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @return a boolean value
     */
    public boolean getBoolean(String key) {
        unparcel();
        if (DEBUG) Log.d(TAG, "Getting boolean in "
                + Integer.toHexString(System.identityHashCode(this)));
        return getBoolean(key, false);
    }

    // Log a message if the value was non-null but not of the expected type
    void typeWarning(String key, Object value, String className,
                     Object defaultValue, ClassCastException e) {
        StringBuilder sb = new StringBuilder();
        sb.append("Key ");
        sb.append(key);
        sb.append(" expected ");
        sb.append(className);
        sb.append(" but value was a ");
        sb.append(value.getClass().getName());
        sb.append(".  The default value ");
        sb.append(defaultValue);
        sb.append(" was returned.");
        Log.w(TAG, sb.toString());
        Log.w(TAG, "Attempt to cast generated internal exception:", e);
    }

    void typeWarning(String key, Object value, String className,
                     ClassCastException e) {
        typeWarning(key, value, className, "<null>", e);
    }

    /**
     * Returns the value associated with the given key, or defaultValue if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @param defaultValue Value to return if key does not exist
     * @return a boolean value
     */
    public boolean getBoolean(String key, boolean defaultValue) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return defaultValue;
        }
        try {
            return (Boolean) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "Boolean", defaultValue, e);
            return defaultValue;
        }
    }

    /**
     * Returns the value associated with the given key, or (byte) 0 if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @return a byte value
     */
    byte getByte(String key) {
        unparcel();
        return getByte(key, (byte) 0);
    }

    /**
     * Returns the value associated with the given key, or defaultValue if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @param defaultValue Value to return if key does not exist
     * @return a byte value
     */
    Byte getByte(String key, byte defaultValue) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return defaultValue;
        }
        try {
            return (Byte) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "Byte", defaultValue, e);
            return defaultValue;
        }
    }

    /**
     * Returns the value associated with the given key, or (char) 0 if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @return a char value
     */
    char getChar(String key) {
        unparcel();
        return getChar(key, (char) 0);
    }

    /**
     * Returns the value associated with the given key, or defaultValue if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @param defaultValue Value to return if key does not exist
     * @return a char value
     */
    char getChar(String key, char defaultValue) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return defaultValue;
        }
        try {
            return (Character) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "Character", defaultValue, e);
            return defaultValue;
        }
    }

    /**
     * Returns the value associated with the given key, or (short) 0 if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @return a short value
     */
    short getShort(String key) {
        unparcel();
        return getShort(key, (short) 0);
    }

    /**
     * Returns the value associated with the given key, or defaultValue if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @param defaultValue Value to return if key does not exist
     * @return a short value
     */
    short getShort(String key, short defaultValue) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return defaultValue;
        }
        try {
            return (Short) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "Short", defaultValue, e);
            return defaultValue;
        }
    }

    /**
     * Returns the value associated with the given key, or 0 if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @return an int value
     */
    public int getInt(String key) {
        unparcel();
        return getInt(key, 0);
    }

    /**
     * Returns the value associated with the given key, or defaultValue if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @param defaultValue Value to return if key does not exist
     * @return an int value
     */
    public int getInt(String key, int defaultValue) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return defaultValue;
        }
        try {
            return (Integer) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "Integer", defaultValue, e);
            return defaultValue;
        }
    }

    /**
     * Returns the value associated with the given key, or 0L if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @return a long value
     */
    public long getLong(String key) {
        unparcel();
        return getLong(key, 0L);
    }

    /**
     * Returns the value associated with the given key, or defaultValue if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @param defaultValue Value to return if key does not exist
     * @return a long value
     */
    public long getLong(String key, long defaultValue) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return defaultValue;
        }
        try {
            return (Long) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "Long", defaultValue, e);
            return defaultValue;
        }
    }

    /**
     * Returns the value associated with the given key, or 0.0f if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @return a float value
     */
    float getFloat(String key) {
        unparcel();
        return getFloat(key, 0.0f);
    }

    /**
     * Returns the value associated with the given key, or defaultValue if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @param defaultValue Value to return if key does not exist
     * @return a float value
     */
    float getFloat(String key, float defaultValue) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return defaultValue;
        }
        try {
            return (Float) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "Float", defaultValue, e);
            return defaultValue;
        }
    }

    /**
     * Returns the value associated with the given key, or 0.0 if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @return a double value
     */
    public double getDouble(String key) {
        unparcel();
        return getDouble(key, 0.0);
    }

    /**
     * Returns the value associated with the given key, or defaultValue if
     * no mapping of the desired type exists for the given key.
     *
     * @param key a String
     * @param defaultValue Value to return if key does not exist
     * @return a double value
     */
    public double getDouble(String key, double defaultValue) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return defaultValue;
        }
        try {
            return (Double) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "Double", defaultValue, e);
            return defaultValue;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a String value, or null
     */
    @Nullable
    public String getString(@Nullable String key) {
        unparcel();
        final Object o = mMap.get(key);
        try {
            return (String) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "String", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or defaultValue if
     * no mapping of the desired type exists for the given key or if a null
     * value is explicitly associated with the given key.
     *
     * @param key a String, or null
     * @param defaultValue Value to return if key does not exist or if a null
     *     value is associated with the given key.
     * @return the String value associated with the given key, or defaultValue
     *     if no valid String object is currently mapped to that key.
     */
    public String getString(@Nullable String key, String defaultValue) {
        final String s = getString(key);
        return (s == null) ? defaultValue : s;
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a CharSequence value, or null
     */
    @Nullable
    CharSequence getCharSequence(@Nullable String key) {
        unparcel();
        final Object o = mMap.get(key);
        try {
            return (CharSequence) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "CharSequence", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or defaultValue if
     * no mapping of the desired type exists for the given key or if a null
     * value is explicitly associated with the given key.
     *
     * @param key a String, or null
     * @param defaultValue Value to return if key does not exist or if a null
     *     value is associated with the given key.
     * @return the CharSequence value associated with the given key, or defaultValue
     *     if no valid CharSequence object is currently mapped to that key.
     */
    CharSequence getCharSequence(@Nullable String key, CharSequence defaultValue) {
        final CharSequence cs = getCharSequence(key);
        return (cs == null) ? defaultValue : cs;
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a Serializable value, or null
     */
    @Nullable
    Serializable getSerializable(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (Serializable) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "Serializable", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return an ArrayList<String> value, or null
     */
    @Nullable
    ArrayList<Integer> getIntegerArrayList(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (ArrayList<Integer>) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "ArrayList<Integer>", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return an ArrayList<String> value, or null
     */
    @Nullable
    ArrayList<String> getStringArrayList(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (ArrayList<String>) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "ArrayList<String>", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return an ArrayList<CharSequence> value, or null
     */
    @Nullable
    ArrayList<CharSequence> getCharSequenceArrayList(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (ArrayList<CharSequence>) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "ArrayList<CharSequence>", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a boolean[] value, or null
     */
    @Nullable
    public boolean[] getBooleanArray(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (boolean[]) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "byte[]", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a byte[] value, or null
     */
    @Nullable
    byte[] getByteArray(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (byte[]) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "byte[]", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a short[] value, or null
     */
    @Nullable
    short[] getShortArray(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (short[]) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "short[]", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a char[] value, or null
     */
    @Nullable
    char[] getCharArray(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (char[]) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "char[]", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return an int[] value, or null
     */
    @Nullable
    public int[] getIntArray(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (int[]) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "int[]", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a long[] value, or null
     */
    @Nullable
    public long[] getLongArray(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (long[]) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "long[]", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a float[] value, or null
     */
    @Nullable
    float[] getFloatArray(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (float[]) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "float[]", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a double[] value, or null
     */
    @Nullable
    public double[] getDoubleArray(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (double[]) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "double[]", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a String[] value, or null
     */
    @Nullable
    public String[] getStringArray(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (String[]) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "String[]", e);
            return null;
        }
    }

    /**
     * Returns the value associated with the given key, or null if
     * no mapping of the desired type exists for the given key or a null
     * value is explicitly associated with the key.
     *
     * @param key a String, or null
     * @return a CharSequence[] value, or null
     */
    @Nullable
    CharSequence[] getCharSequenceArray(@Nullable String key) {
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (CharSequence[]) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, "CharSequence[]", e);
            return null;
        }
    }

    private static Field sGetParcelReadWriteHelperField;
    private static boolean sGetParcelReadWriteHelperFieldFetched;

    /**
     * obtains the current ReadWriteHelper from the given Parcel.
     *
     * @param parcel a Parcel
     * @return
     */
    // ReadWriteHelper itself is annotated by @hide
    // so return an Object instead
    Object getReadWriteHelper(Parcel parcel) {
        if (!sGetParcelReadWriteHelperFieldFetched) {
            try {
                sGetParcelReadWriteHelperField = Parcel.class.getField("mReadWriteHelper");
                sGetParcelReadWriteHelperField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mMap field", e);
            }
            sGetParcelReadWriteHelperFieldFetched = true;
        }

        if (sGetParcelReadWriteHelperField != null) {
            try {
                return (ArrayMap<String, Object>) sGetParcelReadWriteHelperField.get(parcel);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mMap via reflection", e);
                sGetParcelReadWriteHelperField = null;
            }
        }
        return null;
    }

    /**
     * @return whether the given parcel has a ReadWriteHelper.
     *
     * @param parcel a Parcel
     * @hide
     */
    public boolean hasReadWriteHelper(Parcel parcel) {
        // ReadWriteHelper.DEFAULT is hidden, however it is the initialization value:
        //
        // private ReadWriteHelper mReadWriteHelper = ReadWriteHelper.DEFAULT
        //
        // so assuming that an obtained Parcel is freshly initialized and does not contain
        // data left over from previous uses, comparing the obtained parcel's reader should be
        // equivalent to comparing against ReadWriteHelper.DEFAULT
        //
        Object mReadWriteHelper = getReadWriteHelper(parcel);
        Parcel tmp = Parcel.obtain();
        boolean r = (mReadWriteHelper != null) && (mReadWriteHelper != getReadWriteHelper(tmp));
        tmp.recycle();
        return r;
    }

    private static Method sGetParcelWriteArrayMapInternalMethod;
    private static boolean sGetParcelWriteArrayMapInternalMethodFetched;
    /**
     * If the given Bundle's data is stored as a Parcel, unparcel them
     * using the given Bundle's currently assigned class loader.
     */
    /* package */ void writeArrayMapInternal(Parcel parcel, ArrayMap<String, Object> map) {
        if (!sGetParcelWriteArrayMapInternalMethodFetched) {
            try {
                sGetParcelWriteArrayMapInternalMethod = Bundle.class.getMethod("writeArrayMapInternal");
                sGetParcelWriteArrayMapInternalMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                Log.i(TAG, "Failed to retrieve writeArrayMapInternal method", e);
            }
            sGetParcelWriteArrayMapInternalMethodFetched = true;
        }

        if (sGetParcelWriteArrayMapInternalMethod != null) {
            try {
                sGetParcelWriteArrayMapInternalMethod.invoke(parcel, map);
            } catch (InvocationTargetException | IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to invoke writeArrayMapInternal via reflection", e);
                sGetParcelWriteArrayMapInternalMethod = null;
            }
        }
    }

    class ParcelReader {
        Parcel parcel;
        int length;
        int magic;
        boolean isJavaBundle;
        boolean isNativeBundle;

        int dataPosition = 0;

        public ParcelReader(Parcel parcel, int length) {
            this.parcel = parcel;
            this.length = length;
        }

        void saveDataPosition() {
            dataPosition = parcel.dataPosition();
        }

        void restoreDataPosition() {
            parcel.setDataPosition(dataPosition);
        }

        boolean magicIsValid(int magic) {
            return isJavaBundle || isNativeBundle;
        }

        /**
         * returns true if the magic is valid, false otherwise
         * <br>
         * equivalent to
         * <pre>
return hasData() && magicIsValid(getMagic())
// the above return statement is functionally equivalent to:
//
// if (hasData() == false) return false;
// int magic = getMagic();
// return magicIsValid(magic);
//
         * </pre>
         * <br>
         * advances the data position, restores after read
         */
        public boolean hasNext() {
            return hasData() && magicIsValid(getMagic());
        }

        /**
         * advances the data position, restores after read
         */
        Parcel get() {
            saveDataPosition();
            Parcel x = read();
            restoreDataPosition();
            return x;
        }

        /**
         * reads into a new parcel, advancing the data position, does not restore after read
         * <br>
         * returns the new parcel for convenience, can return null
         */
        Parcel read() {
            return read(null);
        }

        /**
         * reads into the given parcel, advancing the data position, does not restore after read
         * <br>
         * returns the given parcel for convenience, can return null
         */
        Parcel read(Parcel parcelToReadInto) {
            // read magic
            readMagic();
            if (hasReadWriteHelper(parcel)) {
                // If the parcel has a read-write helper, then we can't lazily-unparcel it, so just
                // unparcel right away.
                synchronized (this) {
                    TODO.TODO(); // allow this to work with the parcel reader
                    initializeFromParcelLocked(parcel, /*recycleParcel=*/ false, isNativeBundle);
                }
                return null;
            }

            // Advance within this Parcel
            int offset = parcel.dataPosition();
            parcel.setDataPosition(MathUtils.addOrThrow(offset, length));

            Parcel p;
            if (parcelToReadInto == null) {
                p = Parcel.obtain();
            } else {
                parcelToReadInto.setDataSize(0);
                p = parcelToReadInto;
            }

            p.setDataPosition(0);
            p.appendFrom(parcel, offset, length);
            adoptClassCookies(p, parcel);
            if (DEBUG) Log.d(TAG, "Retrieving "  + Integer.toHexString(System.identityHashCode(this))
                    + ": " + length + " bundle bytes starting at " + offset);
            p.setDataPosition(0);
            return p;
        }

        public boolean hasData() {
            return parcel.dataAvail() != 0;
        }

        /**
         * advances the data position, restores after read
         */
        public int getMagic() {
            saveDataPosition();
            readMagic();
            restoreDataPosition();
            return magic;
        }

        /**
         * advances the data position, does not restore after read
         */
        public int readMagic() {
            magic = parcel.readInt();
            isJavaBundle = magic == BUNDLE_MAGIC;
            isNativeBundle = magic == BUNDLE_MAGIC_NATIVE;
            return magic;
        }
    }

    ParcelReader createParcelReader(Parcel parcel, int length) {
        return new ParcelReader(parcel, length);
    }

    /**
     * @param parcel the parcel to read from
     * @param length
     */
    private void readParcels(Parcel parcel, int length) {
        if (DEBUG) Log.i(TAG, "readParcels: reading parcels");
        ParcelReader parcelReader = createParcelReader(parcel, length);
        ArrayList<Parcel> parcels = new ArrayList(0);
        queryParcel(parcels);
        for (Parcel value : parcels) {
            if (parcelReader.hasNext()) {
                parcelReader.read(value);
            } else throw new IllegalStateException("Bad magic number for Bundle: 0x"
                    + Integer.toHexString(parcelReader.getMagic()));
        }

        // our mParcelledData is always read last

        mParcelledByNative = parcelReader.isNativeBundle;
    }

    void renewParcels() {
        internalParcel = NoImagePreloadHolder.EMPTY_PARCEL;
        mParcelledData = NoImagePreloadHolder.EMPTY_PARCEL;
    }

    private void readFromParcelInner(Parcel parcel, int length) {
        // TODO: write and read multiple parcels
        TODO.TODO();
        if (length < 0) {
            throw new RuntimeException("Bad length in parcel: " + length);

        } else if (length == 0) {
            // Empty Bundle or end of data.
            renewParcels();
            mParcelledByNative = false;
            return;
        }

        readParcels(parcel, length);
    }

    /**
     * appends parcelFrom to parcel
     * @param parcel a parcel
     * @param parcelFrom the parcel to write to parcel
     * @return true if parcel is not initially null, otherwise false
     */
    final boolean writeParcel(Parcel parcel, Parcel parcelFrom) {
        if (parcelFrom != null) {
            if (parcelFrom == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length_ = parcelFrom.dataSize();
                parcel.writeInt(length_);
                // TODO: mParcelledByNative for other parcels
                parcel.writeInt(mParcelledByNative ? BUNDLE_MAGIC_NATIVE : BUNDLE_MAGIC);
                parcel.appendFrom(parcelFrom, 0, length_);
            }
            return true;
        }
        return false;
    }

    /**
     * query's parcels for reading and writing
     * <br>
     * parcels are written, and read, in the order they are added
     * <br>
     * Overriding methods should call super as follows
     * <pre>
&#064;Override
void queryParcel(ArrayList<Parcel> parcels) {
    parcels.add(info);
    super.queryParcel(parcels);
}
     * </pre>
     * @param parcels add your parcels to this array
     */
    @CallSuper
    void queryParcel(ArrayList<Parcel> parcels) {
        parcels.add(internalParcel);
        parcels.add(mParcelledData);
    }

    /**
     * @param parcel a parcel to write to
     * @return true if the caller should return, false otherwise
     */
    private boolean writeParcels(Parcel parcel) {
        if (DEBUG) Log.i(TAG, "writeParcels: writing parcels");
        ArrayList<Parcel> parcels = new ArrayList(0);
        queryParcel(parcels);
        boolean written = true;
        for (Parcel value : parcels) {
            if (!writeParcel(parcel, value))
                if (written) written = false;
        }
        return written;
    }

    /**
     * Reads the Parcel contents into this Bundle, typically in order for
     * it to be passed through an IBinder connection.
     * @param parcel The parcel to overwrite this bundle from.
     */
    void readFromParcelInner(Parcel parcel) {
        // Keep implementation in sync with readFromParcel() in
        // frameworks/native/libs/binder/PersistableBundle.cpp.
        int length = parcel.readInt();
        readFromParcelInner(parcel, length);
    }

    /**
     * Writes the Bundle contents to a Parcel, typically in order for
     * it to be passed through an IBinder connection.
     * @param parcel The parcel to copy this bundle to.
     */
    void writeToParcelInner(Parcel parcel, int flags) {
        // If the parcel has a read-write helper, we can't just copy the blob, so unparcel it first.
        // hasReadWriteHelper is annotated by @hide
        // however the variable it accesses is not
        if (hasReadWriteHelper(parcel)) {
            unparcel();
        }
        // Keep implementation in sync with writeToParcel() in
        // frameworks/native/libs/binder/PersistableBundle.cpp.
        final ArrayMap<String, Object> map;
        synchronized (this) {
            // unparcel() can race with this method and cause the parcel to recycle
            // at the wrong time. So synchronize access the mParcelledData's content.
            if (writeParcels(parcel)) return;
            map = mMap;
        }

        // Special case for empty bundles.
        if (map == null || map.size() <= 0) {
            parcel.writeInt(0);
            return;
        }
        int lengthPos = parcel.dataPosition();
        parcel.writeInt(-1); // dummy, will hold length
        parcel.writeInt(BUNDLE_MAGIC);

        int startPos = parcel.dataPosition();
        writeArrayMapInternal(parcel, map);
        int endPos = parcel.dataPosition();

        // Backpatch length
        parcel.setDataPosition(lengthPos);
        int length = endPos - startPos;
        parcel.writeInt(length);
        parcel.setDataPosition(endPos);
    }

    private static Field sGetParcelClassCookiesField;
    private static boolean sGetParcelClassCookiesFieldFetched;

    /** @hide */
    android.util.ArrayMap<Class, Object> getClassCookies(Parcel parcel) {
        if (!sGetParcelClassCookiesFieldFetched) {
            try {
                sGetParcelClassCookiesField = Parcel.class.getField("mClassCookies");
                sGetParcelClassCookiesField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mClassCookies field", e);
            }
            sGetParcelClassCookiesFieldFetched = true;
        }

        if (sGetParcelClassCookiesField != null) {
            try {
                return (android.util.ArrayMap<Class, Object>) sGetParcelClassCookiesField.get(parcel);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mClassCookies via reflection", e);
                sGetParcelClassCookiesField = null;
            }
        }
        return null;
    }

    /** @hide */
    void adoptClassCookies(Parcel parcelA, Parcel parcelB) {
        if (!sGetParcelClassCookiesFieldFetched) {
            try {
                sGetParcelClassCookiesField = Parcel.class.getField("mClassCookies");
                sGetParcelClassCookiesField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mClassCookies field", e);
            }
            sGetParcelClassCookiesFieldFetched = true;
        }

        if (sGetParcelClassCookiesField != null) {
            try {
                sGetParcelClassCookiesField.set(parcelA, sGetParcelClassCookiesField.get(parcelB));
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get and set mClassCookies via reflection", e);
                sGetParcelClassCookiesField = null;
            }
        }
    }

    /** @hide */
    void putClassCookies(Parcel parcelA, Parcel parcelB, Map<Class, Object> cookies) {
        if (cookies == null) {
            return;
        }
        if (!sGetParcelClassCookiesFieldFetched) {
            try {
                sGetParcelClassCookiesField = Parcel.class.getField("mClassCookies");
                sGetParcelClassCookiesField.setAccessible(true);
            } catch (NoSuchFieldException e) {
                Log.i(TAG, "Failed to retrieve mClassCookies field", e);
            }
            sGetParcelClassCookiesFieldFetched = true;
        }

        if (sGetParcelClassCookiesField != null) {
            try {
                android.util.ArrayMap<Class, Object> mClassCookies =
                        (android.util.ArrayMap<Class, Object>) sGetParcelClassCookiesField.get(parcelA);
                if (mClassCookies == null) {
                    mClassCookies = new android.util.ArrayMap<>();
                }
                mClassCookies.putAll(cookies);
                sGetParcelClassCookiesField.set(parcelA, mClassCookies);
            } catch (IllegalAccessException
                    | IllegalArgumentException e) {
                Log.i(TAG, "Failed to get mClassCookies via reflection", e);
                sGetParcelClassCookiesField = null;
            }
        }
    }

    /** {@hide} */
    public static void dumpStats(IndentingPrintWriter pw, String key, Object value) {
        final Parcel tmp = Parcel.obtain();
        tmp.writeValue(value);
        final int size = tmp.dataPosition();
        tmp.recycle();

        // We only really care about logging large values
        if (size > 1024) {
            pw.println(key + " [size=" + size + "]");
            if (value instanceof BaseParcelableBundle) {
                dumpStats(pw, (BaseParcelableBundle) value);
            } else if (value instanceof SparseArray) {
                dumpStats(pw, (SparseArray) value);
            }
        }
    }

    /** {@hide} */
    public static void dumpStats(IndentingPrintWriter pw, SparseArray array) {
        pw.increaseIndent();
        if (array == null) {
            pw.println("[null]");
            return;
        }
        for (int i = 0; i < array.size(); i++) {
            dumpStats(pw, "0x" + Integer.toHexString(array.keyAt(i)), array.valueAt(i));
        }
        pw.decreaseIndent();
    }

    /** {@hide} */
    public static void dumpStats(IndentingPrintWriter pw, BaseParcelableBundle bundle) {
        pw.println("dumping...");
        pw.increaseIndent();
        if (bundle == null) {
            pw.println("[null]");
            return;
        }
        final ArrayMap<String, Object> map = bundle.getMap();
        pw.println("map: " + map);
        for (int i = 0; i < map.size(); i++) {
            dumpStats(pw, map.keyAt(i), map.valueAt(i));
        }
        pw.decreaseIndent();
        pw.println("dumped");
    }

    Parcel internalParcel = Parcel.obtain();

    @RequiresApi(api = Build.VERSION_CODES.O)
    Bundle toBundle() {
        Bundle bundle = new Bundle(size());
        synchronized (this) {
            getMap(bundle).putAll(mMap);
            final Parcel parcelledData = getParcelledData(bundle);
            // TODO: order parcels to correctly write and read in all cases
            parcelledData.appendFrom(mParcelledData, 0, mParcelledData.dataSize());
            parcelledData.appendFrom(internalParcel, 0, internalParcel.dataSize());
            parcelledData.setDataPosition(0);
        }
        return bundle;
    }

    boolean recycleCalled;

    /**
     * Put a Parcel object back into the pool.  You must not touch
     * the object after this call.
     * <br>
     * <br>
     * this method is called on finalization.
     * <br>
     * subsequent calls have no effect
     */
    public void recycle() {
        if (!recycleCalled) {
            internalParcel.recycle();
            recycleCalled = true;
        }
    }

    /**
     * Called by the garbage collector on an object when garbage collection
     * determines that there are no more references to the object.
     * A subclass overrides the {@code finalize} method to dispose of
     * system resources or to perform other cleanup.
     * <p>
     * The general contract of {@code finalize} is that it is invoked
     * if and when the Java&trade; virtual
     * machine has determined that there is no longer any
     * means by which this object can be accessed by any thread that has
     * not yet died, except as a result of an action taken by the
     * finalization of some other object or class which is ready to be
     * finalized. The {@code finalize} method may take any action, including
     * making this object available again to other threads; the usual purpose
     * of {@code finalize}, however, is to perform cleanup actions before
     * the object is irrevocably discarded. For example, the finalize method
     * for an object that represents an input/output connection might perform
     * explicit I/O transactions to break the connection before the object is
     * permanently discarded.
     * <p>
     * The {@code finalize} method of class {@code Object} performs no
     * special action; it simply returns normally. Subclasses of
     * {@code Object} may override this definition.
     * <p>
     * The Java programming language does not guarantee which thread will
     * invoke the {@code finalize} method for any given object. It is
     * guaranteed, however, that the thread that invokes finalize will not
     * be holding any user-visible synchronization locks when finalize is
     * invoked. If an uncaught exception is thrown by the finalize method,
     * the exception is ignored and finalization of that object terminates.
     * <p>
     * After the {@code finalize} method has been invoked for an object, no
     * further action is taken until the Java virtual machine has again
     * determined that there is no longer any means by which this object can
     * be accessed by any thread that has not yet died, including possible
     * actions by other objects or classes which are ready to be finalized,
     * at which point the object may be discarded.
     * <p>
     * The {@code finalize} method is never invoked more than once by a Java
     * virtual machine for any given object.
     * <p>
     * Any exception thrown by the {@code finalize} method causes
     * the finalization of this object to be halted, but is otherwise
     * ignored.
     *
     * @throws Throwable the {@code Exception} raised by this method
     * @jls 12.6 Finalization of Class Instances
     * @see WeakReference
     * @see PhantomReference
     */
    @Override
    protected void finalize() throws Throwable {
        if (!recycleCalled) internalParcel.recycle();
        super.finalize();
    }
}